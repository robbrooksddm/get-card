import {
  EMPTY,
  Observable,
  Preview$1,
  Subject,
  WithReferringDocuments,
  __awaiter,
  __generator,
  __spread,
  _arrayLikeToArray,
  _classCallCheck,
  _createClass,
  _createSuper,
  _defineProperty,
  _extends,
  _inherits,
  _objectWithoutPropertiesLoose,
  _typeof,
  _unsupportedIterableToArray,
  bufferTime,
  catchError,
  current,
  debounceTime,
  definePlugin,
  delay,
  empty,
  filter,
  first,
  from,
  iif,
  index,
  isDraft,
  isDraftable,
  map,
  merge,
  mergeMap,
  nanoid,
  observeOn,
  of,
  produce,
  queueScheduler,
  require_hoist_non_react_statics_cjs,
  require_prop_types,
  require_with_selector,
  subscribeOn,
  switchMap,
  takeUntil,
  throwError,
  useClient,
  useColorSchemeValue,
  useDocumentStore,
  useFormValue,
  useIntentLink,
  useSchema,
  v4_default,
  withLatestFrom
} from "./chunk-M6Z42PUE.js";
import "./chunk-CC6OETLG.js";
import "./chunk-DG3JXI3H.js";
import {
  Box,
  Button,
  Card,
  Checkbox,
  Container,
  Dialog,
  Flex,
  Grid,
  Inline,
  Label,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuItem,
  Popover,
  Portal,
  PortalProvider,
  Spinner,
  Stack,
  Switch,
  Tab,
  TabList,
  TabPanel,
  Text,
  TextArea,
  TextInput,
  Tooltip,
  autoUpdate,
  dt,
  ft,
  hues,
  lt,
  rem,
  studioTheme,
  useLayer,
  useMediaIndex,
  usePortal,
  useToast,
  white
} from "./chunk-QUKWXKKN.js";
import {
  AddIcon,
  ArrowDownIcon,
  ArrowUpIcon,
  CheckmarkCircleIcon,
  ChevronDownIcon,
  ChevronUpIcon,
  ClipboardIcon,
  CloseIcon,
  ComposeIcon,
  DownloadIcon,
  EditIcon,
  ErrorOutlineIcon,
  Icon,
  ImageIcon,
  PlugIcon,
  SearchIcon,
  SelectIcon,
  SortIcon,
  ThLargeIcon,
  ThListIcon,
  TrashIcon,
  UploadIcon,
  WarningFilledIcon,
  WarningOutlineIcon
} from "./chunk-ES2RO3Q4.js";
import "./chunk-QCOMQ3TD.js";
import {
  require_react_dom
} from "./chunk-DZ2TJJLL.js";
import {
  require_jsx_runtime
} from "./chunk-X4XPQ7QW.js";
import {
  require_react
} from "./chunk-LEOBW45C.js";
import {
  __commonJS,
  __publicField,
  __require,
  __toESM
} from "./chunk-5IKWDFCZ.js";

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module) {
    (function(root, pluralize2) {
      if (typeof __require === "function" && typeof exports === "object" && typeof module === "object") {
        module.exports = pluralize2();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize2();
        });
      } else {
        root.pluralize = pluralize2();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token2) {
        if (word === token2) return token2;
        if (word === word.toLowerCase()) return token2.toLowerCase();
        if (word === word.toUpperCase()) return token2.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match3, index2) {
          return args[index2] || "";
        });
      }
      function replace2(word, rule) {
        return word.replace(rule[0], function(match3, index2) {
          var result = interpolate(rule[1], arguments);
          if (match3 === "") {
            return restoreCase(word[index2 - 1], result);
          }
          return restoreCase(match3, result);
        });
      }
      function sanitizeWord(token2, word, rules) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word)) return replace2(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) return true;
          if (replaceMap.hasOwnProperty(token2)) return false;
          return sanitizeWord(token2, token2, rules) === token2;
        };
      }
      function pluralize2(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i3 = 0; i3 < selection.rangeCount; i3++) {
        ranges.push(selection.getRangeAt(i3));
      }
      switch (active.tagName.toUpperCase()) {
        // .toUpperCase handles XHTML
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format2(message2) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message2.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy3(text, options2) {
      var debug, message2, reselectPrevious, range, selection, mark, success = false;
      if (!options2) {
        options2 = {};
      }
      debug = options2.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options2.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format3 = clipboardToIE11Formatting[options2.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format3, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options2.format, text);
            }
          }
          if (options2.onCopy) {
            e2.preventDefault();
            options2.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options2.format || "text", text);
          options2.onCopy && options2.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message2 = format2("message" in options2 ? options2.message : defaultMessage);
          window.prompt(message2, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy3;
  }
});

// node_modules/attr-accept/dist/es/index.js
var require_es = __commonJS({
  "node_modules/attr-accept/dist/es/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = function(file, acceptedFiles) {
      if (file && acceptedFiles) {
        var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
        if (acceptedFilesArray.length === 0) {
          return true;
        }
        var fileName = file.name || "";
        var mimeType = (file.type || "").toLowerCase();
        var baseMimeType = mimeType.replace(/\/.*$/, "");
        return acceptedFilesArray.some(function(type) {
          var validType = type.trim().toLowerCase();
          if (validType.charAt(0) === ".") {
            return fileName.toLowerCase().endsWith(validType);
          } else if (validType.endsWith("/*")) {
            return baseMimeType === validType.replace(/\/.*$/, "");
          }
          return mimeType === validType;
        });
      }
      return true;
    };
  }
});

// node_modules/sanity-plugin-media/dist/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);

// node_modules/groq/lib/groq.js
function groq(strings2, ...keys) {
  const lastIndex = strings2.length - 1;
  return strings2.slice(0, lastIndex).reduce((acc, str, i3) => acc + str + keys[i3], "") + strings2[lastIndex];
}

// node_modules/react-redux/dist/react-redux.mjs
var React = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var IS_REACT_19 = React.version.startsWith("19");
var REACT_ELEMENT_TYPE = Symbol.for(
  IS_REACT_19 ? "react.transitional.element" : "react.element"
);
var REACT_PORTAL_TYPE = Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
var REACT_CONTEXT_TYPE = Symbol.for("react.context");
var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = Symbol.for(
  "react.suspense_list"
);
var REACT_MEMO_TYPE = Symbol.for("react.memo");
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = Symbol.for(
  "react.client.reference"
);
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first2 = null;
  let last = null;
  return {
    clear() {
      first2 = null;
      last = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener2 = first2;
        while (listener2) {
          listener2.callback();
          listener2 = listener2.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener2 = first2;
      while (listener2) {
        listeners.push(listener2);
        listener2 = listener2.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener2 = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener2.prev) {
        listener2.prev.next = listener2;
      } else {
        first2 = listener2;
      }
      return function unsubscribe() {
        if (!isSubscribed || first2 === null) return;
        isSubscribed = false;
        if (listener2.next) {
          listener2.next.prev = listener2.prev;
        } else {
          last = listener2.prev;
        }
        if (listener2.prev) {
          listener2.prev.next = listener2.next;
        } else {
          first2 = listener2.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener2) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener2);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React.useLayoutEffect : React.useEffect;
var useIsomorphicLayoutEffect = getUseIsomorphicLayoutEffect();
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
var objectPrototype = Object.prototype;
var ContextKey = Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!React.createContext) return {};
  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
  let realContext = contextMap.get(React.createContext);
  if (!realContext) {
    realContext = React.createContext(
      null
    );
    if (true) {
      realContext.displayName = "ReactRedux";
    }
    contextMap.set(React.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = getContext();
function Provider(providerProps) {
  const { children, context, serverState, store } = providerProps;
  const contextValue = React.useMemo(() => {
    const subscription = createSubscription(store);
    const baseContextValue = {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
    if (false) {
      return baseContextValue;
    } else {
      const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
      return Object.assign(baseContextValue, {
        stabilityCheck,
        identityFunctionCheck
      });
    }
  }, [store, serverState]);
  const previousState = React.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return React.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = React.useContext(context);
    if (!contextValue) {
      throw new Error(
        "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
      );
    }
    return contextValue;
  };
}
var useReduxContext = createReduxContextHook();
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context)
  );
  const useStore2 = () => {
    const { store } = useReduxContext2();
    return store;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  const useDispatch2 = () => {
    const store = useStore2();
    return store.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = createDispatchHook();
var refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    if (true) {
      if (!selector) {
        throw new Error(`You must pass a selector to useSelector`);
      }
      if (typeof selector !== "function") {
        throw new Error(`You must pass a function as a selector to useSelector`);
      }
      if (typeof equalityFn !== "function") {
        throw new Error(
          `You must pass a function as an equality function to useSelector`
        );
      }
    }
    const reduxContext = useReduxContext2();
    const { store, subscription, getServerState } = reduxContext;
    const firstRun = React.useRef(true);
    const wrappedSelector = React.useCallback(
      {
        [selector.name](state) {
          const selected = selector(state);
          if (true) {
            const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
            const { identityFunctionCheck, stabilityCheck } = reduxContext;
            const {
              identityFunctionCheck: finalIdentityFunctionCheck,
              stabilityCheck: finalStabilityCheck
            } = {
              stabilityCheck,
              identityFunctionCheck,
              ...devModeChecks
            };
            if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
              const toCompare = selector(state);
              if (!equalityFn(selected, toCompare)) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                  {
                    state,
                    selected,
                    selected2: toCompare,
                    stack
                  }
                );
              }
            }
            if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
              if (selected === state) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                  { stack }
                );
              }
            }
            if (firstRun.current) firstRun.current = false;
          }
          return selected;
        }
      }[selector.name],
      [selector]
    );
    const selectedState = (0, import_with_selector.useSyncExternalStoreWithSelector)(
      subscription.addNestedSub,
      store.getState,
      getServerState || store.getState,
      wrappedSelector,
      equalityFn
    );
    React.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = createSelectorHook();

// node_modules/redux/dist/redux.mjs
var $$observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer2, preloadedState, enhancer) {
  if (typeof reducer2 !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer2)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer2, preloadedState);
  }
  let currentReducer = reducer2;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener2, key) => {
        nextListeners.set(key, listener2);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener2) {
    if (typeof listener2 !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener2)}'`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener2);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(false ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener2) => {
      listener2();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function warning(message2) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message2);
  }
  try {
    throw new Error(message2);
  } catch (e2) {
  }
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers2, action, unexpectedKeyCache) {
  const reducerKeys = Object.keys(reducers2);
  const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
  if (reducerKeys.length === 0) {
    return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
  }
  if (!isPlainObject(inputState)) {
    return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
  }
  const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers2.hasOwnProperty(key) && !unexpectedKeyCache[key]);
  unexpectedKeys.forEach((key) => {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === actionTypes_default.REPLACE)
    return;
  if (unexpectedKeys.length > 0) {
    return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
  }
}
function assertReducerShape(reducers2) {
  Object.keys(reducers2).forEach((key) => {
    const reducer2 = reducers2[key];
    const initialState4 = reducer2(void 0, {
      type: actionTypes_default.INIT
    });
    if (typeof initialState4 === "undefined") {
      throw new Error(false ? formatProdErrorMessage(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
    }
    if (typeof reducer2(void 0, {
      type: actionTypes_default.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(false ? formatProdErrorMessage(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
    }
  });
}
function combineReducers(reducers2) {
  const reducerKeys = Object.keys(reducers2);
  const finalReducers = {};
  for (let i3 = 0; i3 < reducerKeys.length; i3++) {
    const key = reducerKeys[i3];
    if (true) {
      if (typeof reducers2[key] === "undefined") {
        warning(`No reducer provided for key "${key}"`);
      }
    }
    if (typeof reducers2[key] === "function") {
      finalReducers[key] = reducers2[key];
    }
  }
  const finalReducerKeys = Object.keys(finalReducers);
  let unexpectedKeyCache;
  if (true) {
    unexpectedKeyCache = {};
  }
  let shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    if (true) {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning(warningMessage);
      }
    }
    let hasChanged = false;
    const nextState = {};
    for (let i3 = 0; i3 < finalReducerKeys.length; i3++) {
      const key = finalReducerKeys[i3];
      const reducer2 = finalReducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer2(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        const actionType = action && action.type;
        throw new Error(false ? formatProdErrorMessage(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b2) => (...args) => a2(b2(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer2, preloadedState) => {
    const store = createStore2(reducer2, preloadedState);
    let dispatch = () => {
      throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    };
    const chain = middlewares.map((middleware2) => middleware2(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);
    return {
      ...store,
      dispatch
    };
  };
}
function isAction(action) {
  return isPlainObject(action) && "type" in action && typeof action.type === "string";
}

// node_modules/reselect/dist/reselect.mjs
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e2) {
        ;
        ({ stack } = e2);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
var runInputStabilityCheck = (inputSelectorResultsObject, options2, inputSelectorArgs) => {
  const { memoize: memoize2, memoizeOptions } = options2;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize2(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e2) {
      ;
      ({ stack } = e2);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
var NOT_FOUND = Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
  if (typeof object !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array.every((item) => typeof item === "function")) {
    const itemTypes = array.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length: length2 } = dependencies;
  for (let i3 = 0; i3 < length2; i3++) {
    inputSelectorResults.push(dependencies[i3].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
var REDUX_PROXY_LABEL = Symbol();
var proto = Object.getPrototypeOf({});
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options2 = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options2;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a;
    let cacheNode = fnNode;
    const { length: length2 } = arguments;
    for (let i3 = 0, l2 = length2; i3 < l2; i3++) {
      const arg = arguments[i3];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = ((_a = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a.call(lastResult)) ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize: memoize2,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize2(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (true) {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize: memoize2, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize: memoize2,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key) => inputSelectorsObject[key]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index2) => {
          composition[inputSelectorKeys[index2]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);

// node_modules/redux-thunk/dist/redux-thunk.mjs
function createThunkMiddleware(extraArgument) {
  const middleware2 = ({ dispatch, getState }) => (next2) => (action) => {
    if (typeof action === "function") {
      return action(dispatch, getState, extraArgument);
    }
    return next2(action);
  };
  return middleware2;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;

// node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs
var createDraftSafeSelectorCreator = (...args) => {
  const createSelector2 = createSelectorCreator(...args);
  const createDraftSafeSelector2 = Object.assign((...args2) => {
    const selector = createSelector2(...args2);
    const wrappedSelector = (value, ...rest) => selector(isDraft(value) ? current(value) : value, ...rest);
    Object.assign(wrappedSelector, selector);
    return wrappedSelector;
  }, {
    withTypes: () => createDraftSafeSelector2
  });
  return createDraftSafeSelector2;
};
var createDraftSafeSelector = createDraftSafeSelectorCreator(weakMapMemoize);
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0) return void 0;
  if (typeof arguments[0] === "object") return compose;
  return compose.apply(null, arguments);
};
var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
  return function(noop32) {
    return noop32;
  };
};
var hasMatchFunction = (v2) => {
  return v2 && typeof v2.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator(...args) {
    if (prepareAction) {
      let prepared = prepareAction(...args);
      if (!prepared) {
        throw new Error(false ? formatProdErrorMessage(0) : "prepareAction did not return an object");
      }
      return {
        type,
        payload: prepared.payload,
        ..."meta" in prepared && {
          meta: prepared.meta
        },
        ..."error" in prepared && {
          error: prepared.error
        }
      };
    }
    return {
      type,
      payload: args[0]
    };
  }
  actionCreator.toString = () => `${type}`;
  actionCreator.type = type;
  actionCreator.match = (action) => isAction(action) && action.type === type;
  return actionCreator;
}
function isActionCreator(action) {
  return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
  hasMatchFunction(action);
}
function getMessage(type) {
  const splitType = type ? `${type}`.split("/") : [];
  const actionName = splitType[splitType.length - 1] || "actionCreator";
  return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options2 = {}) {
  if (false) {
    return () => (next2) => (action) => next2(action);
  }
  const {
    isActionCreator: isActionCreator2 = isActionCreator
  } = options2;
  return () => (next2) => (action) => {
    if (isActionCreator2(action)) {
      console.warn(getMessage(action.type));
    }
    return next2(action);
  };
}
function getTimeMeasureUtils(maxDelay, fnName) {
  let elapsed = 0;
  return {
    measureTime(fn2) {
      const started = Date.now();
      try {
        return fn2();
      } finally {
        const finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
      }
    }
  };
}
var Tuple = class _Tuple extends Array {
  constructor(...items) {
    super(...items);
    Object.setPrototypeOf(this, _Tuple.prototype);
  }
  static get [Symbol.species]() {
    return _Tuple;
  }
  concat(...arr) {
    return super.concat.apply(this, arr);
  }
  prepend(...arr) {
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new _Tuple(...arr[0].concat(this));
    }
    return new _Tuple(...arr.concat(this));
  }
};
function freezeDraftable(val) {
  return isDraftable(val) ? produce(val, () => {
  }) : val;
}
function getOrInsertComputed(map2, key, compute) {
  if (map2.has(key)) return map2.get(key);
  return map2.set(key, compute(key)).get(key);
}
function isImmutableDefault(value) {
  return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations() {
      return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
  const tracked = {
    value: obj
  };
  if (!isImmutable(obj) && !checkedObjects.has(obj)) {
    checkedObjects.add(obj);
    tracked.children = {};
    for (const key in obj) {
      const childPath = path ? path + "." + key : key;
      if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
        continue;
      }
      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }
  return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
  const prevObj = trackedProperty ? trackedProperty.value : void 0;
  const sameRef = prevObj === obj;
  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path
    };
  }
  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  }
  const keysToDetect = {};
  for (let key in trackedProperty.children) {
    keysToDetect[key] = true;
  }
  for (let key in obj) {
    keysToDetect[key] = true;
  }
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (let key in keysToDetect) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
    if (result.wasMutated) {
      return result;
    }
  }
  return {
    wasMutated: false
  };
}
function createImmutableStateInvariantMiddleware(options2 = {}) {
  if (false) {
    return () => (next2) => (action) => next2(action);
  } else {
    let stringify22 = function(obj, serializer, indent, decycler) {
      return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
    }, getSerialize2 = function(serializer, decycler) {
      let stack = [], keys = [];
      if (!decycler) decycler = function(_2, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function(key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value)) value = decycler.call(this, key, value);
        } else stack.push(value);
        return serializer == null ? value : serializer.call(this, key, value);
      };
    };
    var stringify2 = stringify22, getSerialize = getSerialize2;
    let {
      isImmutable = isImmutableDefault,
      ignoredPaths,
      warnAfter = 32
    } = options2;
    const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
    return ({
      getState
    }) => {
      let state = getState();
      let tracker = track(state);
      let result;
      return (next2) => (action) => {
        const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        const dispatchedAction = next2(action);
        measureUtils.measureTime(() => {
          state = getState();
          result = tracker.detectMutations();
          tracker = track(state);
          if (result.wasMutated) {
            throw new Error(false ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify22(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
          }
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  }
}
function isPlain(val) {
  const type = typeof val;
  return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
}
function findNonSerializableValue(value, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {
  let foundNestedSerializable;
  if (!isSerializable(value)) {
    return {
      keyPath: path || "<root>",
      value
    };
  }
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (cache == null ? void 0 : cache.has(value)) return false;
  const entries = getEntries != null ? getEntries(value) : Object.entries(value);
  const hasIgnoredPaths = ignoredPaths.length > 0;
  for (const [key, nestedValue] of entries) {
    const nestedPath = path ? path + "." + key : key;
    if (hasIgnoredPaths) {
      const hasMatches = ignoredPaths.some((ignored) => {
        if (ignored instanceof RegExp) {
          return ignored.test(nestedPath);
        }
        return nestedPath === ignored;
      });
      if (hasMatches) {
        continue;
      }
    }
    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath,
        value: nestedValue
      };
    }
    if (typeof nestedValue === "object") {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }
  if (cache && isNestedFrozen(value)) cache.add(value);
  return false;
}
function isNestedFrozen(value) {
  if (!Object.isFrozen(value)) return false;
  for (const nestedValue of Object.values(value)) {
    if (typeof nestedValue !== "object" || nestedValue === null) continue;
    if (!isNestedFrozen(nestedValue)) return false;
  }
  return true;
}
function createSerializableStateInvariantMiddleware(options2 = {}) {
  if (false) {
    return () => (next2) => (action) => next2(action);
  } else {
    const {
      isSerializable = isPlain,
      getEntries,
      ignoredActions = [],
      ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
      ignoredPaths = [],
      warnAfter = 32,
      ignoreState = false,
      ignoreActions = false,
      disableCache = false
    } = options2;
    const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
    return (storeAPI) => (next2) => (action) => {
      if (!isAction(action)) {
        return next2(action);
      }
      const result = next2(action);
      const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
      if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
        measureUtils.measureTime(() => {
          const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache);
          if (foundActionNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundActionNonSerializableValue;
            console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
          }
        });
      }
      if (!ignoreState) {
        measureUtils.measureTime(() => {
          const state = storeAPI.getState();
          const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache);
          if (foundStateNonSerializableValue) {
            const {
              keyPath,
              value
            } = foundStateNonSerializableValue;
            console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
          }
        });
        measureUtils.warnIfExceeded();
      }
      return result;
    };
  }
}
function isBoolean(x3) {
  return typeof x3 === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options2) {
  const {
    thunk: thunk2 = true,
    immutableCheck = true,
    serializableCheck = true,
    actionCreatorCheck = true
  } = options2 ?? {};
  let middlewareArray = new Tuple();
  if (thunk2) {
    if (isBoolean(thunk2)) {
      middlewareArray.push(thunk);
    } else {
      middlewareArray.push(withExtraArgument(thunk2.extraArgument));
    }
  }
  if (true) {
    if (immutableCheck) {
      let immutableOptions = {};
      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }
      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
    }
    if (serializableCheck) {
      let serializableOptions = {};
      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }
      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
    if (actionCreatorCheck) {
      let actionCreatorOptions = {};
      if (!isBoolean(actionCreatorCheck)) {
        actionCreatorOptions = actionCreatorCheck;
      }
      middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
    }
  }
  return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var createQueueWithTimer = (timeout) => {
  return (notify) => {
    setTimeout(notify, timeout);
  };
};
var autoBatchEnhancer = (options2 = {
  type: "raf"
}) => (next2) => (...args) => {
  const store = next2(...args);
  let notifying = true;
  let shouldNotifyAtEndOfTick = false;
  let notificationQueued = false;
  const listeners = /* @__PURE__ */ new Set();
  const queueCallback = options2.type === "tick" ? queueMicrotask : options2.type === "raf" ? (
    // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
    typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
  ) : options2.type === "callback" ? options2.queueNotification : createQueueWithTimer(options2.timeout);
  const notifyListeners = () => {
    notificationQueued = false;
    if (shouldNotifyAtEndOfTick) {
      shouldNotifyAtEndOfTick = false;
      listeners.forEach((l2) => l2());
    }
  };
  return Object.assign({}, store, {
    // Override the base `store.subscribe` method to keep original listeners
    // from running if we're delaying notifications
    subscribe(listener2) {
      const wrappedListener = () => notifying && listener2();
      const unsubscribe = store.subscribe(wrappedListener);
      listeners.add(listener2);
      return () => {
        unsubscribe();
        listeners.delete(listener2);
      };
    },
    // Override the base `store.dispatch` method so that we can check actions
    // for the `shouldAutoBatch` flag and determine if batching is active
    dispatch(action) {
      var _a;
      try {
        notifying = !((_a = action == null ? void 0 : action.meta) == null ? void 0 : _a[SHOULD_AUTOBATCH]);
        shouldNotifyAtEndOfTick = !notifying;
        if (shouldNotifyAtEndOfTick) {
          if (!notificationQueued) {
            notificationQueued = true;
            queueCallback(notifyListeners);
          }
        }
        return store.dispatch(action);
      } finally {
        notifying = true;
      }
    }
  });
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options2) {
  const {
    autoBatch = true
  } = options2 ?? {};
  let enhancerArray = new Tuple(middlewareEnhancer);
  if (autoBatch) {
    enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
  }
  return enhancerArray;
};
function configureStore(options2) {
  const getDefaultMiddleware = buildGetDefaultMiddleware();
  const {
    reducer: reducer2 = void 0,
    middleware: middleware2,
    devTools = true,
    duplicateMiddlewareCheck = true,
    preloadedState = void 0,
    enhancers = void 0
  } = options2 || {};
  let rootReducer2;
  if (typeof reducer2 === "function") {
    rootReducer2 = reducer2;
  } else if (isPlainObject(reducer2)) {
    rootReducer2 = combineReducers(reducer2);
  } else {
    throw new Error(false ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
  }
  if (middleware2 && typeof middleware2 !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
  }
  let finalMiddleware;
  if (typeof middleware2 === "function") {
    finalMiddleware = middleware2(getDefaultMiddleware);
    if (!Array.isArray(finalMiddleware)) {
      throw new Error(false ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
    }
  } else {
    finalMiddleware = getDefaultMiddleware();
  }
  if (finalMiddleware.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
  }
  if (duplicateMiddlewareCheck) {
    let middlewareReferences = /* @__PURE__ */ new Set();
    finalMiddleware.forEach((middleware22) => {
      if (middlewareReferences.has(middleware22)) {
        throw new Error(false ? formatProdErrorMessage(42) : "Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
      }
      middlewareReferences.add(middleware22);
    });
  }
  let finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools({
      // Enable capture of stack traces for dispatched Redux actions
      trace: true,
      ...typeof devTools === "object" && devTools
    });
  }
  const middlewareEnhancer = applyMiddleware(...finalMiddleware);
  const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
  if (enhancers && typeof enhancers !== "function") {
    throw new Error(false ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
  }
  let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
  if (!Array.isArray(storeEnhancers)) {
    throw new Error(false ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
  }
  if (storeEnhancers.some((item) => typeof item !== "function")) {
    throw new Error(false ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
  }
  if (finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
    console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
  }
  const composedEnhancer = finalCompose(...storeEnhancers);
  return createStore(rootReducer2, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  const actionsMap = {};
  const actionMatchers = [];
  let defaultCaseReducer;
  const builder = {
    addCase(typeOrActionCreator, reducer2) {
      if (true) {
        if (actionMatchers.length > 0) {
          throw new Error(false ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
        }
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
        }
      }
      const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error(false ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error(false ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
      }
      actionsMap[type] = reducer2;
      return builder;
    },
    addMatcher(matcher, reducer2) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
        }
      }
      actionMatchers.push({
        matcher,
        reducer: reducer2
      });
      return builder;
    },
    addDefaultCase(reducer2) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error(false ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
        }
      }
      defaultCaseReducer = reducer2;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x3) {
  return typeof x3 === "function";
}
function createReducer(initialState4, mapOrBuilderCallback) {
  if (true) {
    if (typeof mapOrBuilderCallback === "object") {
      throw new Error(false ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
    }
  }
  let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
  let getInitialState;
  if (isStateFunction(initialState4)) {
    getInitialState = () => freezeDraftable(initialState4());
  } else {
    const frozenInitialState = freezeDraftable(initialState4);
    getInitialState = () => frozenInitialState;
  }
  function reducer2(state = getInitialState(), action) {
    let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
      matcher
    }) => matcher(action)).map(({
      reducer: reducer22
    }) => reducer22)];
    if (caseReducers.filter((cr2) => !!cr2).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce((previousState, caseReducer) => {
      if (caseReducer) {
        if (isDraft(previousState)) {
          const draft = previousState;
          const result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!isDraftable(previousState)) {
          const result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return produce(previousState, (draft) => {
            return caseReducer(draft, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer2.getInitialState = getInitialState;
  return reducer2;
}
var matches = (matcher, action) => {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf(...matchers) {
  return (action) => {
    return matchers.some((matcher) => matches(matcher, action));
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid2 = (size = 21) => {
  let id = "";
  let i3 = size;
  while (i3--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
};
var commonProperties = ["name", "message", "stack", "code"];
var RejectWithValue = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var FulfillWithMeta = class {
  constructor(payload, meta) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    __publicField(this, "_type");
    this.payload = payload;
    this.meta = meta;
  }
};
var miniSerializeError = (value) => {
  if (typeof value === "object" && value !== null) {
    const simpleError = {};
    for (const property of commonProperties) {
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return {
    message: String(value)
  };
};
var externalAbortMessage = "External signal was aborted";
var createAsyncThunk = (() => {
  function createAsyncThunk2(typePrefix, payloadCreator, options2) {
    const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
      payload,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "fulfilled"
      }
    }));
    const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
      payload: void 0,
      meta: {
        ...meta || {},
        arg,
        requestId,
        requestStatus: "pending"
      }
    }));
    const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
      payload,
      error: (options2 && options2.serializeError || miniSerializeError)(error || "Rejected"),
      meta: {
        ...meta || {},
        arg,
        requestId,
        rejectedWithValue: !!payload,
        requestStatus: "rejected",
        aborted: (error == null ? void 0 : error.name) === "AbortError",
        condition: (error == null ? void 0 : error.name) === "ConditionError"
      }
    }));
    function actionCreator(arg, {
      signal
    } = {}) {
      return (dispatch, getState, extra) => {
        const requestId = (options2 == null ? void 0 : options2.idGenerator) ? options2.idGenerator(arg) : nanoid2();
        const abortController = new AbortController();
        let abortHandler;
        let abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        if (signal) {
          if (signal.aborted) {
            abort(externalAbortMessage);
          } else {
            signal.addEventListener("abort", () => abort(externalAbortMessage), {
              once: true
            });
          }
        }
        const promise = async function() {
          var _a, _b;
          let finalAction;
          try {
            let conditionResult = (_a = options2 == null ? void 0 : options2.condition) == null ? void 0 : _a.call(options2, arg, {
              getState,
              extra
            });
            if (isThenable(conditionResult)) {
              conditionResult = await conditionResult;
            }
            if (conditionResult === false || abortController.signal.aborted) {
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            }
            const abortedPromise = new Promise((_2, reject) => {
              abortHandler = () => {
                reject({
                  name: "AbortError",
                  message: abortReason || "Aborted"
                });
              };
              abortController.signal.addEventListener("abort", abortHandler);
            });
            dispatch(pending(requestId, arg, (_b = options2 == null ? void 0 : options2.getPendingMeta) == null ? void 0 : _b.call(options2, {
              requestId,
              arg
            }, {
              getState,
              extra
            })));
            finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch,
              getState,
              extra,
              requestId,
              signal: abortController.signal,
              abort,
              rejectWithValue: (value, meta) => {
                return new RejectWithValue(value, meta);
              },
              fulfillWithValue: (value, meta) => {
                return new FulfillWithMeta(value, meta);
              }
            })).then((result) => {
              if (result instanceof RejectWithValue) {
                throw result;
              }
              if (result instanceof FulfillWithMeta) {
                return fulfilled(result.payload, requestId, arg, result.meta);
              }
              return fulfilled(result, requestId, arg);
            })]);
          } catch (err) {
            finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
          } finally {
            if (abortHandler) {
              abortController.signal.removeEventListener("abort", abortHandler);
            }
          }
          const skipDispatch = options2 && !options2.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
          if (!skipDispatch) {
            dispatch(finalAction);
          }
          return finalAction;
        }();
        return Object.assign(promise, {
          abort,
          requestId,
          arg,
          unwrap() {
            return promise.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      settled: isAnyOf(rejected, fulfilled),
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = () => createAsyncThunk2;
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var asyncThunkSymbol = Symbol.for("rtk-slice-createasyncthunk");
var asyncThunkCreator = {
  [asyncThunkSymbol]: createAsyncThunk
};
var ReducerType = ((ReducerType2) => {
  ReducerType2["reducer"] = "reducer";
  ReducerType2["reducerWithPrepare"] = "reducerWithPrepare";
  ReducerType2["asyncThunk"] = "asyncThunk";
  return ReducerType2;
})(ReducerType || {});
function getType(slice2, actionKey) {
  return `${slice2}/${actionKey}`;
}
function buildCreateSlice({
  creators
} = {}) {
  var _a;
  const cAT = (_a = creators == null ? void 0 : creators.asyncThunk) == null ? void 0 : _a[asyncThunkSymbol];
  return function createSlice2(options2) {
    const {
      name,
      reducerPath = name
    } = options2;
    if (!name) {
      throw new Error(false ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
    }
    if (typeof process !== "undefined" && true) {
      if (options2.initialState === void 0) {
        console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
      }
    }
    const reducers2 = (typeof options2.reducers === "function" ? options2.reducers(buildReducerCreators()) : options2.reducers) || {};
    const reducerNames = Object.keys(reducers2);
    const context = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    };
    const contextMethods = {
      addCase(typeOrActionCreator, reducer22) {
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(false ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
        }
        if (type in context.sliceCaseReducersByType) {
          throw new Error(false ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
        }
        context.sliceCaseReducersByType[type] = reducer22;
        return contextMethods;
      },
      addMatcher(matcher, reducer22) {
        context.sliceMatchers.push({
          matcher,
          reducer: reducer22
        });
        return contextMethods;
      },
      exposeAction(name2, actionCreator) {
        context.actionCreators[name2] = actionCreator;
        return contextMethods;
      },
      exposeCaseReducer(name2, reducer22) {
        context.sliceCaseReducersByName[name2] = reducer22;
        return contextMethods;
      }
    };
    reducerNames.forEach((reducerName) => {
      const reducerDefinition = reducers2[reducerName];
      const reducerDetails = {
        reducerName,
        type: getType(name, reducerName),
        createNotation: typeof options2.reducers === "function"
      };
      if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
        handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
      } else {
        handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
      }
    });
    function buildReducer() {
      if (true) {
        if (typeof options2.extraReducers === "object") {
          throw new Error(false ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
        }
      }
      const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options2.extraReducers === "function" ? executeReducerBuilderCallback(options2.extraReducers) : [options2.extraReducers];
      const finalCaseReducers = {
        ...extraReducers,
        ...context.sliceCaseReducersByType
      };
      return createReducer(options2.initialState, (builder) => {
        for (let key in finalCaseReducers) {
          builder.addCase(key, finalCaseReducers[key]);
        }
        for (let sM of context.sliceMatchers) {
          builder.addMatcher(sM.matcher, sM.reducer);
        }
        for (let m2 of actionMatchers) {
          builder.addMatcher(m2.matcher, m2.reducer);
        }
        if (defaultCaseReducer) {
          builder.addDefaultCase(defaultCaseReducer);
        }
      });
    }
    const selectSelf = (state) => state;
    const injectedSelectorCache = /* @__PURE__ */ new Map();
    const injectedStateCache = /* @__PURE__ */ new WeakMap();
    let _reducer;
    function reducer2(state, action) {
      if (!_reducer) _reducer = buildReducer();
      return _reducer(state, action);
    }
    function getInitialState() {
      if (!_reducer) _reducer = buildReducer();
      return _reducer.getInitialState();
    }
    function makeSelectorProps(reducerPath2, injected = false) {
      function selectSlice(state) {
        let sliceState = state[reducerPath2];
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
          } else if (true) {
            throw new Error(false ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
          }
        }
        return sliceState;
      }
      function getSelectors(selectState = selectSelf) {
        const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
        return getOrInsertComputed(selectorCache, selectState, () => {
          const map2 = {};
          for (const [name2, selector] of Object.entries(options2.selectors ?? {})) {
            map2[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
          }
          return map2;
        });
      }
      return {
        reducerPath: reducerPath2,
        getSelectors,
        get selectors() {
          return getSelectors(selectSlice);
        },
        selectSlice
      };
    }
    const slice2 = {
      name,
      reducer: reducer2,
      actions: context.actionCreators,
      caseReducers: context.sliceCaseReducersByName,
      getInitialState,
      ...makeSelectorProps(reducerPath),
      injectInto(injectable, {
        reducerPath: pathOpt,
        ...config
      } = {}) {
        const newReducerPath = pathOpt ?? reducerPath;
        injectable.inject({
          reducerPath: newReducerPath,
          reducer: reducer2
        }, config);
        return {
          ...slice2,
          ...makeSelectorProps(newReducerPath, true)
        };
      }
    };
    return slice2;
  };
}
function wrapSelector(selector, selectState, getInitialState, injected) {
  function wrapper(rootState, ...args) {
    let sliceState = selectState(rootState);
    if (typeof sliceState === "undefined") {
      if (injected) {
        sliceState = getInitialState();
      } else if (true) {
        throw new Error(false ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
      }
    }
    return selector(sliceState, ...args);
  }
  wrapper.unwrapped = selector;
  return wrapper;
}
var createSlice = buildCreateSlice();
function buildReducerCreators() {
  function asyncThunk(payloadCreator, config) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator,
      ...config
    };
  }
  asyncThunk.withTypes = () => asyncThunk;
  return {
    reducer(caseReducer) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [caseReducer.name](...args) {
          return caseReducer(...args);
        }
      }[caseReducer.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(prepare, reducer2) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare,
        reducer: reducer2
      };
    },
    asyncThunk
  };
}
function handleNormalReducerDefinition({
  type,
  reducerName,
  createNotation
}, maybeReducerWithPrepare, context) {
  let caseReducer;
  let prepareCallback;
  if ("reducer" in maybeReducerWithPrepare) {
    if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
      throw new Error(false ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
    }
    caseReducer = maybeReducerWithPrepare.reducer;
    prepareCallback = maybeReducerWithPrepare.prepare;
  } else {
    caseReducer = maybeReducerWithPrepare;
  }
  context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
  return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({
  type,
  reducerName
}, reducerDefinition, context, cAT) {
  if (!cAT) {
    throw new Error(false ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
  }
  const {
    payloadCreator,
    fulfilled,
    pending,
    rejected,
    settled,
    options: options2
  } = reducerDefinition;
  const thunk2 = cAT(type, payloadCreator, options2);
  context.exposeAction(reducerName, thunk2);
  if (fulfilled) {
    context.addCase(thunk2.fulfilled, fulfilled);
  }
  if (pending) {
    context.addCase(thunk2.pending, pending);
  }
  if (rejected) {
    context.addCase(thunk2.rejected, rejected);
  }
  if (settled) {
    context.addMatcher(thunk2.settled, settled);
  }
  context.exposeCaseReducer(reducerName, {
    fulfilled: fulfilled || noop,
    pending: pending || noop,
    rejected: rejected || noop,
    settled: settled || noop
  });
}
function noop() {
}
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = `task-${cancelled}`;
var taskCompleted = `task-${completed}`;
var listenerCancelled = `${listener}-${cancelled}`;
var listenerCompleted = `${listener}-${completed}`;
var assertFunction = (func, expected) => {
  if (typeof func !== "function") {
    throw new TypeError(false ? formatProdErrorMessage(32) : `${expected} is not a function`);
  }
};
var {
  assign
} = Object;
var alm = "listenerMiddleware";
var getListenerEntryPropsFrom = (options2) => {
  let {
    type,
    actionCreator,
    matcher,
    predicate,
    effect
  } = options2;
  if (type) {
    predicate = createAction(type).match;
  } else if (actionCreator) {
    type = actionCreator.type;
    predicate = actionCreator.match;
  } else if (matcher) {
    predicate = matcher;
  } else if (predicate) {
  } else {
    throw new Error(false ? formatProdErrorMessage(21) : "Creating or removing a listener requires one of the known fields for matching an action");
  }
  assertFunction(effect, "options.listener");
  return {
    predicate,
    type,
    effect
  };
};
var createListenerEntry = assign((options2) => {
  const {
    type,
    predicate,
    effect
  } = getListenerEntryPropsFrom(options2);
  const entry = {
    id: nanoid2(),
    effect,
    type,
    predicate,
    pending: /* @__PURE__ */ new Set(),
    unsubscribe: () => {
      throw new Error(false ? formatProdErrorMessage(22) : "Unsubscribe not initialized");
    }
  };
  return entry;
}, {
  withTypes: () => createListenerEntry
});
var addListener = assign(createAction(`${alm}/add`), {
  withTypes: () => addListener
});
var clearAllListeners = createAction(`${alm}/removeAll`);
var removeListener = assign(createAction(`${alm}/remove`), {
  withTypes: () => removeListener
});
var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");

// node_modules/redux-observable/dist/redux-observable.mjs
var StateObservable = class extends Observable {
  constructor(input$, initialState4) {
    super((subscriber) => {
      const subscription = this.__notifier.subscribe(subscriber);
      if (subscription && !subscription.closed) {
        subscriber.next(this.value);
      }
      return subscription;
    });
    __publicField(this, "value");
    __publicField(this, "__notifier", new Subject());
    this.value = initialState4;
    input$.subscribe((value) => {
      if (value !== this.value) {
        this.value = value;
        this.__notifier.next(value);
      }
    });
  }
};
function combineEpics(...epics) {
  const merger = (...args) => merge(
    ...epics.map((epic) => {
      const output$ = epic(...args);
      if (!output$) {
        throw new TypeError(
          `combineEpics: one of the provided Epics "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
        );
      }
      return output$;
    })
  );
  try {
    Object.defineProperty(merger, "name", {
      value: `combineEpics(${epics.map((epic) => epic.name || "<anonymous>").join(", ")})`
    });
  } catch (e2) {
  }
  return merger;
}
var consoleWarn = typeof console === "object" && typeof console.warn === "function" ? console.warn.bind(console) : () => {
};
var warn = (msg) => {
  consoleWarn(`redux-observable | WARNING: ${msg}`);
};
function createEpicMiddleware(options2 = {}) {
  const QueueScheduler = queueScheduler.constructor;
  const uniqueQueueScheduler = new QueueScheduler(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    queueScheduler.schedulerActionCtor
  );
  if (typeof options2 === "function") {
    throw new TypeError(
      "Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\n\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware"
    );
  }
  const epic$ = new Subject();
  let store;
  const epicMiddleware = (_store) => {
    if (store) {
      warn(
        "this middleware is already associated with a store. createEpicMiddleware should be called for every store.\n\nLearn more: https://goo.gl/2GQ7Da"
      );
    }
    store = _store;
    const actionSubject$ = new Subject();
    const stateSubject$ = new Subject();
    const action$ = actionSubject$.asObservable().pipe(observeOn(uniqueQueueScheduler));
    const state$ = new StateObservable(
      stateSubject$.pipe(observeOn(uniqueQueueScheduler)),
      store.getState()
    );
    const result$ = epic$.pipe(
      map((epic) => {
        const output$ = epic(action$, state$, options2.dependencies);
        if (!output$) {
          throw new TypeError(
            `Your root Epic "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
          );
        }
        return output$;
      }),
      mergeMap(
        (output$) => from(output$).pipe(
          subscribeOn(uniqueQueueScheduler),
          observeOn(uniqueQueueScheduler)
        )
      )
    );
    result$.subscribe(store.dispatch);
    return (next2) => {
      return (action) => {
        const result = next2(action);
        stateSubject$.next(store.getState());
        actionSubject$.next(action);
        return result;
      };
    };
  };
  epicMiddleware.run = (rootEpic2) => {
    if (!store) {
      warn(
        "epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first."
      );
    }
    epic$.next(rootEpic2);
  };
  return epicMiddleware;
}
function ofType(...types) {
  const len = types.length;
  if (true) {
    if (len === 0) {
      warn("ofType was called without any types!");
    }
    if (types.some((key) => key === null || key === void 0)) {
      warn("ofType was called with one or more undefined or null values!");
    }
  }
  return filter(
    len === 1 ? (action) => isAction(action) && action.type === types[0] : (action) => {
      if (isAction(action)) {
        for (let i3 = 0; i3 < len; i3++) {
          if (action.type === types[i3]) {
            return true;
          }
        }
      }
      return false;
    }
  );
}

// node_modules/sanity-plugin-media/dist/index.mjs
var import_pluralize = __toESM(require_pluralize(), 1);

// node_modules/@tanem/react-nprogress/dist/react-nprogress.esm.js
var React2 = __toESM(require_react());
var import_react = __toESM(require_react());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var clamp = function clamp2(num, lower, upper) {
  num = num <= upper ? num : upper;
  num = num >= lower ? num : lower;
  return num;
};
var createQueue = function createQueue2() {
  var isRunning = false;
  var pending = [];
  var _next = function next2() {
    isRunning = true;
    var cb = pending.shift();
    if (cb) {
      return cb(_next);
    }
    isRunning = false;
  };
  var clear = function clear2() {
    isRunning = false;
    pending = [];
  };
  var enqueue = function enqueue2(cb) {
    pending.push(cb);
    if (!isRunning && pending.length === 1) {
      _next();
    }
  };
  return {
    clear,
    enqueue
  };
};
var createTimeout = function createTimeout2() {
  var handle;
  var cancel = function cancel2() {
    if (handle) {
      window.cancelAnimationFrame(handle);
    }
  };
  var schedule = function schedule2(callback, delay2) {
    var deltaTime;
    var start;
    var _frame = function frame(time) {
      start = start || time;
      deltaTime = time - start;
      if (deltaTime > delay2) {
        callback();
        return;
      }
      handle = window.requestAnimationFrame(_frame);
    };
    handle = window.requestAnimationFrame(_frame);
  };
  return {
    cancel,
    schedule
  };
};
var increment = function increment2(progress) {
  var amount = 0;
  if (progress >= 0 && progress < 0.2) {
    amount = 0.1;
  } else if (progress >= 0.2 && progress < 0.5) {
    amount = 0.04;
  } else if (progress >= 0.5 && progress < 0.8) {
    amount = 0.02;
  } else if (progress >= 0.8 && progress < 0.99) {
    amount = 5e-3;
  }
  return clamp(progress + amount, 0, 0.994);
};
var useEffectOnce = function useEffectOnce2(effect) {
  (0, import_react.useEffect)(effect, []);
};
var incrementParameter = function incrementParameter2(num) {
  return ++num % 1e6;
};
var useUpdate = function useUpdate2() {
  var _useState = (0, import_react.useState)(0), setState = _useState[1];
  return (0, import_react.useCallback)(function() {
    return setState(incrementParameter);
  }, []);
};
var useGetSetState = function useGetSetState2(initialState4) {
  if (initialState4 === void 0) {
    initialState4 = {};
  }
  var update = useUpdate();
  var state = (0, import_react.useRef)(_extends({}, initialState4));
  var get2 = (0, import_react.useCallback)(function() {
    return state.current;
  }, []);
  var set2 = (0, import_react.useCallback)(function(patch) {
    if (!patch) {
      return;
    }
    Object.assign(state.current, patch);
    update();
  }, []);
  return [get2, set2];
};
var useFirstMountState = function useFirstMountState2() {
  var isFirst = (0, import_react.useRef)(true);
  if (isFirst.current) {
    isFirst.current = false;
    return true;
  }
  return isFirst.current;
};
var useUpdateEffect = function useUpdateEffect2(effect, deps) {
  var isFirstMount = useFirstMountState();
  (0, import_react.useEffect)(function() {
    if (!isFirstMount) {
      return effect();
    }
  }, deps);
};
var noop2 = function noop3() {
  return void 0;
};
var initialState = {
  isFinished: true,
  progress: 0,
  sideEffect: noop2
};
var useNProgress = function useNProgress2(_temp) {
  var _ref3 = _temp === void 0 ? {} : _temp, _ref$animationDuratio = _ref3.animationDuration, animationDuration = _ref$animationDuratio === void 0 ? 200 : _ref$animationDuratio, _ref$incrementDuratio = _ref3.incrementDuration, incrementDuration = _ref$incrementDuratio === void 0 ? 800 : _ref$incrementDuratio, _ref$isAnimating = _ref3.isAnimating, isAnimating = _ref$isAnimating === void 0 ? false : _ref$isAnimating, _ref$minimum = _ref3.minimum, minimum = _ref$minimum === void 0 ? 0.08 : _ref$minimum;
  var _useGetSetState = useGetSetState(initialState), get2 = _useGetSetState[0], setState = _useGetSetState[1];
  var queue = (0, import_react.useRef)(null);
  var timeout = (0, import_react.useRef)(null);
  useEffectOnce(function() {
    queue.current = createQueue();
    timeout.current = createTimeout();
  });
  var cleanup = (0, import_react.useCallback)(function() {
    var _timeout$current, _queue$current;
    (_timeout$current = timeout.current) == null || _timeout$current.cancel();
    (_queue$current = queue.current) == null || _queue$current.clear();
  }, []);
  var set2 = (0, import_react.useCallback)(function(n3) {
    var _queue$current4;
    n3 = clamp(n3, minimum, 1);
    if (n3 === 1) {
      var _queue$current2, _queue$current3;
      cleanup();
      (_queue$current2 = queue.current) == null || _queue$current2.enqueue(function(next2) {
        setState({
          progress: n3,
          sideEffect: function sideEffect2() {
            var _timeout$current2;
            return (_timeout$current2 = timeout.current) == null ? void 0 : _timeout$current2.schedule(next2, animationDuration);
          }
        });
      });
      (_queue$current3 = queue.current) == null || _queue$current3.enqueue(function() {
        setState({
          isFinished: true,
          sideEffect: cleanup
        });
      });
      return;
    }
    (_queue$current4 = queue.current) == null || _queue$current4.enqueue(function(next2) {
      setState({
        isFinished: false,
        progress: n3,
        sideEffect: function sideEffect2() {
          var _timeout$current3;
          return (_timeout$current3 = timeout.current) == null ? void 0 : _timeout$current3.schedule(next2, animationDuration);
        }
      });
    });
  }, [animationDuration, cleanup, minimum, queue, setState, timeout]);
  var trickle = (0, import_react.useCallback)(function() {
    set2(increment(get2().progress));
  }, [get2, set2]);
  var start = (0, import_react.useCallback)(function() {
    var _work = function work() {
      var _queue$current5;
      trickle();
      (_queue$current5 = queue.current) == null || _queue$current5.enqueue(function(next2) {
        var _timeout$current4;
        (_timeout$current4 = timeout.current) == null || _timeout$current4.schedule(function() {
          _work();
          next2();
        }, incrementDuration);
      });
    };
    _work();
  }, [incrementDuration, queue, timeout, trickle]);
  var savedTrickle = (0, import_react.useRef)(noop2);
  var sideEffect = get2().sideEffect;
  (0, import_react.useEffect)(function() {
    savedTrickle.current = trickle;
  });
  useEffectOnce(function() {
    if (isAnimating) {
      start();
    }
    return cleanup;
  });
  useUpdateEffect(function() {
    get2().sideEffect();
  }, [get2, sideEffect]);
  useUpdateEffect(function() {
    if (!isAnimating) {
      set2(1);
    } else {
      setState(_extends({}, initialState, {
        sideEffect: start
      }));
    }
  }, [isAnimating, set2, setState, start]);
  return {
    animationDuration,
    isFinished: get2().isFinished,
    progress: get2().progress
  };
};

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys(e2, r3) {
  var t3 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o3 = Object.getOwnPropertySymbols(e2);
    r3 && (o3 = o3.filter(function(r4) {
      return Object.getOwnPropertyDescriptor(e2, r4).enumerable;
    })), t3.push.apply(t3, o3);
  }
  return t3;
}
function _objectSpread2(e2) {
  for (var r3 = 1; r3 < arguments.length; r3++) {
    var t3 = null != arguments[r3] ? arguments[r3] : {};
    r3 % 2 ? ownKeys(Object(t3), true).forEach(function(r4) {
      _defineProperty(e2, r4, t3[r4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : ownKeys(Object(t3)).forEach(function(r4) {
      Object.defineProperty(e2, r4, Object.getOwnPropertyDescriptor(t3, r4));
    });
  }
  return e2;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r3) {
  if (Array.isArray(r3)) return r3;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r3, l2) {
  var t3 = null == r3 ? null : "undefined" != typeof Symbol && r3[Symbol.iterator] || r3["@@iterator"];
  if (null != t3) {
    var e2, n3, i3, u2, a2 = [], f2 = true, o3 = false;
    try {
      if (i3 = (t3 = t3.call(r3)).next, 0 === l2) {
        if (Object(t3) !== t3) return;
        f2 = false;
      } else for (; !(f2 = (e2 = i3.call(t3)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r4) {
      o3 = true, n3 = r4;
    } finally {
      try {
        if (!f2 && null != t3["return"] && (u2 = t3["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o3) throw n3;
      }
    }
    return a2;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r3, e2) {
  return _arrayWithHoles(r3) || _iterableToArrayLimit(r3, e2) || _unsupportedIterableToArray(r3, e2) || _nonIterableRest();
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e2, t3) {
  if (null == e2) return {};
  var o3, r3, i3 = _objectWithoutPropertiesLoose(e2, t3);
  if (Object.getOwnPropertySymbols) {
    var n3 = Object.getOwnPropertySymbols(e2);
    for (r3 = 0; r3 < n3.length; r3++) o3 = n3[r3], -1 === t3.indexOf(o3) && {}.propertyIsEnumerable.call(e2, o3) && (i3[o3] = e2[o3]);
  }
  return i3;
}

// node_modules/react-select/dist/useStateManager-7e1e8489.esm.js
var import_react2 = __toESM(require_react());
var _excluded = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded);
  var _useState = (0, import_react2.useState)(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = (0, import_react2.useState)(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = (0, import_react2.useState)(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = (0, import_react2.useCallback)(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = (0, import_react2.useCallback)(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = (0, import_react2.useCallback)(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = (0, import_react2.useCallback)(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}

// node_modules/react-select/dist/react-select.esm.js
var React7 = __toESM(require_react());
var import_react8 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r3) {
  if (Array.isArray(r3)) return _arrayLikeToArray(r3);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r3) {
  if ("undefined" != typeof Symbol && null != r3[Symbol.iterator] || null != r3["@@iterator"]) return Array.from(r3);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r3) {
  return _arrayWithoutHoles(r3) || _iterableToArray(r3) || _unsupportedIterableToArray(r3) || _nonIterableSpread();
}

// node_modules/react-select/dist/Select-aab027f3.esm.js
var React6 = __toESM(require_react());
var import_react6 = __toESM(require_react());

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var React4 = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/@emotion/sheet/dist/emotion-sheet.development.esm.js
var isDevelopment = true;
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
    if (document.styleSheets[i3].ownerNode === tag) {
      return document.styleSheets[i3];
    }
  }
  return void 0;
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? !isDevelopment : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    {
      var isImportRule3 = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
      if (isImportRule3 && this._alreadyInsertedOrderInsensitiveRule) {
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
      }
      this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule3;
    }
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
        if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
          console.error('There was a problem inserting the following rule: "' + rule + '"', e2);
        }
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
    {
      this._alreadyInsertedOrderInsensitiveRule = false;
    }
  };
  return StyleSheet2;
}();

// node_modules/@emotion/cache/node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// node_modules/@emotion/cache/node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from2 = String.fromCharCode;
var assign2 = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}

// node_modules/@emotion/cache/node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign2(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from2(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}

// node_modules/@emotion/cache/node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from2(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i3 = 0, j3 = 0, k2 = 0; i3 < index2; ++i3)
    for (var x3 = 0, y3 = substr(value, post + 1, post = abs(j3 = points[i3])), z3 = value; x3 < size; ++x3)
      if (z3 = trim(j3 > 0 ? rule[x3] + " " + y3 : replace(y3, /&\f/g, rule[x3])))
        props[k2++] = z3;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from2(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}

// node_modules/@emotion/cache/node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i3 = 0; i3 < length2; i3++)
    output += callback(children[i3], i3, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// node_modules/@emotion/cache/node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i3 = 0; i3 < length2; i3++)
      output += collection[i3](element, index2, children, callback) || "";
    return output;
  };
}

// node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};

// node_modules/@emotion/cache/dist/emotion-cache.browser.development.esm.js
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      // fallthrough
      default:
        parsed[index2] += from2(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i3 = 0, k2 = 0; i3 < rules.length; i3++) {
    for (var j3 = 0; j3 < parentRules.length; j3++, k2++) {
      element.props[k2] = points[i3] ? rules[i3].replace(/&\f/g, parentRules[j3]) : parentRules[j3] + " " + rules[i3];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment2(element) {
  return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
  return function(element, index2, children) {
    if (element.type !== "rule" || cache.compat) return;
    var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
    if (unsafePseudoClasses) {
      var isNested = !!element.parent;
      var commentContainer = isNested ? element.parent.children : (
        // global rule at the root level
        children
      );
      for (var i3 = commentContainer.length - 1; i3 >= 0; i3--) {
        var node2 = commentContainer[i3];
        if (node2.line < element.line) {
          break;
        }
        if (node2.column < element.column) {
          if (isIgnoringComment(node2)) {
            return;
          }
          break;
        }
      }
      unsafePseudoClasses.forEach(function(unsafePseudoClass) {
        console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
      });
    }
  };
};
var isImportRule = function isImportRule2(element) {
  return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index2, children) {
  for (var i3 = index2 - 1; i3 >= 0; i3--) {
    if (!isImportRule(children[i3])) {
      return true;
    }
  }
  return false;
};
var nullifyElement = function nullifyElement2(element) {
  element.type = "";
  element.value = "";
  element["return"] = "";
  element.children = "";
  element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm2(element, index2, children) {
  if (!isImportRule(element)) {
    return;
  }
  if (element.parent) {
    console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
    nullifyElement(element);
  } else if (isPrependedWithRegularRules(index2, children)) {
    console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
    nullifyElement(element);
  }
};
function prefix2(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix2(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix2(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var getSourceMap;
{
  sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
  getSourceMap = function getSourceMap2(styles) {
    var matches2 = styles.match(sourceMapPattern);
    if (!matches2) return;
    return matches2[matches2.length - 1];
  };
}
var sourceMapPattern;
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (!key) {
    throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
  }
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  {
    if (/[^a-z-]/.test(key)) {
      throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    }
  }
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i3 = 1; i3 < attrib.length; i3++) {
          inserted[attrib[i3]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
      get compat() {
        return cache.compat;
      }
    }), incorrectImportAlarm);
  }
  {
    var currentSheet;
    var finalizingPlugins = [stringify, function(element) {
      if (!element.root) {
        if (element["return"]) {
          currentSheet.insert(element["return"]);
        } else if (element.value && element.type !== COMMENT) {
          currentSheet.insert(element.value + "{}");
        }
      }
    }];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      if (getSourceMap) {
        var sourceMap = getSourceMap(serialized.styles);
        if (sourceMap) {
          currentSheet = {
            insert: function insert2(rule) {
              sheet.insert(rule + sourceMap);
            }
          };
        }
      }
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

// node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js
var import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());

// node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current2 = serialized;
    do {
      cache.insert(serialized === current2 ? "." + className : "", current2, cache.sheet, true);
      current2 = current2.next;
    } while (current2 !== void 0);
  }
};

// node_modules/@emotion/hash/dist/emotion-hash.esm.js
function murmur2(str) {
  var h2 = 0;
  var k2, i3 = 0, len = str.length;
  for (; len >= 4; ++i3, len -= 4) {
    k2 = str.charCodeAt(i3) & 255 | (str.charCodeAt(++i3) & 255) << 8 | (str.charCodeAt(++i3) & 255) << 16 | (str.charCodeAt(++i3) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i3 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i3 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i3) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}

// node_modules/@emotion/serialize/node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// node_modules/@emotion/serialize/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn2(arg);
    return cache[arg];
  };
}

// node_modules/@emotion/serialize/dist/emotion-serialize.development.esm.js
var isDevelopment2 = true;
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match3, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
{
  contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
  contentValues = ["normal", "none", "initial", "inherit", "unset"];
  oldProcessStyleValue = processStyleValue;
  msPattern = /^-ms-/;
  hyphenPattern = /-(.)/g;
  hyphenatedCache = {};
  processStyleValue = function processStyleValue3(key, value) {
    if (key === "content") {
      if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
        throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
      }
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
      hyphenatedCache[key] = true;
      console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
        return _char.toUpperCase();
      }) + "?");
    }
    return processed;
  };
}
var contentValuePattern;
var contentValues;
var oldProcessStyleValue;
var msPattern;
var hyphenPattern;
var hyphenatedCache;
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    if (String(componentSelector) === "NO_COMPONENT_SELECTOR") {
      throw new Error(noComponentSelectorMessage);
    }
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = serializedStyles.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      } else {
        console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      }
      break;
    }
    case "string":
      {
        var matched = [];
        var replaced = interpolation.replace(animationRegex, function(_match, _p1, p2) {
          var fakeVarName = "animation" + matched.length;
          matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
          return "${" + fakeVarName + "}";
        });
        if (matched.length) {
          console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\ncss`" + replaced + "`");
        }
      }
      break;
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i3 = 0; i3 < obj.length; i3++) {
      string += handleInterpolation(mergedProps, registered, obj[i3]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              if (key === "undefined") {
                console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
              }
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings2 = args[0];
  if (strings2 == null || strings2.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings2);
  } else {
    var asTemplateStringsArr = strings2;
    if (asTemplateStringsArr[0] === void 0) {
      console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
    }
    styles += asTemplateStringsArr[0];
  }
  for (var i3 = 1; i3 < args.length; i3++) {
    styles += handleInterpolation(mergedProps, registered, args[i3]);
    if (stringMode) {
      var templateStringsArr = strings2;
      if (templateStringsArr[i3] === void 0) {
        console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
      }
      styles += templateStringsArr[i3];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match3;
  while ((match3 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match3[1];
  }
  var name = murmur2(styles) + identifierName;
  {
    var devStyles = {
      name,
      styles,
      next: cursor,
      toString: function toString() {
        return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
      }
    };
    return devStyles;
  }
}

// node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
var React3 = __toESM(require_react());
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect2 = React3["useInsertionEffect"] ? React3["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React3.useLayoutEffect;

// node_modules/@emotion/react/dist/emotion-element-489459f2.browser.development.esm.js
var EmotionCacheContext = React4.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? createCache({
    key: "css"
  }) : null
);
{
  EmotionCacheContext.displayName = "EmotionCacheContext";
}
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return (0, import_react3.forwardRef)(function(props, ref) {
    var cache = (0, import_react3.useContext)(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = React4.createContext({});
{
  ThemeContext.displayName = "EmotionThemeContext";
}
var getTheme = function getTheme2(outerTheme, theme) {
  if (typeof theme === "function") {
    var mergedTheme = theme(outerTheme);
    if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
      throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
    }
    return mergedTheme;
  }
  if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
    throw new Error("[ThemeProvider] Please make your theme prop a plain object");
  }
  return _extends({}, outerTheme, theme);
};
var createCacheWithTheme = weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme) {
    return getTheme(outerTheme, theme);
  });
});
var hasOwn = {}.hasOwnProperty;
var getLastPart = function getLastPart2(functionName) {
  var parts = functionName.split(".");
  return parts[parts.length - 1];
};
var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line2) {
  var match3 = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line2);
  if (match3) return getLastPart(match3[1]);
  match3 = /^([A-Za-z0-9$.]+)@/.exec(line2);
  if (match3) return getLastPart(match3[1]);
  return void 0;
};
var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
var sanitizeIdentifier = function sanitizeIdentifier2(identifier2) {
  return identifier2.replace(/\$/g, "-");
};
var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
  if (!stackTrace) return void 0;
  var lines = stackTrace.split("\n");
  for (var i3 = 0; i3 < lines.length; i3++) {
    var functionName = getFunctionNameFromStackTraceLine(lines[i3]);
    if (!functionName) continue;
    if (internalReactFunctionNames.has(functionName)) break;
    if (/^[A-Z]/.test(functionName)) return sanitizeIdentifier(functionName);
  }
  return void 0;
};
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  if (typeof props.css === "string" && // check if there is a css declaration
  props.css.indexOf(":") !== -1) {
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
  }
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  if (typeof globalThis !== "undefined" && !!globalThis.EMOTION_RUNTIME_AUTO_LABEL && !!props.css && (typeof props.css !== "object" || !("name" in props.css) || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
    var label = getLabelFromStackTrace(new Error().stack);
    if (label) newProps[labelPropName] = label;
  }
  return newProps;
};
var Insertion = function Insertion2(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React4.useContext(ThemeContext));
  if (serialized.name.indexOf("-") === -1) {
    var labelFromStack = props[labelPropName];
    if (labelFromStack) {
      serialized = serializeStyles([serialized, "label:" + labelFromStack + ";"]);
    }
  }
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && _key2 !== labelPropName) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return React4.createElement(React4.Fragment, null, React4.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), React4.createElement(WrappedComponent, newProps));
});
{
  Emotion.displayName = "EmotionCssPropInternal";
}
var Emotion$1 = Emotion;

// node_modules/@emotion/react/dist/emotion-react.browser.development.esm.js
var React5 = __toESM(require_react());
var import_hoist_non_react_statics3 = __toESM(require_hoist_non_react_statics_cjs());
var isDevelopment3 = true;
var pkg = {
  name: "@emotion/react",
  version: "11.14.0",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  types: "dist/emotion-react.cjs.d.ts",
  exports: {
    ".": {
      types: {
        "import": "./dist/emotion-react.cjs.mjs",
        "default": "./dist/emotion-react.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        worker: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./dist/emotion-react.development.edge-light.esm.js",
          "import": "./dist/emotion-react.development.edge-light.cjs.mjs",
          "default": "./dist/emotion-react.development.edge-light.cjs.js"
        },
        browser: {
          module: "./dist/emotion-react.browser.development.esm.js",
          "import": "./dist/emotion-react.browser.development.cjs.mjs",
          "default": "./dist/emotion-react.browser.development.cjs.js"
        },
        module: "./dist/emotion-react.development.esm.js",
        "import": "./dist/emotion-react.development.cjs.mjs",
        "default": "./dist/emotion-react.development.cjs.js"
      },
      "edge-light": {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      worker: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      workerd: {
        module: "./dist/emotion-react.edge-light.esm.js",
        "import": "./dist/emotion-react.edge-light.cjs.mjs",
        "default": "./dist/emotion-react.edge-light.cjs.js"
      },
      browser: {
        module: "./dist/emotion-react.browser.esm.js",
        "import": "./dist/emotion-react.browser.cjs.mjs",
        "default": "./dist/emotion-react.browser.cjs.js"
      },
      module: "./dist/emotion-react.esm.js",
      "import": "./dist/emotion-react.cjs.mjs",
      "default": "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      types: {
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.esm.js",
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.development.cjs.js"
        },
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.development.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.mjs",
        "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.cjs.js"
      },
      module: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js",
      "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      types: {
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        worker: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.edge-light.cjs.js"
        },
        browser: {
          module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.esm.js",
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.development.cjs.js"
        },
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.development.cjs.js"
      },
      "edge-light": {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      worker: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      workerd: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.edge-light.cjs.js"
      },
      browser: {
        module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.mjs",
        "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.cjs.js"
      },
      module: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js",
      "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      types: {
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
      },
      development: {
        "edge-light": {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        worker: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        workerd: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.edge-light.cjs.js"
        },
        browser: {
          module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.esm.js",
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.development.cjs.js"
        },
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.development.cjs.js"
      },
      "edge-light": {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      worker: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      workerd: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.edge-light.cjs.js"
      },
      browser: {
        module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.mjs",
        "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.cjs.js"
      },
      module: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js",
      "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        "import": "./macro.d.mts",
        "default": "./macro.d.ts"
      },
      "default": "./macro.js"
    }
  },
  imports: {
    "#is-development": {
      development: "./src/conditions/true.ts",
      "default": "./src/conditions/false.ts"
    },
    "#is-browser": {
      "edge-light": "./src/conditions/false.ts",
      workerd: "./src/conditions/false.ts",
      worker: "./src/conditions/false.ts",
      browser: "./src/conditions/true.ts",
      "default": "./src/conditions/is-browser.ts"
    }
  },
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/css-prop.d.ts",
    "macro.*"
  ],
  sideEffects: false,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.13.5",
    "@emotion/cache": "^11.14.0",
    "@emotion/serialize": "^1.3.3",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
    "@emotion/utils": "^1.4.2",
    "@emotion/weak-memoize": "^0.4.0",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: true
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.13.5",
    "@emotion/css-prettifier": "1.2.0",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.14.0",
    "@types/hoist-non-react-statics": "^3.3.5",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^5.4.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.ts",
      "./jsx-runtime.ts",
      "./jsx-dev-runtime.ts",
      "./_isolated-hnrs.ts"
    ],
    umdName: "emotionReact",
    exports: {
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      }
    }
  }
};
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return React5.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i3 = 2; i3 < argsLength; i3++) {
    createElementArgArray[i3] = args[i3];
  }
  return React5.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var warnedAboutCssPropForGlobal = false;
var Global = withEmotionCache(function(props, cache) {
  if (!warnedAboutCssPropForGlobal && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // I don't really want to add it to the type since it shouldn't be used
  ("className" in props && props.className || "css" in props && props.css)) {
    console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
    warnedAboutCssPropForGlobal = true;
  }
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, React5.useContext(ThemeContext));
  var sheetRef = React5.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
{
  Global.displayName = "EmotionGlobal";
}
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var classnames = function classnames2(args) {
  var len = args.length;
  var i3 = 0;
  var cls = "";
  for (; i3 < len; i3++) {
    var arg = args[i3];
    if (arg == null) continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames2(arg);
        } else {
          if (arg.styles !== void 0 && arg.name !== void 0) {
            console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
          }
          toAdd = "";
          for (var k2 in arg) {
            if (arg[k2] && k2) {
              toAdd && (toAdd += " ");
              toAdd += k2;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge2(registered, css5, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css5(registeredStyles);
}
var Insertion3 = function Insertion4(_ref3) {
  var cache = _ref3.cache, serializedArr = _ref3.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i3 = 0; i3 < serializedArr.length; i3++) {
      insertStyles(cache, serializedArr[i3], false);
    }
  });
  return null;
};
var ClassNames = withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css5 = function css6() {
    if (hasRendered && isDevelopment3) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && isDevelopment3) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge2(cache.registered, css5, classnames(args));
  };
  var content = {
    css: css5,
    cx,
    theme: React5.useContext(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return React5.createElement(React5.Fragment, null, React5.createElement(Insertion3, {
    cache,
    serializedArr
  }), ele);
});
{
  ClassNames.displayName = "EmotionClassNames";
}
{
  isBrowser2 = typeof document !== "undefined";
  isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
  if (isBrowser2 && !isTestEnv) {
    globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser2 ? window : global;
    globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
    if (globalContext[globalKey]) {
      console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
    }
    globalContext[globalKey] = true;
  }
}
var isBrowser2;
var isTestEnv;
var globalContext;
var globalKey;

// node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js
function _taggedTemplateLiteral(e2, t3) {
  return t3 || (t3 = e2.slice(0)), Object.freeze(Object.defineProperties(e2, {
    raw: {
      value: Object.freeze(t3)
    }
  }));
}

// node_modules/react-select/dist/index-641ee5b8.esm.js
var import_react5 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop4 = function noop5() {
};
function applyPrefixToName(prefix3, name) {
  if (!name) {
    return prefix3;
  } else if (name[0] === "-") {
    return prefix3 + name;
  } else {
    return prefix3 + "__" + name;
  }
}
function classNames(prefix3, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state && prefix3) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix3, key)));
      }
    }
  }
  return arr.filter(function(i3) {
    return i3;
  }).map(function(i3) {
    return String(i3).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray(value)) return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null) return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
  };
};
function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}
function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}
function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top) {
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
}
function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style.position === "fixed") return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === "static") {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t3, b2, c2, d2) {
  return c2 * ((t3 = t3 / d2 - 1) * t3 * t3 + 1) + b2;
}
function animatedScrollTo(element, to2) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop4;
  var start = getScrollTop(element);
  var change = to2 - start;
  var increment3 = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment3;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e2) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e2) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w = typeof window !== "undefined" ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener("p", noop4, options);
  w.removeEventListener("p", noop4, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref23 = _slicedToArray(_ref3, 1), key = _ref23[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
var _excluded$3 = ["children", "innerProps"];
var _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent) return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p2) {
  return p2 === "auto" ? "bottom" : p2;
};
var menuCSS = function menuCSS2(_ref23, unstyled) {
  var _objectSpread22;
  var placement = _ref23.placement, _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread22 = {
    label: "menu"
  }, _defineProperty(_objectSpread22, alignToControl(placement), "100%"), _defineProperty(_objectSpread22, "position", "absolute"), _defineProperty(_objectSpread22, "width", "100%"), _defineProperty(_objectSpread22, "zIndex", 1), _objectSpread22), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = (0, import_react5.createContext)(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme;
  var _ref3 = (0, import_react5.useContext)(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = (0, import_react5.useRef)(null);
  var _useState = (0, import_react5.useState)(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = (0, import_react5.useState)(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme.spacing.controlHeight;
  index(function() {
    var menuEl = ref.current;
    if (!menuEl) return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu2 = function Menu3(props) {
  var children = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children);
};
var Menu$1 = Menu2;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(_ref6) {
  var _ref6$children = _ref6.children, children = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children);
};
var LoadingMessage = function LoadingMessage2(_ref7) {
  var _ref7$children = _ref7.children, children = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children,
    innerProps
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children);
};
var menuPortalCSS = function menuPortalCSS2(_ref8) {
  var rect = _ref8.rect, offset = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = (0, import_react5.useRef)(null);
  var cleanupRef = (0, import_react5.useRef)(null);
  var _useState5 = (0, import_react5.useState)(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = (0, import_react5.useMemo)(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = (0, import_react5.useState)(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = (0, import_react5.useCallback)(function() {
    if (!controlElement) return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset = rect[placement] + scrollDistance;
    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  index(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = (0, import_react5.useCallback)(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  index(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = (0, import_react5.useCallback)(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition) return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? (0, import_react_dom.createPortal)(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children);
};
var valueContainerCSS = function valueContainerCSS2(_ref23, unstyled) {
  var spacing2 = _ref23.theme.spacing, isMulti = _ref23.isMulti, hasValue = _ref23.hasValue, controlShouldRenderValue = _ref23.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children);
};
var _templateObject;
var _excluded$2 = ["size"];
var _excluded2 = ["innerProps", "isRtl", "size"];
function _EMOTION_STRINGIFIED_CSS_ERROR__() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref2 = false ? {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} : {
  name: "tj5bde-Svg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0;label:Svg;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__
};
var Svg = function Svg2(_ref3) {
  var size = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay2 = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: css({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay2, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, false ? "" : ";label:LoadingDot;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGljYXRvcnMudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1RSSIsImZpbGUiOiJpbmRpY2F0b3JzLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGtleWZyYW1lcyB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuaW1wb3J0IHtcbiAgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWUsXG4gIENTU09iamVjdFdpdGhMYWJlbCxcbiAgR3JvdXBCYXNlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRTdHlsZVByb3BzIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgSWNvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBTdmcgPSAoe1xuICBzaXplLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzdmcnXSAmIHsgc2l6ZTogbnVtYmVyIH0pID0+IChcbiAgPHN2Z1xuICAgIGhlaWdodD17c2l6ZX1cbiAgICB3aWR0aD17c2l6ZX1cbiAgICB2aWV3Qm94PVwiMCAwIDIwIDIwXCJcbiAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgIGZvY3VzYWJsZT1cImZhbHNlXCJcbiAgICBjc3M9e3tcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgZmlsbDogJ2N1cnJlbnRDb2xvcicsXG4gICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IHR5cGUgQ3Jvc3NJY29uUHJvcHMgPSBKU1guSW50cmluc2ljRWxlbWVudHNbJ3N2ZyddICYgeyBzaXplPzogbnVtYmVyIH07XG5leHBvcnQgY29uc3QgQ3Jvc3NJY29uID0gKHByb3BzOiBDcm9zc0ljb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNMTQuMzQ4IDE0Ljg0OWMtMC40NjkgMC40NjktMS4yMjkgMC40NjktMS42OTcgMGwtMi42NTEtMy4wMzAtMi42NTEgMy4wMjljLTAuNDY5IDAuNDY5LTEuMjI5IDAuNDY5LTEuNjk3IDAtMC40NjktMC40NjktMC40NjktMS4yMjkgMC0xLjY5N2wyLjc1OC0zLjE1LTIuNzU5LTMuMTUyYy0wLjQ2OS0wLjQ2OS0wLjQ2OS0xLjIyOCAwLTEuNjk3czEuMjI4LTAuNDY5IDEuNjk3IDBsMi42NTIgMy4wMzEgMi42NTEtMy4wMzFjMC40NjktMC40NjkgMS4yMjgtMC40NjkgMS42OTcgMHMwLjQ2OSAxLjIyOSAwIDEuNjk3bC0yLjc1OCAzLjE1MiAyLjc1OCAzLjE1YzAuNDY5IDAuNDY5IDAuNDY5IDEuMjI5IDAgMS42OTh6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuZXhwb3J0IHR5cGUgRG93bkNoZXZyb25Qcm9wcyA9IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snc3ZnJ10gJiB7IHNpemU/OiBudW1iZXIgfTtcbmV4cG9ydCBjb25zdCBEb3duQ2hldnJvbiA9IChwcm9wczogRG93bkNoZXZyb25Qcm9wcykgPT4gKFxuICA8U3ZnIHNpemU9ezIwfSB7Li4ucHJvcHN9PlxuICAgIDxwYXRoIGQ9XCJNNC41MTYgNy41NDhjMC40MzYtMC40NDYgMS4wNDMtMC40ODEgMS41NzYgMGwzLjkwOCAzLjc0NyAzLjkwOC0zLjc0N2MwLjUzMy0wLjQ4MSAxLjE0MS0wLjQ0NiAxLjU3NCAwIDAuNDM2IDAuNDQ1IDAuNDA4IDEuMTk3IDAgMS42MTUtMC40MDYgMC40MTgtNC42OTUgNC41MDItNC42OTUgNC41MDItMC4yMTcgMC4yMjMtMC41MDIgMC4zMzUtMC43ODcgMC4zMzVzLTAuNTctMC4xMTItMC43ODktMC4zMzVjMCAwLTQuMjg3LTQuMDg0LTQuNjk1LTQuNTAycy0wLjQzNi0xLjE3IDAtMS42MTV6XCIgLz5cbiAgPC9Tdmc+XG4pO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERyb3Bkb3duICYgQ2xlYXIgQnV0dG9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxcbiAgT3B0aW9uID0gdW5rbm93bixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+ID0gR3JvdXBCYXNlPE9wdGlvbj5cbj4gZXh0ZW5kcyBDb21tb25Qcm9wc0FuZENsYXNzTmFtZTxPcHRpb24sIElzTXVsdGksIEdyb3VwPiB7XG4gIC8qKiBUaGUgY2hpbGRyZW4gdG8gYmUgcmVuZGVyZWQgaW5zaWRlIHRoZSBpbmRpY2F0b3IuICovXG4gIGNoaWxkcmVuPzogUmVhY3ROb2RlO1xuICAvKiogUHJvcHMgdGhhdCB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aGUgY2hpbGRyZW4uICovXG4gIGlubmVyUHJvcHM6IEpTWC5JbnRyaW5zaWNFbGVtZW50c1snZGl2J107XG4gIC8qKiBUaGUgZm9jdXNlZCBzdGF0ZSBvZiB0aGUgc2VsZWN0LiAqL1xuICBpc0ZvY3VzZWQ6IGJvb2xlYW47XG4gIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGJhc2VDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgdGhlbWU6IHtcbiAgICAgIHNwYWNpbmc6IHsgYmFzZVVuaXQgfSxcbiAgICAgIGNvbG9ycyxcbiAgICB9LFxuICB9OlxuICAgIHwgRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuICAgIHwgQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2luZGljYXRvckNvbnRhaW5lcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgdHJhbnNpdGlvbjogJ2NvbG9yIDE1MG1zJyxcbiAgLi4uKHVuc3R5bGVkXG4gICAgPyB7fVxuICAgIDoge1xuICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw2MCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIHBhZGRpbmc6IGJhc2VVbml0ICogMixcbiAgICAgICAgJzpob3Zlcic6IHtcbiAgICAgICAgICBjb2xvcjogaXNGb2N1c2VkID8gY29sb3JzLm5ldXRyYWw4MCA6IGNvbG9ycy5uZXV0cmFsNDAsXG4gICAgICAgIH0sXG4gICAgICB9KSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZHJvcGRvd25JbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IERyb3Bkb3duSW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogRHJvcGRvd25JbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnZHJvcGRvd25JbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2Ryb3Bkb3duLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8RG93bkNoZXZyb24gLz59XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsZWFySW5kaWNhdG9yUHJvcHM8XG4gIE9wdGlvbiA9IHVua25vd24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbixcbiAgR3JvdXAgZXh0ZW5kcyBHcm91cEJhc2U8T3B0aW9uPiA9IEdyb3VwQmFzZTxPcHRpb24+XG4+IGV4dGVuZHMgQ29tbW9uUHJvcHNBbmRDbGFzc05hbWU8T3B0aW9uLCBJc011bHRpLCBHcm91cD4ge1xuICAvKiogVGhlIGNoaWxkcmVuIHRvIGJlIHJlbmRlcmVkIGluc2lkZSB0aGUgaW5kaWNhdG9yLiAqL1xuICBjaGlsZHJlbj86IFJlYWN0Tm9kZTtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgY2xlYXJJbmRpY2F0b3JDU1MgPSBiYXNlQ1NTO1xuZXhwb3J0IGNvbnN0IENsZWFySW5kaWNhdG9yID0gPFxuICBPcHRpb24sXG4gIElzTXVsdGkgZXh0ZW5kcyBib29sZWFuLFxuICBHcm91cCBleHRlbmRzIEdyb3VwQmFzZTxPcHRpb24+XG4+KFxuICBwcm9wczogQ2xlYXJJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgY2hpbGRyZW4sIGlubmVyUHJvcHMgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIHsuLi5nZXRTdHlsZVByb3BzKHByb3BzLCAnY2xlYXJJbmRpY2F0b3InLCB7XG4gICAgICAgIGluZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgJ2NsZWFyLWluZGljYXRvcic6IHRydWUsXG4gICAgICB9KX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIHtjaGlsZHJlbiB8fCA8Q3Jvc3NJY29uIC8+fVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTZXBhcmF0b3Jcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGljYXRvclNlcGFyYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpbm5lclByb3BzPzogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ107XG59XG5cbmV4cG9ydCBjb25zdCBpbmRpY2F0b3JTZXBhcmF0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0Rpc2FibGVkLFxuICAgIHRoZW1lOiB7XG4gICAgICBzcGFjaW5nOiB7IGJhc2VVbml0IH0sXG4gICAgICBjb2xvcnMsXG4gICAgfSxcbiAgfTogSW5kaWNhdG9yU2VwYXJhdG9yUHJvcHM8T3B0aW9uLCBJc011bHRpLCBHcm91cD4sXG4gIHVuc3R5bGVkOiBib29sZWFuXG4pOiBDU1NPYmplY3RXaXRoTGFiZWwgPT4gKHtcbiAgbGFiZWw6ICdpbmRpY2F0b3JTZXBhcmF0b3InLFxuICBhbGlnblNlbGY6ICdzdHJldGNoJyxcbiAgd2lkdGg6IDEsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpc0Rpc2FibGVkID8gY29sb3JzLm5ldXRyYWwxMCA6IGNvbG9ycy5uZXV0cmFsMjAsXG4gICAgICAgIG1hcmdpbkJvdHRvbTogYmFzZVVuaXQgKiAyLFxuICAgICAgICBtYXJnaW5Ub3A6IGJhc2VVbml0ICogMixcbiAgICAgIH0pLFxufSk7XG5cbmV4cG9ydCBjb25zdCBJbmRpY2F0b3JTZXBhcmF0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHByb3BzOiBJbmRpY2F0b3JTZXBhcmF0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPlxuKSA9PiB7XG4gIGNvbnN0IHsgaW5uZXJQcm9wcyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPHNwYW5cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgICAgey4uLmdldFN0eWxlUHJvcHMocHJvcHMsICdpbmRpY2F0b3JTZXBhcmF0b3InLCB7XG4gICAgICAgICdpbmRpY2F0b3Itc2VwYXJhdG9yJzogdHJ1ZSxcbiAgICAgIH0pfVxuICAgIC8+XG4gICk7XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExvYWRpbmdcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBsb2FkaW5nRG90QW5pbWF0aW9ucyA9IGtleWZyYW1lc2BcbiAgMCUsIDgwJSwgMTAwJSB7IG9wYWNpdHk6IDA7IH1cbiAgNDAlIHsgb3BhY2l0eTogMTsgfVxuYDtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmdJbmRpY2F0b3JDU1MgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oXG4gIHtcbiAgICBpc0ZvY3VzZWQsXG4gICAgc2l6ZSxcbiAgICB0aGVtZToge1xuICAgICAgY29sb3JzLFxuICAgICAgc3BhY2luZzogeyBiYXNlVW5pdCB9LFxuICAgIH0sXG4gIH06IExvYWRpbmdJbmRpY2F0b3JQcm9wczxPcHRpb24sIElzTXVsdGksIEdyb3VwPixcbiAgdW5zdHlsZWQ6IGJvb2xlYW5cbik6IENTU09iamVjdFdpdGhMYWJlbCA9PiAoe1xuICBsYWJlbDogJ2xvYWRpbmdJbmRpY2F0b3InLFxuICBkaXNwbGF5OiAnZmxleCcsXG4gIHRyYW5zaXRpb246ICdjb2xvciAxNTBtcycsXG4gIGFsaWduU2VsZjogJ2NlbnRlcicsXG4gIGZvbnRTaXplOiBzaXplLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBtYXJnaW5SaWdodDogc2l6ZSxcbiAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gIC4uLih1bnN0eWxlZFxuICAgID8ge31cbiAgICA6IHtcbiAgICAgICAgY29sb3I6IGlzRm9jdXNlZCA/IGNvbG9ycy5uZXV0cmFsNjAgOiBjb2xvcnMubmV1dHJhbDIwLFxuICAgICAgICBwYWRkaW5nOiBiYXNlVW5pdCAqIDIsXG4gICAgICB9KSxcbn0pO1xuXG5pbnRlcmZhY2UgTG9hZGluZ0RvdFByb3BzIHtcbiAgZGVsYXk6IG51bWJlcjtcbiAgb2Zmc2V0OiBib29sZWFuO1xufVxuY29uc3QgTG9hZGluZ0RvdCA9ICh7IGRlbGF5LCBvZmZzZXQgfTogTG9hZGluZ0RvdFByb3BzKSA9PiAoXG4gIDxzcGFuXG4gICAgY3NzPXt7XG4gICAgICBhbmltYXRpb246IGAke2xvYWRpbmdEb3RBbmltYXRpb25zfSAxcyBlYXNlLWluLW91dCAke2RlbGF5fW1zIGluZmluaXRlO2AsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMWVtJyxcbiAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgbWFyZ2luTGVmdDogb2Zmc2V0ID8gJzFlbScgOiB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6ICcxZW0nLFxuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICB3aWR0aDogJzFlbScsXG4gICAgfX1cbiAgLz5cbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGluZ0luZGljYXRvclByb3BzPFxuICBPcHRpb24gPSB1bmtub3duLFxuICBJc011bHRpIGV4dGVuZHMgYm9vbGVhbiA9IGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj4gPSBHcm91cEJhc2U8T3B0aW9uPlxuPiBleHRlbmRzIENvbW1vblByb3BzQW5kQ2xhc3NOYW1lPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+IHtcbiAgLyoqIFByb3BzIHRoYXQgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIGNoaWxkcmVuLiAqL1xuICBpbm5lclByb3BzOiBKU1guSW50cmluc2ljRWxlbWVudHNbJ2RpdiddO1xuICAvKiogVGhlIGZvY3VzZWQgc3RhdGUgb2YgdGhlIHNlbGVjdC4gKi9cbiAgaXNGb2N1c2VkOiBib29sZWFuO1xuICBpc0Rpc2FibGVkOiBib29sZWFuO1xuICAvKiogU2V0IHNpemUgb2YgdGhlIGNvbnRhaW5lci4gKi9cbiAgc2l6ZTogbnVtYmVyO1xufVxuZXhwb3J0IGNvbnN0IExvYWRpbmdJbmRpY2F0b3IgPSA8XG4gIE9wdGlvbixcbiAgSXNNdWx0aSBleHRlbmRzIGJvb2xlYW4sXG4gIEdyb3VwIGV4dGVuZHMgR3JvdXBCYXNlPE9wdGlvbj5cbj4oe1xuICBpbm5lclByb3BzLFxuICBpc1J0bCxcbiAgc2l6ZSA9IDQsXG4gIC4uLnJlc3RQcm9wc1xufTogTG9hZGluZ0luZGljYXRvclByb3BzPE9wdGlvbiwgSXNNdWx0aSwgR3JvdXA+KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgey4uLmdldFN0eWxlUHJvcHMoXG4gICAgICAgIHsgLi4ucmVzdFByb3BzLCBpbm5lclByb3BzLCBpc1J0bCwgc2l6ZSB9LFxuICAgICAgICAnbG9hZGluZ0luZGljYXRvcicsXG4gICAgICAgIHtcbiAgICAgICAgICBpbmRpY2F0b3I6IHRydWUsXG4gICAgICAgICAgJ2xvYWRpbmctaW5kaWNhdG9yJzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKX1cbiAgICAgIHsuLi5pbm5lclByb3BzfVxuICAgID5cbiAgICAgIDxMb2FkaW5nRG90IGRlbGF5PXswfSBvZmZzZXQ9e2lzUnRsfSAvPlxuICAgICAgPExvYWRpbmdEb3QgZGVsYXk9ezE2MH0gb2Zmc2V0IC8+XG4gICAgICA8TG9hZGluZ0RvdCBkZWxheT17MzIwfSBvZmZzZXQ9eyFpc1J0bH0gLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iXX0= */")
  });
};
var LoadingIndicator = function LoadingIndicator2(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
var css$1 = function css2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps, {
    "aria-disabled": isDisabled || void 0
  }), children);
};
var Control$1 = Control;
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group = function Group2(props) {
  var children = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading = function GroupHeading2(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1 = Group;
var _excluded3 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input = function Input2(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded3);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var Input$1 = Input;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref23, unstyled) {
  var _ref2$theme = _ref23.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref23.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container3 = components2.Container, Label2 = components2.Label, Remove = components2.Remove;
  return jsx(Container3, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label2, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option = function Option2(props) {
  var children = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};
var Option$1 = Option;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children);
};
var Placeholder$1 = Placeholder;
var css3 = function css4(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue = function SingleValue2(props) {
  var children = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children);
};
var SingleValue$1 = SingleValue;
var components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN(first2) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i3 = 0; i3 < newInputs.length; i3++) {
    if (!isEqual(newInputs[i3], lastInputs[i3])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}

// node_modules/react-select/dist/Select-aab027f3.esm.js
function _EMOTION_STRINGIFIED_CSS_ERROR__$2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref = false ? {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} : {
  name: "1f43avz-a11yText-A11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap;label:A11yText;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkExMXlUZXh0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFPSSIsImZpbGUiOiJBMTF5VGV4dC50c3giLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGpzeCBqc3ggKi9cbmltcG9ydCB7IEpTWCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCB9IGZyb20gJ0BlbW90aW9uL3JlYWN0JztcblxuLy8gQXNzaXN0aXZlIHRleHQgdG8gZGVzY3JpYmUgdmlzdWFsIGVsZW1lbnRzLiBIaWRkZW4gZm9yIHNpZ2h0ZWQgdXNlcnMuXG5jb25zdCBBMTF5VGV4dCA9IChwcm9wczogSlNYLkludHJpbnNpY0VsZW1lbnRzWydzcGFuJ10pID0+IChcbiAgPHNwYW5cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAnYTExeVRleHQnLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgYm9yZGVyOiAwLFxuICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICB3aWR0aDogMSxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcGFkZGluZzogMCxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIH19XG4gICAgey4uLnByb3BzfVxuICAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQTExeVRleHQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$2
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, tabSelectsValue = props.tabSelectsValue, context = props.context, isInitialFocus = props.isInitialFocus;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return isInitialFocus ? "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action = props.action, _props$label = props.label, label = _props$label === void 0 ? "" : _props$label, labels = props.labels, isDisabled = props.isDisabled;
    switch (action) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels.length > 1 ? "s" : "", " ").concat(labels.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected, isAppleDevice2 = props.isAppleDevice;
    var getArrayIndex = function getArrayIndex2(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu" && isAppleDevice2) {
      var disabled = isDisabled ? " disabled" : "";
      var status = "".concat(isSelected ? " selected" : "").concat(disabled);
      return "".concat(label).concat(status, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id = props.id, isAppleDevice2 = props.isAppleDevice;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue, isLoading = selectProps.isLoading;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = (0, import_react6.useMemo)(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = (0, import_react6.useMemo)(function() {
    var message2 = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel4(selected) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled3(selected, selectValue),
        label,
        labels
      }, ariaSelection);
      message2 = messages.onChange(onChangeProps);
    }
    return message2;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = (0, import_react6.useMemo)(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue,
        isAppleDevice: isAppleDevice2
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue, isAppleDevice2]);
  var ariaResults = (0, import_react6.useMemo)(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && !isLoading && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2, isLoading]);
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  var ariaGuidance = (0, import_react6.useMemo)(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue,
        isInitialFocus
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue, isInitialFocus]);
  var ScreenReaderText = jsx(import_react6.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-focused"
  }, ariaFocused), jsx("span", {
    id: "aria-results"
  }, ariaResults), jsx("span", {
    id: "aria-guidance"
  }, ariaGuidance));
  return jsx(import_react6.Fragment, null, jsx(A11yText$1, {
    id
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
}, {
  base: "AA",
  letters: "Ꜳ"
}, {
  base: "AE",
  letters: "ÆǼǢ"
}, {
  base: "AO",
  letters: "Ꜵ"
}, {
  base: "AU",
  letters: "Ꜷ"
}, {
  base: "AV",
  letters: "ꜸꜺ"
}, {
  base: "AY",
  letters: "Ꜽ"
}, {
  base: "B",
  letters: "BⒷＢḂḄḆɃƂƁ"
}, {
  base: "C",
  letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
}, {
  base: "D",
  letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
}, {
  base: "DZ",
  letters: "ǱǄ"
}, {
  base: "Dz",
  letters: "ǲǅ"
}, {
  base: "E",
  letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
}, {
  base: "F",
  letters: "FⒻＦḞƑꝻ"
}, {
  base: "G",
  letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
}, {
  base: "H",
  letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
}, {
  base: "I",
  letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
}, {
  base: "J",
  letters: "JⒿＪĴɈ"
}, {
  base: "K",
  letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
}, {
  base: "L",
  letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
}, {
  base: "LJ",
  letters: "Ǉ"
}, {
  base: "Lj",
  letters: "ǈ"
}, {
  base: "M",
  letters: "MⓂＭḾṀṂⱮƜ"
}, {
  base: "N",
  letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
}, {
  base: "NJ",
  letters: "Ǌ"
}, {
  base: "Nj",
  letters: "ǋ"
}, {
  base: "O",
  letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
}, {
  base: "OI",
  letters: "Ƣ"
}, {
  base: "OO",
  letters: "Ꝏ"
}, {
  base: "OU",
  letters: "Ȣ"
}, {
  base: "P",
  letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
}, {
  base: "Q",
  letters: "QⓆＱꝖꝘɊ"
}, {
  base: "R",
  letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
}, {
  base: "S",
  letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
}, {
  base: "T",
  letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
}, {
  base: "TZ",
  letters: "Ꜩ"
}, {
  base: "U",
  letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
}, {
  base: "V",
  letters: "VⓋＶṼṾƲꝞɅ"
}, {
  base: "VY",
  letters: "Ꝡ"
}, {
  base: "W",
  letters: "WⓌＷẀẂŴẆẄẈⱲ"
}, {
  base: "X",
  letters: "XⓍＸẊẌ"
}, {
  base: "Y",
  letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
}, {
  base: "Z",
  letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
}, {
  base: "a",
  letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
}, {
  base: "aa",
  letters: "ꜳ"
}, {
  base: "ae",
  letters: "æǽǣ"
}, {
  base: "ao",
  letters: "ꜵ"
}, {
  base: "au",
  letters: "ꜷ"
}, {
  base: "av",
  letters: "ꜹꜻ"
}, {
  base: "ay",
  letters: "ꜽ"
}, {
  base: "b",
  letters: "bⓑｂḃḅḇƀƃɓ"
}, {
  base: "c",
  letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
}, {
  base: "d",
  letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
}, {
  base: "dz",
  letters: "ǳǆ"
}, {
  base: "e",
  letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
}, {
  base: "f",
  letters: "fⓕｆḟƒꝼ"
}, {
  base: "g",
  letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
}, {
  base: "h",
  letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
}, {
  base: "hv",
  letters: "ƕ"
}, {
  base: "i",
  letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
}, {
  base: "j",
  letters: "jⓙｊĵǰɉ"
}, {
  base: "k",
  letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
}, {
  base: "l",
  letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
}, {
  base: "lj",
  letters: "ǉ"
}, {
  base: "m",
  letters: "mⓜｍḿṁṃɱɯ"
}, {
  base: "n",
  letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
}, {
  base: "nj",
  letters: "ǌ"
}, {
  base: "o",
  letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
}, {
  base: "oi",
  letters: "ƣ"
}, {
  base: "ou",
  letters: "ȣ"
}, {
  base: "oo",
  letters: "ꝏ"
}, {
  base: "p",
  letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
}, {
  base: "q",
  letters: "qⓠｑɋꝗꝙ"
}, {
  base: "r",
  letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
}, {
  base: "s",
  letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
}, {
  base: "t",
  letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
}, {
  base: "tz",
  letters: "ꜩ"
}, {
  base: "u",
  letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
}, {
  base: "v",
  letters: "vⓥｖṽṿʋꝟʌ"
}, {
  base: "vy",
  letters: "ꝡ"
}, {
  base: "w",
  letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
}, {
  base: "x",
  letters: "xⓧｘẋẍ"
}, {
  base: "y",
  letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
}, {
  base: "z",
  letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (i3 = 0; i3 < diacritics.length; i3++) {
  diacritic = diacritics[i3];
  for (j3 = 0; j3 < diacritic.letters.length; j3++) {
    diacriticToBase[diacritic.letters[j3]] = diacritic.base;
  }
}
var diacritic;
var j3;
var i3;
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match3) {
    return diacriticToBase[match3];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__) return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded4 = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded4);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: css({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, false ? "" : ";label:DummyInput;", false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkR1bW15SW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlCTSIsImZpbGUiOiJEdW1teUlucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsgSlNYLCBSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5pbXBvcnQgeyByZW1vdmVQcm9wcyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRHVtbXlJbnB1dCh7XG4gIGlubmVyUmVmLFxuICAuLi5wcm9wc1xufTogSlNYLkludHJpbnNpY0VsZW1lbnRzWydpbnB1dCddICYge1xuICByZWFkb25seSBpbm5lclJlZjogUmVmPEhUTUxJbnB1dEVsZW1lbnQ+O1xufSkge1xuICAvLyBSZW1vdmUgYW5pbWF0aW9uIHByb3BzIG5vdCBtZWFudCBmb3IgSFRNTCBlbGVtZW50c1xuICBjb25zdCBmaWx0ZXJlZFByb3BzID0gcmVtb3ZlUHJvcHMoXG4gICAgcHJvcHMsXG4gICAgJ29uRXhpdGVkJyxcbiAgICAnaW4nLFxuICAgICdlbnRlcicsXG4gICAgJ2V4aXQnLFxuICAgICdhcHBlYXInXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8aW5wdXRcbiAgICAgIHJlZj17aW5uZXJSZWZ9XG4gICAgICB7Li4uZmlsdGVyZWRQcm9wc31cbiAgICAgIGNzcz17e1xuICAgICAgICBsYWJlbDogJ2R1bW15SW5wdXQnLFxuICAgICAgICAvLyBnZXQgcmlkIG9mIGFueSBkZWZhdWx0IHN0eWxlc1xuICAgICAgICBiYWNrZ3JvdW5kOiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgdGhpcyBoaWRlcyB0aGUgZmxhc2hpbmcgY3Vyc29yXG4gICAgICAgIGNhcmV0Q29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIGdyaWRBcmVhOiAnMSAvIDEgLyAyIC8gMycsXG4gICAgICAgIG91dGxpbmU6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIC8vIGltcG9ydGFudCEgd2l0aG91dCBgd2lkdGhgIGJyb3dzZXJzIHdvbid0IGFsbG93IGZvY3VzXG4gICAgICAgIHdpZHRoOiAxLFxuXG4gICAgICAgIC8vIHJlbW92ZSBjdXJzb3Igb24gZGVza3RvcFxuICAgICAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAgICAgICAvLyByZW1vdmUgY3Vyc29yIG9uIG1vYmlsZSB3aGlsc3QgbWFpbnRhaW5pbmcgXCJzY3JvbGwgaW50byB2aWV3XCIgYmVoYXZpb3VyXG4gICAgICAgIGxlZnQ6IC0xMDAsXG4gICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSguMDEpJyxcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn1cbiJdfQ== */")
  }));
}
var cancelScroll = function cancelScroll2(event) {
  if (event.cancelable) event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = (0, import_react6.useRef)(false);
  var isTop = (0, import_react6.useRef)(false);
  var touchStart = (0, import_react6.useRef)(0);
  var scrollTarget = (0, import_react6.useRef)(null);
  var handleEventDelta = (0, import_react6.useCallback)(function(event, delta) {
    if (scrollTarget.current === null) return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave) onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave) onTopLeave(event);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = (0, import_react6.useCallback)(function(event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = (0, import_react6.useCallback)(function(event) {
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = (0, import_react6.useCallback)(function(event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = (0, import_react6.useCallback)(function(el) {
    if (!el) return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener("wheel", onWheel, notPassive);
    el.addEventListener("touchstart", onTouchStart, notPassive);
    el.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = (0, import_react6.useCallback)(function(el) {
    if (!el) return;
    el.removeEventListener("wheel", onWheel, false);
    el.removeEventListener("touchstart", onTouchStart, false);
    el.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  (0, import_react6.useEffect)(function() {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e2) {
  if (e2.cancelable) e2.preventDefault();
}
function allowTouchMove(e2) {
  e2.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM2 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = (0, import_react6.useRef)({});
  var scrollTarget = (0, import_react6.useRef)(null);
  var addScrollLock = (0, import_react6.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM2) return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = (0, import_react6.useCallback)(function(touchScrollTarget) {
    if (!canUseDOM2) return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  (0, import_react6.useEffect)(function() {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
function _EMOTION_STRINGIFIED_CSS_ERROR__$1() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var blurSelectInput = function blurSelectInput2(event) {
  var element = event.target;
  return element.ownerDocument.activeElement && element.ownerDocument.activeElement.blur();
};
var _ref2$1 = false ? {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} : {
  name: "bp8cua-ScrollManager",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0;label:ScrollManager;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlNjcm9sbE1hbmFnZXIudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EVSIsImZpbGUiOiJTY3JvbGxNYW5hZ2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAanN4IGpzeCAqL1xuaW1wb3J0IHsganN4IH0gZnJvbSAnQGVtb3Rpb24vcmVhY3QnO1xuaW1wb3J0IHsgRnJhZ21lbnQsIFJlYWN0RWxlbWVudCwgUmVmQ2FsbGJhY2ssIE1vdXNlRXZlbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdXNlU2Nyb2xsQ2FwdHVyZSBmcm9tICcuL3VzZVNjcm9sbENhcHR1cmUnO1xuaW1wb3J0IHVzZVNjcm9sbExvY2sgZnJvbSAnLi91c2VTY3JvbGxMb2NrJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgcmVhZG9ubHkgY2hpbGRyZW46IChyZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PikgPT4gUmVhY3RFbGVtZW50O1xuICByZWFkb25seSBsb2NrRW5hYmxlZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FwdHVyZUVuYWJsZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG9uQm90dG9tQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Cb3R0b21MZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG4gIHJlYWRvbmx5IG9uVG9wQXJyaXZlPzogKGV2ZW50OiBXaGVlbEV2ZW50IHwgVG91Y2hFdmVudCkgPT4gdm9pZDtcbiAgcmVhZG9ubHkgb25Ub3BMZWF2ZT86IChldmVudDogV2hlZWxFdmVudCB8IFRvdWNoRXZlbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGJsdXJTZWxlY3RJbnB1dCA9IChldmVudDogTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgcmV0dXJuIChcbiAgICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgIChlbGVtZW50Lm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYmx1cigpXG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxNYW5hZ2VyKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2tFbmFibGVkLFxuICBjYXB0dXJlRW5hYmxlZCA9IHRydWUsXG4gIG9uQm90dG9tQXJyaXZlLFxuICBvbkJvdHRvbUxlYXZlLFxuICBvblRvcEFycml2ZSxcbiAgb25Ub3BMZWF2ZSxcbn06IFByb3BzKSB7XG4gIGNvbnN0IHNldFNjcm9sbENhcHR1cmVUYXJnZXQgPSB1c2VTY3JvbGxDYXB0dXJlKHtcbiAgICBpc0VuYWJsZWQ6IGNhcHR1cmVFbmFibGVkLFxuICAgIG9uQm90dG9tQXJyaXZlLFxuICAgIG9uQm90dG9tTGVhdmUsXG4gICAgb25Ub3BBcnJpdmUsXG4gICAgb25Ub3BMZWF2ZSxcbiAgfSk7XG4gIGNvbnN0IHNldFNjcm9sbExvY2tUYXJnZXQgPSB1c2VTY3JvbGxMb2NrKHsgaXNFbmFibGVkOiBsb2NrRW5hYmxlZCB9KTtcblxuICBjb25zdCB0YXJnZXRSZWY6IFJlZkNhbGxiYWNrPEhUTUxFbGVtZW50PiA9IChlbGVtZW50KSA9PiB7XG4gICAgc2V0U2Nyb2xsQ2FwdHVyZVRhcmdldChlbGVtZW50KTtcbiAgICBzZXRTY3JvbGxMb2NrVGFyZ2V0KGVsZW1lbnQpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge2xvY2tFbmFibGVkICYmIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgIG9uQ2xpY2s9e2JsdXJTZWxlY3RJbnB1dH1cbiAgICAgICAgICBjc3M9e3sgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDAsIHRvcDogMCB9fVxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIHtjaGlsZHJlbih0YXJnZXRSZWYpfVxuICAgIDwvRnJhZ21lbnQ+XG4gICk7XG59XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__$1
};
function ScrollManager(_ref3) {
  var children = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(import_react6.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
function _EMOTION_STRINGIFIED_CSS_ERROR__2() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var _ref22 = false ? {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} : {
  name: "5kkxb2-requiredInput-RequiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%;label:RequiredInput;",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlcXVpcmVkSW5wdXQudHN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNJIiwiZmlsZSI6IlJlcXVpcmVkSW5wdXQudHN4Iiwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBqc3gganN4ICovXG5pbXBvcnQgeyBGb2N1c0V2ZW50SGFuZGxlciwgRnVuY3Rpb25Db21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XG5cbmNvbnN0IFJlcXVpcmVkSW5wdXQ6IEZ1bmN0aW9uQ29tcG9uZW50PHtcbiAgcmVhZG9ubHkgbmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgb25Gb2N1czogRm9jdXNFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD47XG59PiA9ICh7IG5hbWUsIG9uRm9jdXMgfSkgPT4gKFxuICA8aW5wdXRcbiAgICByZXF1aXJlZFxuICAgIG5hbWU9e25hbWV9XG4gICAgdGFiSW5kZXg9ey0xfVxuICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgb25Gb2N1cz17b25Gb2N1c31cbiAgICBjc3M9e3tcbiAgICAgIGxhYmVsOiAncmVxdWlyZWRJbnB1dCcsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH19XG4gICAgLy8gUHJldmVudCBgU3dpdGNoaW5nIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWRgIGVycm9yXG4gICAgdmFsdWU9XCJcIlxuICAgIG9uQ2hhbmdlPXsoKSA9PiB7fX1cbiAgLz5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFJlcXVpcmVkSW5wdXQ7XG4iXX0= */",
  toString: _EMOTION_STRINGIFIED_CSS_ERROR__2
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: true,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref22,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
function testPlatform(re2) {
  var _window$navigator$use;
  return typeof window !== "undefined" && window.navigator != null ? re2.test(((_window$navigator$use = window.navigator["userAgentData"]) === null || _window$navigator$use === void 0 ? void 0 : _window$navigator$use.platform) || window.navigator.platform) : false;
}
function isIPhone() {
  return testPlatform(/^iPhone/i);
}
function isMac() {
  return testPlatform(/^Mac/i);
}
function isIPad() {
  return testPlatform(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  isMac() && navigator.maxTouchPoints > 1;
}
function isIOS() {
  return isIPhone() || isIPad();
}
function isAppleDevice() {
  return isMac() || isIOS();
}
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css3,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptionsWithIds(categorizedOptions, optionId) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return {
          data: option.data,
          id: "".concat(optionId, "-").concat(categorizedOption.index, "-").concat(option.index)
        };
      })));
    } else {
      optionsAccumulator.push({
        data: categorizedOption.data,
        id: "".concat(optionId, "-").concat(categorizedOption.index)
      });
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getFocusedOptionId = function getFocusedOptionId2(focusableOptionsWithIds, focusedOption) {
  var _focusableOptionsWith;
  var focusedOptionId = (_focusableOptionsWith = focusableOptionsWithIds.find(function(option) {
    return option.data === focusedOption;
  })) === null || _focusableOptionsWith === void 0 ? void 0 : _focusableOptionsWith.id;
  return focusedOptionId || null;
};
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i3) {
    return getOptionValue2(props, i3) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0) return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.isAppleDevice = isAppleDevice();
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i3) {
          return _this.getOptionValue(i3) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i3) {
        return _this.getOptionValue(i3) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      if (lastSelectedValue) {
        _this.onChange(newValue, {
          action: "pop-value",
          removedValue: lastSelectedValue
        });
      }
    };
    _this.getFocusedOptionId = function(focusedOption) {
      return getFocusedOptionId(_this.state.focusableOptionsWithIds, focusedOption);
    };
    _this.getFocusableOptionsWithIds = function() {
      return buildFocusableOptionsWithIds(buildCategorizedOptions(_this.props, _this.state.selectValue), _this.getElementId("option"));
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled;
      var base = defaultStyles[key](props, unstyled);
      base.boxSizing = "border-box";
      var custom2 = _this.props.styles[key];
      return custom2 ? custom2(base, props) : base;
    };
    _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.state.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event) {
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== "INPUT" && event.target.tagName !== "TEXTAREA") {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event) {
      if (event && event.type === "mousedown" && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref23) {
      var touches = _ref23.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function(event) {
      if (_this.userIsDragging) return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function(event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      var options2 = _this.getFocusableOptions();
      var focusedOptionIndex = options2.indexOf(focusedOption);
      _this.setState({
        focusedOption,
        focusedOptionId: focusedOptionIndex > -1 ? _this.getFocusedOptionId(focusedOption) : null
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e2) {
      e2.preventDefault();
      e2.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled) return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue) return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue) return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue) return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing) return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption) return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen) return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen) return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen) return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen) return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.state.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptionsWithIds = _this.getFocusableOptionsWithIds();
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusableOptionsWithIds = focusableOptionsWithIds;
      _this.state.focusedOption = focusableOptions[optionIndex];
      _this.state.focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusableOptions[optionIndex]);
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex],
        focusedOptionId: this.getFocusedOptionId(focusableOptions[openAtIndex])
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti) return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length) return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1) nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null,
        focusedOptionId: this.getFocusedOptionId(options2[nextFocus])
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme3() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0) return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input3 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return React6.createElement(DummyInput, _extends({
            id,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop4,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return React6.createElement(Input3, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel3 = _this$getComponents2.MultiValueLabel, MultiValueRemove3 = _this$getComponents2.MultiValueRemove, SingleValue4 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : React6.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index2) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return React6.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel3,
              Remove: MultiValueRemove3
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e2) {
                e2.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return React6.createElement(SingleValue4, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator4 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator4 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return React6.createElement(ClearIndicator4, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading) return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return React6.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator4 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator4 || !IndicatorSeparator3) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return React6.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator4 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator4) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return React6.createElement(DropdownIndicator4, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu5 = _this$getComponents7.Menu, MenuList4 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage4 = _this$getComponents7.NoOptionsMessage, Option4 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen) return null;
      var render = function render2(props, id) {
        var type = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1,
          role: "option",
          "aria-selected": _this4.isAppleDevice ? void 0 : isSelected
          // is not supported on Apple devices
        };
        return React6.createElement(Option4, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label,
          type,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item) {
          if (item.type === "group") {
            var _data = item.data, options2 = item.options, groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return React6.createElement(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item.data
              },
              label: _this4.formatGroupLabel(item.data)
            }), item.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item.type === "option") {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message2 = loadingMessage2({
          inputValue
        });
        if (message2 === null) return null;
        menuUI = React6.createElement(LoadingMessage3, commonProps, message2);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null) return null;
        menuUI = React6.createElement(NoOptionsMessage4, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = React6.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return React6.createElement(Menu5, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove
          },
          isLoading,
          placement
        }), React6.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return React6.createElement(MenuList4, _extends({}, commonProps, {
            innerRef: function innerRef(instance) {
              _this4.getMenuListRef(instance);
              scrollTargetRef(instance);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": commonProps.isMulti,
              id: _this4.getElementId("listbox")
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? React6.createElement(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return React6.createElement(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled) return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return React6.createElement("input", {
            name,
            type: "hidden",
            value
          });
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function(opt, i3) {
            return React6.createElement("input", {
              key: "i-".concat(i3),
              name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : React6.createElement("input", {
            name,
            type: "hidden",
            value: ""
          });
          return React6.createElement("div", null, input);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return React6.createElement("input", {
          name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return React6.createElement(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return React6.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), React6.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), React6.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), React6.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused, instancePrefix = state.instancePrefix;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusableOptionsWithIds = menuIsOpen ? buildFocusableOptionsWithIds(buildCategorizedOptions(props, selectValue), "".concat(instancePrefix, "-option")) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        var focusedOptionId = getFocusedOptionId(focusableOptionsWithIds, focusedOption);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedOptionId,
          focusableOptionsWithIds,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(import_react6.Component);
Select.defaultProps = defaultProps;

// node_modules/react-select/dist/react-select.esm.js
var import_react_dom2 = __toESM(require_react_dom());
var StateManagedSelect = (0, import_react8.forwardRef)(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return React7.createElement(Select, _extends({
    ref
  }, baseSelectProps));
});
var StateManagedSelect$1 = StateManagedSelect;

// node_modules/react-virtuoso/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var we = 0;
var zt = 1;
var qt = 2;
var En = 4;
function ln(t3) {
  return () => t3;
}
function co(t3) {
  t3();
}
function ne(t3, e2) {
  return (n3) => t3(e2(n3));
}
function cn(t3, e2) {
  return () => t3(e2);
}
function kn(t3, e2) {
  return (n3) => t3(e2, n3);
}
function Me(t3) {
  return t3 !== void 0;
}
function uo(...t3) {
  return () => {
    t3.map(co);
  };
}
function Yt() {
}
function ye(t3, e2) {
  return e2(t3), t3;
}
function ao(t3, e2) {
  return e2(t3);
}
function X(...t3) {
  return t3;
}
function K(t3, e2) {
  return t3(zt, e2);
}
function W(t3, e2) {
  t3(we, e2);
}
function We(t3) {
  t3(qt);
}
function lt2(t3) {
  return t3(En);
}
function F(t3, e2) {
  return K(t3, kn(e2, we));
}
function Rt(t3, e2) {
  const n3 = t3(zt, (o3) => {
    n3(), e2(o3);
  });
  return n3;
}
function un(t3) {
  let e2, n3;
  return (o3) => (r3) => {
    e2 = r3, n3 && clearTimeout(n3), n3 = setTimeout(() => {
      o3(e2);
    }, t3);
  };
}
function Bn(t3, e2) {
  return t3 === e2;
}
function Y(t3 = Bn) {
  let e2;
  return (n3) => (o3) => {
    t3(e2, o3) || (e2 = o3, n3(o3));
  };
}
function P(t3) {
  return (e2) => (n3) => {
    t3(n3) && e2(n3);
  };
}
function E(t3) {
  return (e2) => ne(e2, t3);
}
function vt(t3) {
  return (e2) => () => {
    e2(t3);
  };
}
function x(t3, ...e2) {
  const n3 = fo(...e2);
  return (o3, r3) => {
    switch (o3) {
      case qt:
        We(t3);
        return;
      case zt:
        return K(t3, n3(r3));
    }
  };
}
function bt(t3, e2) {
  return (n3) => (o3) => {
    n3(e2 = t3(e2, o3));
  };
}
function jt(t3) {
  return (e2) => (n3) => {
    t3 > 0 ? t3-- : e2(n3);
  };
}
function Lt(t3) {
  let e2 = null, n3;
  return (o3) => (r3) => {
    e2 = r3, !n3 && (n3 = setTimeout(() => {
      n3 = void 0, o3(e2);
    }, t3));
  };
}
function G(...t3) {
  const e2 = new Array(t3.length);
  let n3 = 0, o3 = null;
  const r3 = Math.pow(2, t3.length) - 1;
  return t3.forEach((s3, i3) => {
    const l2 = Math.pow(2, i3);
    K(s3, (c2) => {
      const u2 = n3;
      n3 = n3 | l2, e2[i3] = c2, u2 !== r3 && n3 === r3 && o3 && (o3(), o3 = null);
    });
  }), (s3) => (i3) => {
    const l2 = () => {
      s3([i3].concat(e2));
    };
    n3 === r3 ? l2() : o3 = l2;
  };
}
function fo(...t3) {
  return (e2) => t3.reduceRight(ao, e2);
}
function mo(t3) {
  let e2, n3;
  const o3 = () => e2 == null ? void 0 : e2();
  return function(r3, s3) {
    switch (r3) {
      case zt:
        return s3 ? n3 === s3 ? void 0 : (o3(), n3 = s3, e2 = K(t3, s3), e2) : (o3(), Yt);
      case qt:
        o3(), n3 = null;
        return;
    }
  };
}
function y(t3) {
  let e2 = t3;
  const n3 = $();
  return (o3, r3) => {
    switch (o3) {
      case we:
        e2 = r3;
        break;
      case zt: {
        r3(e2);
        break;
      }
      case En:
        return e2;
    }
    return n3(o3, r3);
  };
}
function ct(t3, e2) {
  return ye(y(e2), (n3) => F(t3, n3));
}
function $() {
  const t3 = [];
  return (e2, n3) => {
    switch (e2) {
      case we:
        t3.slice().forEach((o3) => {
          o3(n3);
        });
        return;
      case qt:
        t3.splice(0, t3.length);
        return;
      case zt:
        return t3.push(n3), () => {
          const o3 = t3.indexOf(n3);
          o3 > -1 && t3.splice(o3, 1);
        };
    }
  };
}
function pt(t3) {
  return ye($(), (e2) => F(t3, e2));
}
function U(t3, e2 = [], { singleton: n3 } = { singleton: true }) {
  return {
    constructor: t3,
    dependencies: e2,
    id: po(),
    singleton: n3
  };
}
var po = () => Symbol();
function ho(t3) {
  const e2 = /* @__PURE__ */ new Map(), n3 = ({ constructor: o3, dependencies: r3, id: s3, singleton: i3 }) => {
    if (i3 && e2.has(s3))
      return e2.get(s3);
    const l2 = o3(r3.map((c2) => n3(c2)));
    return i3 && e2.set(s3, l2), l2;
  };
  return n3(t3);
}
function rt(...t3) {
  const e2 = $(), n3 = new Array(t3.length);
  let o3 = 0;
  const r3 = Math.pow(2, t3.length) - 1;
  return t3.forEach((s3, i3) => {
    const l2 = Math.pow(2, i3);
    K(s3, (c2) => {
      n3[i3] = c2, o3 = o3 | l2, o3 === r3 && W(e2, n3);
    });
  }), function(s3, i3) {
    switch (s3) {
      case qt: {
        We(e2);
        return;
      }
      case zt:
        return o3 === r3 && i3(n3), K(e2, i3);
    }
  };
}
function A(t3, e2 = Bn) {
  return x(t3, Y(e2));
}
function an(...t3) {
  return function(e2, n3) {
    switch (e2) {
      case qt:
        return;
      case zt:
        return uo(...t3.map((o3) => K(o3, n3)));
    }
  };
}
var ht = ((t3) => (t3[t3.DEBUG = 0] = "DEBUG", t3[t3.INFO = 1] = "INFO", t3[t3.WARN = 2] = "WARN", t3[t3.ERROR = 3] = "ERROR", t3))(ht || {});
var go = {
  0: "debug",
  3: "error",
  1: "log",
  2: "warn"
};
var Io = () => typeof globalThis > "u" ? window : globalThis;
var Vt = U(
  () => {
    const t3 = y(
      3
      /* ERROR */
    );
    return {
      log: y((n3, o3, r3 = 1) => {
        var i3;
        const s3 = (i3 = Io().VIRTUOSO_LOG_LEVEL) != null ? i3 : lt2(t3);
        r3 >= s3 && console[go[r3]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          n3,
          o3
        );
      }),
      logLevel: t3
    };
  },
  [],
  { singleton: true }
);
function Ht(t3, e2, n3) {
  return _e(t3, e2, n3).callbackRef;
}
function _e(t3, e2, n3) {
  const o3 = import_react10.default.useRef(null);
  let r3 = (s3) => {
  };
  if (typeof ResizeObserver < "u") {
    const s3 = import_react10.default.useMemo(() => new ResizeObserver((i3) => {
      const l2 = () => {
        const c2 = i3[0].target;
        c2.offsetParent !== null && t3(c2);
      };
      n3 ? l2() : requestAnimationFrame(l2);
    }), [t3]);
    r3 = (i3) => {
      i3 && e2 ? (s3.observe(i3), o3.current = i3) : (o3.current && s3.unobserve(o3.current), o3.current = null);
    };
  }
  return { callbackRef: r3, ref: o3 };
}
function On(t3, e2, n3, o3, r3, s3, i3, l2, c2) {
  const u2 = import_react10.default.useCallback(
    (f2) => {
      const S3 = So(f2.children, e2, l2 ? "offsetWidth" : "offsetHeight", r3);
      let p2 = f2.parentElement;
      for (; !p2.dataset.virtuosoScroller; )
        p2 = p2.parentElement;
      const m2 = p2.lastElementChild.dataset.viewportType === "window";
      let w3;
      m2 && (w3 = p2.ownerDocument.defaultView);
      const I = i3 ? l2 ? i3.scrollLeft : i3.scrollTop : m2 ? l2 ? w3.scrollX || w3.document.documentElement.scrollLeft : w3.scrollY || w3.document.documentElement.scrollTop : l2 ? p2.scrollLeft : p2.scrollTop, C = i3 ? l2 ? i3.scrollWidth : i3.scrollHeight : m2 ? l2 ? w3.document.documentElement.scrollWidth : w3.document.documentElement.scrollHeight : l2 ? p2.scrollWidth : p2.scrollHeight, g2 = i3 ? l2 ? i3.offsetWidth : i3.offsetHeight : m2 ? l2 ? w3.innerWidth : w3.innerHeight : l2 ? p2.offsetWidth : p2.offsetHeight;
      o3({
        scrollHeight: C,
        scrollTop: Math.max(I, 0),
        viewportHeight: g2
      }), s3 == null || s3(
        l2 ? dn("column-gap", getComputedStyle(f2).columnGap, r3) : dn("row-gap", getComputedStyle(f2).rowGap, r3)
      ), S3 !== null && t3(S3);
    },
    [t3, e2, r3, s3, i3, o3]
  );
  return _e(u2, n3, c2);
}
function So(t3, e2, n3, o3) {
  const r3 = t3.length;
  if (r3 === 0)
    return null;
  const s3 = [];
  for (let i3 = 0; i3 < r3; i3++) {
    const l2 = t3.item(i3);
    if (l2.dataset.index === void 0)
      continue;
    const c2 = parseInt(l2.dataset.index), u2 = parseFloat(l2.dataset.knownSize), f2 = e2(l2, n3);
    if (f2 === 0 && o3("Zero-sized element, this should not happen", { child: l2 }, ht.ERROR), f2 === u2)
      continue;
    const S3 = s3[s3.length - 1];
    s3.length === 0 || S3.size !== f2 || S3.endIndex !== c2 - 1 ? s3.push({ endIndex: c2, size: f2, startIndex: c2 }) : s3[s3.length - 1].endIndex++;
  }
  return s3;
}
function dn(t3, e2, n3) {
  return e2 !== "normal" && !(e2 != null && e2.endsWith("px")) && n3(`${t3} was not resolved to pixel value correctly`, e2, ht.WARN), e2 === "normal" ? 0 : parseInt(e2 != null ? e2 : "0", 10);
}
function Ge(t3, e2, n3) {
  const o3 = import_react10.default.useRef(null), r3 = import_react10.default.useCallback(
    (c2) => {
      if (!(c2 != null && c2.offsetParent))
        return;
      const u2 = c2.getBoundingClientRect(), f2 = u2.width;
      let S3, p2;
      if (e2) {
        const m2 = e2.getBoundingClientRect(), w3 = u2.top - m2.top;
        p2 = m2.height - Math.max(0, w3), S3 = w3 + e2.scrollTop;
      } else {
        const m2 = i3.current.ownerDocument.defaultView;
        p2 = m2.innerHeight - Math.max(0, u2.top), S3 = u2.top + m2.scrollY;
      }
      o3.current = {
        offsetTop: S3,
        visibleHeight: p2,
        visibleWidth: f2
      }, t3(o3.current);
    },
    [t3, e2]
  ), { callbackRef: s3, ref: i3 } = _e(r3, true, n3), l2 = import_react10.default.useCallback(() => {
    r3(i3.current);
  }, [r3, i3]);
  return import_react10.default.useEffect(() => {
    var c2;
    if (e2) {
      e2.addEventListener("scroll", l2);
      const u2 = new ResizeObserver(() => {
        requestAnimationFrame(l2);
      });
      return u2.observe(e2), () => {
        e2.removeEventListener("scroll", l2), u2.unobserve(e2);
      };
    } else {
      const u2 = (c2 = i3.current) == null ? void 0 : c2.ownerDocument.defaultView;
      return u2 == null || u2.addEventListener("scroll", l2), u2 == null || u2.addEventListener("resize", l2), () => {
        u2 == null || u2.removeEventListener("scroll", l2), u2 == null || u2.removeEventListener("resize", l2);
      };
    }
  }, [l2, e2]), s3;
}
var at = U(
  () => {
    const t3 = $(), e2 = $(), n3 = y(0), o3 = $(), r3 = y(0), s3 = $(), i3 = $(), l2 = y(0), c2 = y(0), u2 = y(0), f2 = y(0), S3 = $(), p2 = $(), m2 = y(false), w3 = y(false), I = y(false);
    return F(
      x(
        t3,
        E(({ scrollTop: C }) => C)
      ),
      e2
    ), F(
      x(
        t3,
        E(({ scrollHeight: C }) => C)
      ),
      i3
    ), F(e2, r3), {
      deviation: n3,
      fixedFooterHeight: u2,
      fixedHeaderHeight: c2,
      footerHeight: f2,
      headerHeight: l2,
      horizontalDirection: w3,
      scrollBy: p2,
      // input
      scrollContainerState: t3,
      scrollHeight: i3,
      scrollingInProgress: m2,
      // signals
      scrollTo: S3,
      scrollTop: e2,
      skipAnimationFrameInResizeObserver: I,
      smoothScrollTargetReached: o3,
      // state
      statefulScrollTop: r3,
      viewportHeight: s3
    };
  },
  [],
  { singleton: true }
);
var oe = { lvl: 0 };
function Fn(t3, e2) {
  const n3 = t3.length;
  if (n3 === 0)
    return [];
  let { index: o3, value: r3 } = e2(t3[0]);
  const s3 = [];
  for (let i3 = 1; i3 < n3; i3++) {
    const { index: l2, value: c2 } = e2(t3[i3]);
    s3.push({ end: l2 - 1, start: o3, value: r3 }), o3 = l2, r3 = c2;
  }
  return s3.push({ end: 1 / 0, start: o3, value: r3 }), s3;
}
function j(t3) {
  return t3 === oe;
}
function re(t3, e2) {
  if (!j(t3))
    return e2 === t3.k ? t3.v : e2 < t3.k ? re(t3.l, e2) : re(t3.r, e2);
}
function Ct(t3, e2, n3 = "k") {
  if (j(t3))
    return [-1 / 0, void 0];
  if (Number(t3[n3]) === e2)
    return [t3.k, t3.v];
  if (Number(t3[n3]) < e2) {
    const o3 = Ct(t3.r, e2, n3);
    return o3[0] === -1 / 0 ? [t3.k, t3.v] : o3;
  }
  return Ct(t3.l, e2, n3);
}
function mt(t3, e2, n3) {
  return j(t3) ? Vn(e2, n3, 1) : e2 === t3.k ? ot(t3, { k: e2, v: n3 }) : e2 < t3.k ? fn(ot(t3, { l: mt(t3.l, e2, n3) })) : fn(ot(t3, { r: mt(t3.r, e2, n3) }));
}
function Ut() {
  return oe;
}
function ve(t3, e2, n3) {
  if (j(t3))
    return [];
  const o3 = Ct(t3, e2)[0];
  return xo(ze(t3, o3, n3));
}
function Le(t3, e2) {
  if (j(t3)) return oe;
  const { k: n3, l: o3, r: r3 } = t3;
  if (e2 === n3) {
    if (j(o3))
      return r3;
    if (j(r3))
      return o3;
    {
      const [s3, i3] = zn(o3);
      return ge(ot(t3, { k: s3, l: Ln(o3), v: i3 }));
    }
  } else return e2 < n3 ? ge(ot(t3, { l: Le(o3, e2) })) : ge(ot(t3, { r: Le(r3, e2) }));
}
function _t(t3) {
  return j(t3) ? [] : [..._t(t3.l), { k: t3.k, v: t3.v }, ..._t(t3.r)];
}
function ze(t3, e2, n3) {
  if (j(t3))
    return [];
  const { k: o3, l: r3, r: s3, v: i3 } = t3;
  let l2 = [];
  return o3 > e2 && (l2 = l2.concat(ze(r3, e2, n3))), o3 >= e2 && o3 <= n3 && l2.push({ k: o3, v: i3 }), o3 <= n3 && (l2 = l2.concat(ze(s3, e2, n3))), l2;
}
function ge(t3) {
  const { l: e2, lvl: n3, r: o3 } = t3;
  if (o3.lvl >= n3 - 1 && e2.lvl >= n3 - 1)
    return t3;
  if (n3 > o3.lvl + 1) {
    if (Ee(e2))
      return Pn(ot(t3, { lvl: n3 - 1 }));
    if (!j(e2) && !j(e2.r))
      return ot(e2.r, {
        l: ot(e2, { r: e2.r.l }),
        lvl: n3,
        r: ot(t3, {
          l: e2.r.r,
          lvl: n3 - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  } else {
    if (Ee(t3))
      return Ve(ot(t3, { lvl: n3 - 1 }));
    if (!j(o3) && !j(o3.l)) {
      const r3 = o3.l, s3 = Ee(r3) ? o3.lvl - 1 : o3.lvl;
      return ot(r3, {
        l: ot(t3, {
          lvl: n3 - 1,
          r: r3.l
        }),
        lvl: r3.lvl + 1,
        r: Ve(ot(o3, { l: r3.r, lvl: s3 }))
      });
    } else
      throw new Error("Unexpected empty nodes");
  }
}
function ot(t3, e2) {
  return Vn(
    e2.k !== void 0 ? e2.k : t3.k,
    e2.v !== void 0 ? e2.v : t3.v,
    e2.lvl !== void 0 ? e2.lvl : t3.lvl,
    e2.l !== void 0 ? e2.l : t3.l,
    e2.r !== void 0 ? e2.r : t3.r
  );
}
function Ln(t3) {
  return j(t3.r) ? t3.l : ge(ot(t3, { r: Ln(t3.r) }));
}
function Ee(t3) {
  return j(t3) || t3.lvl > t3.r.lvl;
}
function zn(t3) {
  return j(t3.r) ? [t3.k, t3.v] : zn(t3.r);
}
function Vn(t3, e2, n3, o3 = oe, r3 = oe) {
  return { k: t3, l: o3, lvl: n3, r: r3, v: e2 };
}
function fn(t3) {
  return Ve(Pn(t3));
}
function Pn(t3) {
  const { l: e2 } = t3;
  return !j(e2) && e2.lvl === t3.lvl ? ot(e2, { r: ot(t3, { l: e2.r }) }) : t3;
}
function Ve(t3) {
  const { lvl: e2, r: n3 } = t3;
  return !j(n3) && !j(n3.r) && n3.lvl === e2 && n3.r.lvl === e2 ? ot(n3, { l: ot(t3, { r: n3.l }), lvl: e2 + 1 }) : t3;
}
function xo(t3) {
  return Fn(t3, ({ k: e2, v: n3 }) => ({ index: e2, value: n3 }));
}
function An(t3, e2) {
  return !!(t3 && t3.startIndex === e2.startIndex && t3.endIndex === e2.endIndex);
}
function se(t3, e2) {
  return !!(t3 && t3[0] === e2[0] && t3[1] === e2[1]);
}
var Ne = U(
  () => ({ recalcInProgress: y(false) }),
  [],
  { singleton: true }
);
function Mn(t3, e2, n3) {
  return t3[Se(t3, e2, n3)];
}
function Se(t3, e2, n3, o3 = 0) {
  let r3 = t3.length - 1;
  for (; o3 <= r3; ) {
    const s3 = Math.floor((o3 + r3) / 2), i3 = t3[s3], l2 = n3(i3, e2);
    if (l2 === 0)
      return s3;
    if (l2 === -1) {
      if (r3 - o3 < 2)
        return s3 - 1;
      r3 = s3 - 1;
    } else {
      if (r3 === o3)
        return s3;
      o3 = s3 + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${t3.join(",")}, searched for ${e2}`);
}
function To(t3, e2, n3, o3) {
  const r3 = Se(t3, e2, o3), s3 = Se(t3, n3, o3, r3);
  return t3.slice(r3, s3 + 1);
}
function wt(t3, e2) {
  return Math.round(t3.getBoundingClientRect()[e2]);
}
function be(t3) {
  return !j(t3.groupOffsetTree);
}
function De({ index: t3 }, e2) {
  return e2 === t3 ? 0 : e2 < t3 ? -1 : 1;
}
function Co() {
  return {
    groupIndices: [],
    groupOffsetTree: Ut(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    offsetTree: [],
    sizeTree: Ut()
  };
}
function wo(t3, e2) {
  let n3 = j(t3) ? 0 : 1 / 0;
  for (const o3 of e2) {
    const { endIndex: r3, size: s3, startIndex: i3 } = o3;
    if (n3 = Math.min(n3, i3), j(t3)) {
      t3 = mt(t3, 0, s3);
      continue;
    }
    const l2 = ve(t3, i3 - 1, r3 + 1);
    if (l2.some(ko(o3)))
      continue;
    let c2 = false, u2 = false;
    for (const { end: f2, start: S3, value: p2 } of l2)
      c2 ? (r3 >= S3 || s3 === p2) && (t3 = Le(t3, S3)) : (u2 = p2 !== s3, c2 = true), f2 > r3 && r3 >= S3 && p2 !== s3 && (t3 = mt(t3, r3 + 1, p2));
    u2 && (t3 = mt(t3, i3, s3));
  }
  return [t3, n3];
}
function yo(t3) {
  return typeof t3.groupIndex < "u";
}
function vo({ offset: t3 }, e2) {
  return e2 === t3 ? 0 : e2 < t3 ? -1 : 1;
}
function ie(t3, e2, n3) {
  if (e2.length === 0)
    return 0;
  const { index: o3, offset: r3, size: s3 } = Mn(e2, t3, De), i3 = t3 - o3, l2 = s3 * i3 + (i3 - 1) * n3 + r3;
  return l2 > 0 ? l2 + n3 : l2;
}
function Wn(t3, e2) {
  if (!be(e2))
    return t3;
  let n3 = 0;
  for (; e2.groupIndices[n3] <= t3 + n3; )
    n3++;
  return t3 + n3;
}
function _n(t3, e2, n3) {
  if (yo(t3))
    return e2.groupIndices[t3.groupIndex] + 1;
  {
    const o3 = t3.index === "LAST" ? n3 : t3.index;
    let r3 = Wn(o3, e2);
    return r3 = Math.max(0, r3, Math.min(n3, r3)), r3;
  }
}
function bo(t3, e2, n3, o3 = 0) {
  return o3 > 0 && (e2 = Math.max(e2, Mn(t3, o3, De).offset)), Fn(To(t3, e2, n3, vo), Eo);
}
function Ro(t3, [e2, n3, o3, r3]) {
  e2.length > 0 && o3("received item sizes", e2, ht.DEBUG);
  const s3 = t3.sizeTree;
  let i3 = s3, l2 = 0;
  if (n3.length > 0 && j(s3) && e2.length === 2) {
    const p2 = e2[0].size, m2 = e2[1].size;
    i3 = n3.reduce((w3, I) => mt(mt(w3, I, p2), I + 1, m2), i3);
  } else
    [i3, l2] = wo(i3, e2);
  if (i3 === s3)
    return t3;
  const { lastIndex: c2, lastOffset: u2, lastSize: f2, offsetTree: S3 } = Pe(t3.offsetTree, l2, i3, r3);
  return {
    groupIndices: n3,
    groupOffsetTree: n3.reduce((p2, m2) => mt(p2, m2, ie(m2, S3, r3)), Ut()),
    lastIndex: c2,
    lastOffset: u2,
    lastSize: f2,
    offsetTree: S3,
    sizeTree: i3
  };
}
function Ho(t3) {
  return _t(t3).map(({ k: e2, v: n3 }, o3, r3) => {
    const s3 = r3[o3 + 1];
    return { endIndex: s3 ? s3.k - 1 : 1 / 0, size: n3, startIndex: e2 };
  });
}
function mn(t3, e2) {
  let n3 = 0, o3 = 0;
  for (; n3 < t3; )
    n3 += e2[o3 + 1] - e2[o3] - 1, o3++;
  return o3 - (n3 === t3 ? 0 : 1);
}
function Pe(t3, e2, n3, o3) {
  let r3 = t3, s3 = 0, i3 = 0, l2 = 0, c2 = 0;
  if (e2 !== 0) {
    c2 = Se(r3, e2 - 1, De), l2 = r3[c2].offset;
    const f2 = Ct(n3, e2 - 1);
    s3 = f2[0], i3 = f2[1], r3.length && r3[c2].size === Ct(n3, e2)[1] && (c2 -= 1), r3 = r3.slice(0, c2 + 1);
  } else
    r3 = [];
  for (const { start: u2, value: f2 } of ve(n3, e2, 1 / 0)) {
    const S3 = u2 - s3, p2 = S3 * i3 + l2 + S3 * o3;
    r3.push({
      index: u2,
      offset: p2,
      size: f2
    }), s3 = u2, l2 = p2, i3 = f2;
  }
  return {
    lastIndex: s3,
    lastOffset: l2,
    lastSize: i3,
    offsetTree: r3
  };
}
function Eo(t3) {
  return { index: t3.index, value: t3 };
}
function ko(t3) {
  const { endIndex: e2, size: n3, startIndex: o3 } = t3;
  return (r3) => r3.start === o3 && (r3.end === e2 || r3.end === 1 / 0) && r3.value === n3;
}
var Bo = {
  offsetHeight: "height",
  offsetWidth: "width"
};
var Et = U(
  ([{ log: t3 }, { recalcInProgress: e2 }]) => {
    const n3 = $(), o3 = $(), r3 = ct(o3, 0), s3 = $(), i3 = $(), l2 = y(0), c2 = y([]), u2 = y(void 0), f2 = y(void 0), S3 = y((h2, d2) => wt(h2, Bo[d2])), p2 = y(void 0), m2 = y(0), w3 = Co(), I = ct(
      x(n3, G(c2, t3, m2), bt(Ro, w3), Y()),
      w3
    ), C = ct(
      x(
        c2,
        Y(),
        bt((h2, d2) => ({ current: d2, prev: h2.current }), {
          current: [],
          prev: []
        }),
        E(({ prev: h2 }) => h2)
      ),
      []
    );
    F(
      x(
        c2,
        P((h2) => h2.length > 0),
        G(I, m2),
        E(([h2, d2, R]) => {
          const B = h2.reduce((O, L, V) => mt(O, L, ie(L, d2.offsetTree, R) || V), Ut());
          return {
            ...d2,
            groupIndices: h2,
            groupOffsetTree: B
          };
        })
      ),
      I
    ), F(
      x(
        o3,
        G(I),
        P(([h2, { lastIndex: d2 }]) => h2 < d2),
        E(([h2, { lastIndex: d2, lastSize: R }]) => [
          {
            endIndex: d2,
            size: R,
            startIndex: h2
          }
        ])
      ),
      n3
    ), F(u2, f2);
    const g2 = ct(
      x(
        u2,
        E((h2) => h2 === void 0)
      ),
      true
    );
    F(
      x(
        f2,
        P((h2) => h2 !== void 0 && j(lt2(I).sizeTree)),
        E((h2) => [{ endIndex: 0, size: h2, startIndex: 0 }])
      ),
      n3
    );
    const a2 = pt(
      x(
        n3,
        G(I),
        bt(
          ({ sizes: h2 }, [d2, R]) => ({
            changed: R !== h2,
            sizes: R
          }),
          { changed: false, sizes: w3 }
        ),
        E((h2) => h2.changed)
      )
    );
    K(
      x(
        l2,
        bt(
          (h2, d2) => ({ diff: h2.prev - d2, prev: d2 }),
          { diff: 0, prev: 0 }
        ),
        E((h2) => h2.diff)
      ),
      (h2) => {
        const { groupIndices: d2 } = lt2(I);
        if (h2 > 0)
          W(e2, true), W(s3, h2 + mn(h2, d2));
        else if (h2 < 0) {
          const R = lt2(C);
          R.length > 0 && (h2 -= mn(-h2, R)), W(i3, h2);
        }
      }
    ), K(x(l2, G(t3)), ([h2, d2]) => {
      h2 < 0 && d2(
        "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
        { firstItemIndex: l2 },
        ht.ERROR
      );
    });
    const T = pt(s3);
    F(
      x(
        s3,
        G(I),
        E(([h2, d2]) => {
          const R = d2.groupIndices.length > 0, B = [], O = d2.lastSize;
          if (R) {
            const L = re(d2.sizeTree, 0);
            let V = 0, D = 0;
            for (; V < h2; ) {
              const k2 = d2.groupIndices[D], q = d2.groupIndices.length === D + 1 ? 1 / 0 : d2.groupIndices[D + 1] - k2 - 1;
              B.push({
                endIndex: k2,
                size: L,
                startIndex: k2
              }), B.push({
                endIndex: k2 + 1 + q - 1,
                size: O,
                startIndex: k2 + 1
              }), D++, V += q + 1;
            }
            const J = _t(d2.sizeTree);
            return V !== h2 && J.shift(), J.reduce(
              (k2, { k: q, v: st }) => {
                let dt2 = k2.ranges;
                return k2.prevSize !== 0 && (dt2 = [
                  ...k2.ranges,
                  {
                    endIndex: q + h2 - 1,
                    size: k2.prevSize,
                    startIndex: k2.prevIndex
                  }
                ]), {
                  prevIndex: q + h2,
                  prevSize: st,
                  ranges: dt2
                };
              },
              {
                prevIndex: h2,
                prevSize: 0,
                ranges: B
              }
            ).ranges;
          }
          return _t(d2.sizeTree).reduce(
            (L, { k: V, v: D }) => ({
              prevIndex: V + h2,
              prevSize: D,
              ranges: [...L.ranges, { endIndex: V + h2 - 1, size: L.prevSize, startIndex: L.prevIndex }]
            }),
            {
              prevIndex: 0,
              prevSize: O,
              ranges: []
            }
          ).ranges;
        })
      ),
      n3
    );
    const b2 = pt(
      x(
        i3,
        G(I, m2),
        E(([h2, { offsetTree: d2 }, R]) => {
          const B = -h2;
          return ie(B, d2, R);
        })
      )
    );
    return F(
      x(
        i3,
        G(I, m2),
        E(([h2, d2, R]) => {
          if (d2.groupIndices.length > 0) {
            if (j(d2.sizeTree))
              return d2;
            let O = Ut();
            const L = lt2(C);
            let V = 0, D = 0, J = 0;
            for (; V < -h2; ) {
              J = L[D];
              const k2 = L[D + 1] - J - 1;
              D++, V += k2 + 1;
            }
            if (O = _t(d2.sizeTree).reduce((k2, { k: q, v: st }) => mt(k2, Math.max(0, q + h2), st), O), V !== -h2) {
              const k2 = re(d2.sizeTree, J);
              O = mt(O, 0, k2);
              const q = Ct(d2.sizeTree, -h2 + 1)[1];
              O = mt(O, 1, q);
            }
            return {
              ...d2,
              sizeTree: O,
              ...Pe(d2.offsetTree, 0, O, R)
            };
          } else {
            const O = _t(d2.sizeTree).reduce((L, { k: V, v: D }) => mt(L, Math.max(0, V + h2), D), Ut());
            return {
              ...d2,
              sizeTree: O,
              ...Pe(d2.offsetTree, 0, O, R)
            };
          }
        })
      ),
      I
    ), {
      beforeUnshiftWith: T,
      // input
      data: p2,
      defaultItemSize: f2,
      firstItemIndex: l2,
      fixedItemSize: u2,
      gap: m2,
      groupIndices: c2,
      itemSize: S3,
      listRefresh: a2,
      shiftWith: i3,
      shiftWithOffset: b2,
      sizeRanges: n3,
      // output
      sizes: I,
      statefulTotalCount: r3,
      totalCount: o3,
      trackItemSizes: g2,
      unshiftWith: s3
    };
  },
  X(Vt, Ne),
  { singleton: true }
);
function Oo(t3) {
  return t3.reduce(
    (e2, n3) => (e2.groupIndices.push(e2.totalCount), e2.totalCount += n3 + 1, e2),
    {
      groupIndices: [],
      totalCount: 0
    }
  );
}
var Gn = U(
  ([{ groupIndices: t3, sizes: e2, totalCount: n3 }, { headerHeight: o3, scrollTop: r3 }]) => {
    const s3 = $(), i3 = $(), l2 = pt(x(s3, E(Oo)));
    return F(
      x(
        l2,
        E((c2) => c2.totalCount)
      ),
      n3
    ), F(
      x(
        l2,
        E((c2) => c2.groupIndices)
      ),
      t3
    ), F(
      x(
        rt(r3, e2, o3),
        P(([c2, u2]) => be(u2)),
        E(([c2, u2, f2]) => Ct(u2.groupOffsetTree, Math.max(c2 - f2, 0), "v")[0]),
        Y(),
        E((c2) => [c2])
      ),
      i3
    ), { groupCounts: s3, topItemsIndexes: i3 };
  },
  X(Et, at)
);
var Pt = U(
  ([{ log: t3 }]) => {
    const e2 = y(false), n3 = pt(
      x(
        e2,
        P((o3) => o3),
        Y()
      )
    );
    return K(e2, (o3) => {
      o3 && lt2(t3)("props updated", {}, ht.DEBUG);
    }), { didMount: n3, propsReady: e2 };
  },
  X(Vt),
  { singleton: true }
);
var Fo = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
function Nn(t3) {
  const e2 = typeof t3 == "number" ? { index: t3 } : t3;
  return e2.align || (e2.align = "start"), (!e2.behavior || !Fo) && (e2.behavior = "auto"), e2.offset || (e2.offset = 0), e2;
}
var ce = U(
  ([
    { gap: t3, listRefresh: e2, sizes: n3, totalCount: o3 },
    {
      fixedFooterHeight: r3,
      fixedHeaderHeight: s3,
      footerHeight: i3,
      headerHeight: l2,
      scrollingInProgress: c2,
      scrollTo: u2,
      smoothScrollTargetReached: f2,
      viewportHeight: S3
    },
    { log: p2 }
  ]) => {
    const m2 = $(), w3 = $(), I = y(0);
    let C = null, g2 = null, a2 = null;
    function T() {
      C && (C(), C = null), a2 && (a2(), a2 = null), g2 && (clearTimeout(g2), g2 = null), W(c2, false);
    }
    return F(
      x(
        m2,
        G(n3, S3, o3, I, l2, i3, p2),
        G(t3, s3, r3),
        E(
          ([
            [b2, h2, d2, R, B, O, L, V],
            D,
            J,
            nt
          ]) => {
            const k2 = Nn(b2), { align: q, behavior: st, offset: dt2 } = k2, St = R - 1, ft2 = _n(k2, h2, St);
            let ut = ie(ft2, h2.offsetTree, D) + O;
            q === "end" ? (ut += J + Ct(h2.sizeTree, ft2)[1] - d2 + nt, ft2 === St && (ut += L)) : q === "center" ? ut += (J + Ct(h2.sizeTree, ft2)[1] - d2 + nt) / 2 : ut -= B, dt2 && (ut += dt2);
            const At = (xt) => {
              T(), xt ? (V("retrying to scroll to", { location: b2 }, ht.DEBUG), W(m2, b2)) : (W(w3, true), V("list did not change, scroll successful", {}, ht.DEBUG));
            };
            if (T(), st === "smooth") {
              let xt = false;
              a2 = K(e2, (Xt) => {
                xt = xt || Xt;
              }), C = Rt(f2, () => {
                At(xt);
              });
            } else
              C = Rt(x(e2, Lo(150)), At);
            return g2 = setTimeout(() => {
              T();
            }, 1200), W(c2, true), V("scrolling from index to", { behavior: st, index: ft2, top: ut }, ht.DEBUG), { behavior: st, top: ut };
          }
        )
      ),
      u2
    ), {
      scrollTargetReached: w3,
      scrollToIndex: m2,
      topListHeight: I
    };
  },
  X(Et, at, Vt),
  { singleton: true }
);
function Lo(t3) {
  return (e2) => {
    const n3 = setTimeout(() => {
      e2(false);
    }, t3);
    return (o3) => {
      o3 && (e2(true), clearTimeout(n3));
    };
  };
}
function $e(t3, e2) {
  t3 == 0 ? e2() : requestAnimationFrame(() => {
    $e(t3 - 1, e2);
  });
}
function Ue(t3, e2) {
  const n3 = e2 - 1;
  return typeof t3 == "number" ? t3 : t3.index === "LAST" ? n3 : t3.index;
}
var ue = U(
  ([{ defaultItemSize: t3, listRefresh: e2, sizes: n3 }, { scrollTop: o3 }, { scrollTargetReached: r3, scrollToIndex: s3 }, { didMount: i3 }]) => {
    const l2 = y(true), c2 = y(0), u2 = y(true);
    return F(
      x(
        i3,
        G(c2),
        P(([f2, S3]) => !!S3),
        vt(false)
      ),
      l2
    ), F(
      x(
        i3,
        G(c2),
        P(([f2, S3]) => !!S3),
        vt(false)
      ),
      u2
    ), K(
      x(
        rt(e2, i3),
        G(l2, n3, t3, u2),
        P(([[, f2], S3, { sizeTree: p2 }, m2, w3]) => f2 && (!j(p2) || Me(m2)) && !S3 && !w3),
        G(c2)
      ),
      ([, f2]) => {
        Rt(r3, () => {
          W(u2, true);
        }), $e(4, () => {
          Rt(o3, () => {
            W(l2, true);
          }), W(s3, f2);
        });
      }
    ), {
      initialItemFinalLocationReached: u2,
      initialTopMostItemIndex: c2,
      scrolledToInitialItem: l2
    };
  },
  X(Et, at, ce, Pt),
  { singleton: true }
);
function Dn(t3, e2) {
  return Math.abs(t3 - e2) < 1.01;
}
var le = "up";
var te = "down";
var zo = "none";
var Vo = {
  atBottom: false,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollHeight: 0,
    scrollTop: 0,
    viewportHeight: 0
  }
};
var Po = 0;
var ae = U(([{ footerHeight: t3, headerHeight: e2, scrollBy: n3, scrollContainerState: o3, scrollTop: r3, viewportHeight: s3 }]) => {
  const i3 = y(false), l2 = y(true), c2 = $(), u2 = $(), f2 = y(4), S3 = y(Po), p2 = ct(
    x(
      an(x(A(r3), jt(1), vt(true)), x(A(r3), jt(1), vt(false), un(100))),
      Y()
    ),
    false
  ), m2 = ct(
    x(an(x(n3, vt(true)), x(n3, vt(false), un(200))), Y()),
    false
  );
  F(
    x(
      rt(A(r3), A(S3)),
      E(([a2, T]) => a2 <= T),
      Y()
    ),
    l2
  ), F(x(l2, Lt(50)), u2);
  const w3 = pt(
    x(
      rt(o3, A(s3), A(e2), A(t3), A(f2)),
      bt((a2, [{ scrollHeight: T, scrollTop: b2 }, h2, d2, R, B]) => {
        const O = b2 + h2 - T > -B, L = {
          scrollHeight: T,
          scrollTop: b2,
          viewportHeight: h2
        };
        if (O) {
          let D, J;
          return b2 > a2.state.scrollTop ? (D = "SCROLLED_DOWN", J = a2.state.scrollTop - b2) : (D = "SIZE_DECREASED", J = a2.state.scrollTop - b2 || a2.scrollTopDelta), {
            atBottom: true,
            atBottomBecause: D,
            scrollTopDelta: J,
            state: L
          };
        }
        let V;
        return L.scrollHeight > a2.state.scrollHeight ? V = "SIZE_INCREASED" : h2 < a2.state.viewportHeight ? V = "VIEWPORT_HEIGHT_DECREASING" : b2 < a2.state.scrollTop ? V = "SCROLLING_UPWARDS" : V = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
          atBottom: false,
          notAtBottomBecause: V,
          state: L
        };
      }, Vo),
      Y((a2, T) => a2 && a2.atBottom === T.atBottom)
    )
  ), I = ct(
    x(
      o3,
      bt(
        (a2, { scrollHeight: T, scrollTop: b2, viewportHeight: h2 }) => {
          if (Dn(a2.scrollHeight, T))
            return {
              changed: false,
              jump: 0,
              scrollHeight: T,
              scrollTop: b2
            };
          {
            const d2 = T - (b2 + h2) < 1;
            return a2.scrollTop !== b2 && d2 ? {
              changed: true,
              jump: a2.scrollTop - b2,
              scrollHeight: T,
              scrollTop: b2
            } : {
              changed: true,
              jump: 0,
              scrollHeight: T,
              scrollTop: b2
            };
          }
        },
        { changed: false, jump: 0, scrollHeight: 0, scrollTop: 0 }
      ),
      P((a2) => a2.changed),
      E((a2) => a2.jump)
    ),
    0
  );
  F(
    x(
      w3,
      E((a2) => a2.atBottom)
    ),
    i3
  ), F(x(i3, Lt(50)), c2);
  const C = y(te);
  F(
    x(
      o3,
      E(({ scrollTop: a2 }) => a2),
      Y(),
      bt(
        (a2, T) => lt2(m2) ? { direction: a2.direction, prevScrollTop: T } : { direction: T < a2.prevScrollTop ? le : te, prevScrollTop: T },
        { direction: te, prevScrollTop: 0 }
      ),
      E((a2) => a2.direction)
    ),
    C
  ), F(x(o3, Lt(50), vt(zo)), C);
  const g2 = y(0);
  return F(
    x(
      p2,
      P((a2) => !a2),
      vt(0)
    ),
    g2
  ), F(
    x(
      r3,
      Lt(100),
      G(p2),
      P(([a2, T]) => !!T),
      bt(([a2, T], [b2]) => [T, b2], [0, 0]),
      E(([a2, T]) => T - a2)
    ),
    g2
  ), {
    atBottomState: w3,
    atBottomStateChange: c2,
    atBottomThreshold: f2,
    atTopStateChange: u2,
    atTopThreshold: S3,
    isAtBottom: i3,
    isAtTop: l2,
    isScrolling: p2,
    lastJumpDueToItemResize: I,
    scrollDirection: C,
    scrollVelocity: g2
  };
}, X(at));
var xe = "top";
var Te = "bottom";
var pn = "none";
function hn(t3, e2, n3) {
  return typeof t3 == "number" ? n3 === le && e2 === xe || n3 === te && e2 === Te ? t3 : 0 : n3 === le ? e2 === xe ? t3.main : t3.reverse : e2 === Te ? t3.main : t3.reverse;
}
function gn(t3, e2) {
  var n3;
  return typeof t3 == "number" ? t3 : (n3 = t3[e2]) != null ? n3 : 0;
}
var Ke = U(
  ([{ deviation: t3, fixedHeaderHeight: e2, headerHeight: n3, scrollTop: o3, viewportHeight: r3 }]) => {
    const s3 = $(), i3 = y(0), l2 = y(0), c2 = y(0), u2 = ct(
      x(
        rt(
          A(o3),
          A(r3),
          A(n3),
          A(s3, se),
          A(c2),
          A(i3),
          A(e2),
          A(t3),
          A(l2)
        ),
        E(
          ([
            f2,
            S3,
            p2,
            [m2, w3],
            I,
            C,
            g2,
            a2,
            T
          ]) => {
            const b2 = f2 - a2, h2 = C + g2, d2 = Math.max(p2 - b2, 0);
            let R = pn;
            const B = gn(T, xe), O = gn(T, Te);
            return m2 -= a2, m2 += p2 + g2, w3 += p2 + g2, w3 -= a2, m2 > f2 + h2 - B && (R = le), w3 < f2 - d2 + S3 + O && (R = te), R !== pn ? [
              Math.max(b2 - p2 - hn(I, xe, R) - B, 0),
              b2 - d2 - g2 + S3 + hn(I, Te, R) + O
            ] : null;
          }
        ),
        P((f2) => f2 != null),
        Y(se)
      ),
      [0, 0]
    );
    return {
      increaseViewportBy: l2,
      // input
      listBoundary: s3,
      overscan: c2,
      topListHeight: i3,
      // output
      visibleRange: u2
    };
  },
  X(at),
  { singleton: true }
);
function Ao(t3, e2, n3) {
  if (be(e2)) {
    const o3 = Wn(t3, e2);
    return [
      { index: Ct(e2.groupOffsetTree, o3)[0], offset: 0, size: 0 },
      { data: n3 == null ? void 0 : n3[0], index: o3, offset: 0, size: 0 }
    ];
  }
  return [{ data: n3 == null ? void 0 : n3[0], index: t3, offset: 0, size: 0 }];
}
var ke = {
  bottom: 0,
  firstItemIndex: 0,
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  topItems: [],
  topListHeight: 0,
  totalCount: 0
};
function Ie(t3, e2, n3, o3, r3, s3) {
  const { lastIndex: i3, lastOffset: l2, lastSize: c2 } = r3;
  let u2 = 0, f2 = 0;
  if (t3.length > 0) {
    u2 = t3[0].offset;
    const I = t3[t3.length - 1];
    f2 = I.offset + I.size;
  }
  const S3 = n3 - i3, p2 = l2 + S3 * c2 + (S3 - 1) * o3, m2 = u2, w3 = p2 - f2;
  return {
    bottom: f2,
    firstItemIndex: s3,
    items: In(t3, r3, s3),
    offsetBottom: w3,
    offsetTop: u2,
    top: m2,
    topItems: In(e2, r3, s3),
    topListHeight: e2.reduce((I, C) => C.size + I, 0),
    totalCount: n3
  };
}
function $n(t3, e2, n3, o3, r3, s3) {
  let i3 = 0;
  if (n3.groupIndices.length > 0)
    for (const f2 of n3.groupIndices) {
      if (f2 - i3 >= t3)
        break;
      i3++;
    }
  const l2 = t3 + i3, c2 = Ue(e2, l2), u2 = Array.from({ length: l2 }).map((f2, S3) => ({
    data: s3[S3 + c2],
    index: S3 + c2,
    offset: 0,
    size: 0
  }));
  return Ie(u2, [], l2, r3, n3, o3);
}
function In(t3, e2, n3) {
  if (t3.length === 0)
    return [];
  if (!be(e2))
    return t3.map((u2) => ({ ...u2, index: u2.index + n3, originalIndex: u2.index }));
  const o3 = t3[0].index, r3 = t3[t3.length - 1].index, s3 = [], i3 = ve(e2.groupOffsetTree, o3, r3);
  let l2, c2 = 0;
  for (const u2 of t3) {
    (!l2 || l2.end < u2.index) && (l2 = i3.shift(), c2 = e2.groupIndices.indexOf(l2.start));
    let f2;
    u2.index === l2.start ? f2 = {
      index: c2,
      type: "group"
    } : f2 = {
      groupIndex: c2,
      index: u2.index - (c2 + 1) + n3
    }, s3.push({
      ...f2,
      data: u2.data,
      offset: u2.offset,
      originalIndex: u2.index,
      size: u2.size
    });
  }
  return s3;
}
var Gt = U(
  ([
    { data: t3, firstItemIndex: e2, gap: n3, sizes: o3, totalCount: r3 },
    s3,
    { listBoundary: i3, topListHeight: l2, visibleRange: c2 },
    { initialTopMostItemIndex: u2, scrolledToInitialItem: f2 },
    { topListHeight: S3 },
    p2,
    { didMount: m2 },
    { recalcInProgress: w3 }
  ]) => {
    const I = y([]), C = y(0), g2 = $();
    F(s3.topItemsIndexes, I);
    const a2 = ct(
      x(
        rt(
          m2,
          w3,
          A(c2, se),
          A(r3),
          A(o3),
          A(u2),
          f2,
          A(I),
          A(e2),
          A(n3),
          t3
        ),
        P(([d2, R, , B, , , , , , , O]) => {
          const L = O && O.length !== B;
          return d2 && !R && !L;
        }),
        E(
          ([
            ,
            ,
            [d2, R],
            B,
            O,
            L,
            V,
            D,
            J,
            nt,
            k2
          ]) => {
            const q = O, { offsetTree: st, sizeTree: dt2 } = q, St = lt2(C);
            if (B === 0)
              return { ...ke, totalCount: B };
            if (d2 === 0 && R === 0)
              return St === 0 ? { ...ke, totalCount: B } : $n(St, L, O, J, nt, k2 || []);
            if (j(dt2))
              return St > 0 ? null : Ie(
                Ao(Ue(L, B), q, k2),
                [],
                B,
                nt,
                q,
                J
              );
            const ft2 = [];
            if (D.length > 0) {
              const Mt = D[0], yt = D[D.length - 1];
              let kt = 0;
              for (const v2 of ve(dt2, Mt, yt)) {
                const N2 = v2.value, Q = Math.max(v2.start, Mt), it = Math.min(v2.end, yt);
                for (let tt = Q; tt <= it; tt++)
                  ft2.push({ data: k2 == null ? void 0 : k2[tt], index: tt, offset: kt, size: N2 }), kt += N2;
              }
            }
            if (!V)
              return Ie([], ft2, B, nt, q, J);
            const ut = D.length > 0 ? D[D.length - 1] + 1 : 0, At = bo(st, d2, R, ut);
            if (At.length === 0)
              return null;
            const xt = B - 1, Xt = ye([], (Mt) => {
              for (const yt of At) {
                const kt = yt.value;
                let v2 = kt.offset, N2 = yt.start;
                const Q = kt.size;
                if (kt.offset < d2) {
                  N2 += Math.floor((d2 - kt.offset + nt) / (Q + nt));
                  const tt = N2 - yt.start;
                  v2 += tt * Q + tt * nt;
                }
                N2 < ut && (v2 += (ut - N2) * Q, N2 = ut);
                const it = Math.min(yt.end, xt);
                for (let tt = N2; tt <= it && !(v2 >= R); tt++)
                  Mt.push({ data: k2 == null ? void 0 : k2[tt], index: tt, offset: v2, size: Q }), v2 += Q + nt;
              }
            });
            return Ie(Xt, ft2, B, nt, q, J);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        P((d2) => d2 !== null),
        Y()
      ),
      ke
    );
    F(
      x(
        t3,
        P(Me),
        E((d2) => d2 == null ? void 0 : d2.length)
      ),
      r3
    ), F(
      x(
        a2,
        E((d2) => d2.topListHeight)
      ),
      S3
    ), F(S3, l2), F(
      x(
        a2,
        E((d2) => [d2.top, d2.bottom])
      ),
      i3
    ), F(
      x(
        a2,
        E((d2) => d2.items)
      ),
      g2
    );
    const T = pt(
      x(
        a2,
        P(({ items: d2 }) => d2.length > 0),
        G(r3, t3),
        P(([{ items: d2 }, R]) => d2[d2.length - 1].originalIndex === R - 1),
        E(([, d2, R]) => [d2 - 1, R]),
        Y(se),
        E(([d2]) => d2)
      )
    ), b2 = pt(
      x(
        a2,
        Lt(200),
        P(({ items: d2, topItems: R }) => d2.length > 0 && d2[0].originalIndex === R.length),
        E(({ items: d2 }) => d2[0].index),
        Y()
      )
    ), h2 = pt(
      x(
        a2,
        P(({ items: d2 }) => d2.length > 0),
        E(({ items: d2 }) => {
          let R = 0, B = d2.length - 1;
          for (; d2[R].type === "group" && R < B; )
            R++;
          for (; d2[B].type === "group" && B > R; )
            B--;
          return {
            endIndex: d2[B].index,
            startIndex: d2[R].index
          };
        }),
        Y(An)
      )
    );
    return { endReached: T, initialItemCount: C, itemsRendered: g2, listState: a2, rangeChanged: h2, startReached: b2, topItemsIndexes: I, ...p2 };
  },
  X(
    Et,
    Gn,
    Ke,
    ue,
    ce,
    ae,
    Pt,
    Ne
  ),
  { singleton: true }
);
var Un = U(
  ([{ fixedFooterHeight: t3, fixedHeaderHeight: e2, footerHeight: n3, headerHeight: o3 }, { listState: r3 }]) => {
    const s3 = $(), i3 = ct(
      x(
        rt(n3, t3, o3, e2, r3),
        E(([l2, c2, u2, f2, S3]) => l2 + c2 + u2 + f2 + S3.offsetBottom + S3.bottom)
      ),
      0
    );
    return F(A(i3), s3), { totalListHeight: i3, totalListHeightChanged: s3 };
  },
  X(at, Gt),
  { singleton: true }
);
var Mo = U(
  ([{ viewportHeight: t3 }, { totalListHeight: e2 }]) => {
    const n3 = y(false), o3 = ct(
      x(
        rt(n3, t3, e2),
        P(([r3]) => r3),
        E(([, r3, s3]) => Math.max(0, r3 - s3)),
        Lt(0),
        Y()
      ),
      0
    );
    return { alignToBottom: n3, paddingTopAddition: o3 };
  },
  X(at, Un),
  { singleton: true }
);
function Sn(t3) {
  return t3 ? t3 === "smooth" ? "smooth" : "auto" : false;
}
var Wo = (t3, e2) => typeof t3 == "function" ? Sn(t3(e2)) : e2 && Sn(t3);
var _o = U(
  ([
    { listRefresh: t3, totalCount: e2 },
    { atBottomState: n3, isAtBottom: o3 },
    { scrollToIndex: r3 },
    { scrolledToInitialItem: s3 },
    { didMount: i3, propsReady: l2 },
    { log: c2 },
    { scrollingInProgress: u2 }
  ]) => {
    const f2 = y(false), S3 = $();
    let p2 = null;
    function m2(I) {
      W(r3, {
        align: "end",
        behavior: I,
        index: "LAST"
      });
    }
    K(
      x(
        rt(x(A(e2), jt(1)), i3),
        G(A(f2), o3, s3, u2),
        E(([[I, C], g2, a2, T, b2]) => {
          let h2 = C && T, d2 = "auto";
          return h2 && (d2 = Wo(g2, a2 || b2), h2 = h2 && !!d2), { followOutputBehavior: d2, shouldFollow: h2, totalCount: I };
        }),
        P(({ shouldFollow: I }) => I)
      ),
      ({ followOutputBehavior: I, totalCount: C }) => {
        p2 && (p2(), p2 = null), p2 = Rt(t3, () => {
          lt2(c2)("following output to ", { totalCount: C }, ht.DEBUG), m2(I), p2 = null;
        });
      }
    );
    function w3(I) {
      const C = Rt(n3, (g2) => {
        I && !g2.atBottom && g2.notAtBottomBecause === "SIZE_INCREASED" && !p2 && (lt2(c2)("scrolling to bottom due to increased size", {}, ht.DEBUG), m2("auto"));
      });
      setTimeout(C, 100);
    }
    return K(
      x(
        rt(A(f2), e2, l2),
        P(([I, , C]) => I && C),
        bt(
          ({ value: I }, [, C]) => ({ refreshed: I === C, value: C }),
          { refreshed: false, value: 0 }
        ),
        P(({ refreshed: I }) => I),
        G(f2, e2)
      ),
      ([, I]) => {
        lt2(s3) && w3(I !== false);
      }
    ), K(S3, () => {
      w3(lt2(f2) !== false);
    }), K(rt(A(f2), n3), ([I, C]) => {
      I && !C.atBottom && C.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && m2("auto");
    }), { autoscrollToBottom: S3, followOutput: f2 };
  },
  X(Et, ae, ce, ue, Pt, Vt, at)
);
var Go = U(
  ([{ data: t3, firstItemIndex: e2, gap: n3, sizes: o3 }, { initialTopMostItemIndex: r3 }, { initialItemCount: s3, listState: i3 }, { didMount: l2 }]) => (F(
    x(
      l2,
      G(s3),
      P(([, c2]) => c2 !== 0),
      G(r3, o3, e2, n3, t3),
      E(([[, c2], u2, f2, S3, p2, m2 = []]) => $n(c2, u2, f2, S3, p2, m2))
    ),
    i3
  ), {}),
  X(Et, ue, Gt, Pt),
  { singleton: true }
);
var No = U(
  ([{ didMount: t3 }, { scrollTo: e2 }, { listState: n3 }]) => {
    const o3 = y(0);
    return K(
      x(
        t3,
        G(o3),
        P(([, r3]) => r3 !== 0),
        E(([, r3]) => ({ top: r3 }))
      ),
      (r3) => {
        Rt(
          x(
            n3,
            jt(1),
            P((s3) => s3.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              W(e2, r3);
            });
          }
        );
      }
    ), {
      initialScrollTop: o3
    };
  },
  X(Pt, at, Gt),
  { singleton: true }
);
var Do = ({
  itemBottom: t3,
  itemTop: e2,
  locationParams: { align: n3, behavior: o3, ...r3 },
  viewportBottom: s3,
  viewportTop: i3
}) => e2 < i3 ? { ...r3, align: n3 != null ? n3 : "start", behavior: o3 } : t3 > s3 ? { ...r3, align: n3 != null ? n3 : "end", behavior: o3 } : null;
var $o = U(
  ([
    { gap: t3, sizes: e2, totalCount: n3 },
    { fixedFooterHeight: o3, fixedHeaderHeight: r3, headerHeight: s3, scrollingInProgress: i3, scrollTop: l2, viewportHeight: c2 },
    { scrollToIndex: u2 }
  ]) => {
    const f2 = $();
    return F(
      x(
        f2,
        G(e2, c2, n3, s3, r3, o3, l2),
        G(t3),
        E(([[S3, p2, m2, w3, I, C, g2, a2], T]) => {
          const { align: b2, behavior: h2, calculateViewLocation: d2 = Do, done: R, ...B } = S3, O = _n(S3, p2, w3 - 1), L = ie(O, p2.offsetTree, T) + I + C, V = L + Ct(p2.sizeTree, O)[1], D = a2 + C, J = a2 + m2 - g2, nt = d2({
            itemBottom: V,
            itemTop: L,
            locationParams: { align: b2, behavior: h2, ...B },
            viewportBottom: J,
            viewportTop: D
          });
          return nt ? R && Rt(
            x(
              i3,
              P((k2) => !k2),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              jt(lt2(i3) ? 1 : 2)
            ),
            R
          ) : R && R(), nt;
        }),
        P((S3) => S3 !== null)
      ),
      u2
    ), {
      scrollIntoView: f2
    };
  },
  X(Et, at, ce, Gt, Vt),
  { singleton: true }
);
var Kn = U(
  ([{ scrollVelocity: t3 }]) => {
    const e2 = y(false), n3 = $(), o3 = y(false);
    return F(
      x(
        t3,
        G(o3, e2, n3),
        P(([r3, s3]) => !!s3),
        E(([r3, s3, i3, l2]) => {
          const { enter: c2, exit: u2 } = s3;
          if (i3) {
            if (u2(r3, l2))
              return false;
          } else if (c2(r3, l2))
            return true;
          return i3;
        }),
        Y()
      ),
      e2
    ), K(
      x(rt(e2, t3, n3), G(o3)),
      ([[r3, s3, i3], l2]) => {
        r3 && l2 && l2.change && l2.change(s3, i3);
      }
    ), { isSeeking: e2, scrollSeekConfiguration: o3, scrollSeekRangeChanged: n3, scrollVelocity: t3 };
  },
  X(ae),
  { singleton: true }
);
var je = U(([{ scrollContainerState: t3, scrollTo: e2 }]) => {
  const n3 = $(), o3 = $(), r3 = $(), s3 = y(false), i3 = y(void 0);
  return F(
    x(
      rt(n3, o3),
      E(([{ scrollHeight: l2, scrollTop: c2, viewportHeight: u2 }, { offsetTop: f2 }]) => ({
        scrollHeight: l2,
        scrollTop: Math.max(0, c2 - f2),
        viewportHeight: u2
      }))
    ),
    t3
  ), F(
    x(
      e2,
      G(o3),
      E(([l2, { offsetTop: c2 }]) => ({
        ...l2,
        top: l2.top + c2
      }))
    ),
    r3
  ), {
    customScrollParent: i3,
    // config
    useWindowScroll: s3,
    // input
    windowScrollContainerState: n3,
    // signals
    windowScrollTo: r3,
    windowViewportRect: o3
  };
}, X(at));
var Uo = U(
  ([
    { sizeRanges: t3, sizes: e2 },
    { headerHeight: n3, scrollTop: o3 },
    { initialTopMostItemIndex: r3 },
    { didMount: s3 },
    { useWindowScroll: i3, windowScrollContainerState: l2, windowViewportRect: c2 }
  ]) => {
    const u2 = $(), f2 = y(void 0), S3 = y(null), p2 = y(null);
    return F(l2, S3), F(c2, p2), K(
      x(
        u2,
        G(e2, o3, i3, S3, p2, n3)
      ),
      ([m2, w3, I, C, g2, a2, T]) => {
        const b2 = Ho(w3.sizeTree);
        C && g2 !== null && a2 !== null && (I = g2.scrollTop - a2.offsetTop), I -= T, m2({ ranges: b2, scrollTop: I });
      }
    ), F(x(f2, P(Me), E(Ko)), r3), F(
      x(
        s3,
        G(f2),
        P(([, m2]) => m2 !== void 0),
        Y(),
        E(([, m2]) => m2.ranges)
      ),
      t3
    ), {
      getState: u2,
      restoreStateFrom: f2
    };
  },
  X(Et, at, ue, Pt, je)
);
function Ko(t3) {
  return { align: "start", index: 0, offset: t3.scrollTop };
}
var jo = U(([{ topItemsIndexes: t3 }]) => {
  const e2 = y(0);
  return F(
    x(
      e2,
      P((n3) => n3 >= 0),
      E((n3) => Array.from({ length: n3 }).map((o3, r3) => r3))
    ),
    t3
  ), { topItemCount: e2 };
}, X(Gt));
function jn(t3) {
  let e2 = false, n3;
  return () => (e2 || (e2 = true, n3 = t3()), n3);
}
var qo = jn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent));
var Yo = U(
  ([
    { deviation: t3, scrollBy: e2, scrollingInProgress: n3, scrollTop: o3 },
    { isAtBottom: r3, isScrolling: s3, lastJumpDueToItemResize: i3, scrollDirection: l2 },
    { listState: c2 },
    { beforeUnshiftWith: u2, gap: f2, shiftWithOffset: S3, sizes: p2 },
    { log: m2 },
    { recalcInProgress: w3 }
  ]) => {
    const I = pt(
      x(
        c2,
        G(i3),
        bt(
          ([, g2, a2, T], [{ bottom: b2, items: h2, offsetBottom: d2, totalCount: R }, B]) => {
            const O = b2 + d2;
            let L = 0;
            return a2 === R && g2.length > 0 && h2.length > 0 && (h2[0].originalIndex === 0 && g2[0].originalIndex === 0 || (L = O - T, L !== 0 && (L += B))), [L, h2, R, O];
          },
          [0, [], 0, 0]
        ),
        P(([g2]) => g2 !== 0),
        G(o3, l2, n3, r3, m2, w3),
        P(([, g2, a2, T, , , b2]) => !b2 && !T && g2 !== 0 && a2 === le),
        E(([[g2], , , , , a2]) => (a2("Upward scrolling compensation", { amount: g2 }, ht.DEBUG), g2))
      )
    );
    function C(g2) {
      g2 > 0 ? (W(e2, { behavior: "auto", top: -g2 }), W(t3, 0)) : (W(t3, 0), W(e2, { behavior: "auto", top: -g2 }));
    }
    return K(x(I, G(t3, s3)), ([g2, a2, T]) => {
      T && qo() ? W(t3, a2 - g2) : C(-g2);
    }), K(
      x(
        rt(ct(s3, false), t3, w3),
        P(([g2, a2, T]) => !g2 && !T && a2 !== 0),
        E(([g2, a2]) => a2),
        Lt(1)
      ),
      C
    ), F(
      x(
        S3,
        E((g2) => ({ top: -g2 }))
      ),
      e2
    ), K(
      x(
        u2,
        G(p2, f2),
        E(([g2, { groupIndices: a2, lastSize: T, sizeTree: b2 }, h2]) => {
          function d2(R) {
            return R * (T + h2);
          }
          if (a2.length === 0)
            return d2(g2);
          {
            let R = 0;
            const B = re(b2, 0);
            let O = 0, L = 0;
            for (; O < g2; ) {
              O++, R += B;
              let V = a2.length === L + 1 ? 1 / 0 : a2[L + 1] - a2[L] - 1;
              O + V > g2 && (R -= B, V = g2 - O + 1), O += V, R += d2(V), L++;
            }
            return R;
          }
        })
      ),
      (g2) => {
        W(t3, g2), requestAnimationFrame(() => {
          W(e2, { top: g2 }), requestAnimationFrame(() => {
            W(t3, 0), W(w3, false);
          });
        });
      }
    ), { deviation: t3 };
  },
  X(at, ae, Gt, Et, Vt, Ne)
);
var Zo = U(
  ([
    t3,
    e2,
    n3,
    o3,
    r3,
    s3,
    i3,
    l2,
    c2,
    u2
  ]) => ({
    ...t3,
    ...e2,
    ...n3,
    ...o3,
    ...r3,
    ...s3,
    ...i3,
    ...l2,
    ...c2,
    ...u2
  }),
  X(
    Ke,
    Go,
    Pt,
    Kn,
    Un,
    No,
    Mo,
    je,
    $o,
    Vt
  )
);
var qn = U(
  ([
    {
      data: t3,
      defaultItemSize: e2,
      firstItemIndex: n3,
      fixedItemSize: o3,
      gap: r3,
      groupIndices: s3,
      itemSize: i3,
      sizeRanges: l2,
      sizes: c2,
      statefulTotalCount: u2,
      totalCount: f2,
      trackItemSizes: S3
    },
    { initialItemFinalLocationReached: p2, initialTopMostItemIndex: m2, scrolledToInitialItem: w3 },
    I,
    C,
    g2,
    { listState: a2, topItemsIndexes: T, ...b2 },
    { scrollToIndex: h2 },
    d2,
    { topItemCount: R },
    { groupCounts: B },
    O
  ]) => (F(b2.rangeChanged, O.scrollSeekRangeChanged), F(
    x(
      O.windowViewportRect,
      E((L) => L.visibleHeight)
    ),
    I.viewportHeight
  ), {
    data: t3,
    defaultItemHeight: e2,
    firstItemIndex: n3,
    fixedItemHeight: o3,
    gap: r3,
    groupCounts: B,
    initialItemFinalLocationReached: p2,
    initialTopMostItemIndex: m2,
    scrolledToInitialItem: w3,
    sizeRanges: l2,
    topItemCount: R,
    topItemsIndexes: T,
    // input
    totalCount: f2,
    ...g2,
    groupIndices: s3,
    itemSize: i3,
    listState: a2,
    scrollToIndex: h2,
    // output
    statefulTotalCount: u2,
    trackItemSizes: S3,
    // exported from stateFlagsSystem
    ...b2,
    // the bag of IO from featureGroup1System
    ...O,
    ...I,
    sizes: c2,
    ...C
  }),
  X(
    Et,
    ue,
    at,
    Uo,
    _o,
    Gt,
    ce,
    Yo,
    jo,
    Gn,
    Zo
  )
);
function Xo(t3, e2) {
  const n3 = {}, o3 = {};
  let r3 = 0;
  const s3 = t3.length;
  for (; r3 < s3; )
    o3[t3[r3]] = 1, r3 += 1;
  for (const i3 in e2)
    Object.hasOwn(o3, i3) || (n3[i3] = e2[i3]);
  return n3;
}
var pe = typeof document < "u" ? import_react10.default.useLayoutEffect : import_react10.default.useEffect;
function qe(t3, e2, n3) {
  const o3 = Object.keys(e2.required || {}), r3 = Object.keys(e2.optional || {}), s3 = Object.keys(e2.methods || {}), i3 = Object.keys(e2.events || {}), l2 = import_react10.default.createContext({});
  function c2(g2, a2) {
    g2.propsReady && W(g2.propsReady, false);
    for (const T of o3) {
      const b2 = g2[e2.required[T]];
      W(b2, a2[T]);
    }
    for (const T of r3)
      if (T in a2) {
        const b2 = g2[e2.optional[T]];
        W(b2, a2[T]);
      }
    g2.propsReady && W(g2.propsReady, true);
  }
  function u2(g2) {
    return s3.reduce((a2, T) => (a2[T] = (b2) => {
      const h2 = g2[e2.methods[T]];
      W(h2, b2);
    }, a2), {});
  }
  function f2(g2) {
    return i3.reduce((a2, T) => (a2[T] = mo(g2[e2.events[T]]), a2), {});
  }
  const S3 = import_react10.default.forwardRef((g2, a2) => {
    const { children: T, ...b2 } = g2, [h2] = import_react10.default.useState(() => ye(ho(t3), (B) => {
      c2(B, b2);
    })), [d2] = import_react10.default.useState(cn(f2, h2));
    pe(() => {
      for (const B of i3)
        B in b2 && K(d2[B], b2[B]);
      return () => {
        Object.values(d2).map(We);
      };
    }, [b2, d2, h2]), pe(() => {
      c2(h2, b2);
    }), import_react10.default.useImperativeHandle(a2, ln(u2(h2)));
    const R = n3;
    return (0, import_jsx_runtime.jsx)(l2.Provider, { value: h2, children: n3 ? (0, import_jsx_runtime.jsx)(R, { ...Xo([...o3, ...r3, ...i3], b2), children: T }) : T });
  }), p2 = (g2) => import_react10.default.useCallback(kn(W, import_react10.default.useContext(l2)[g2]), [g2]), m2 = (g2) => {
    const T = import_react10.default.useContext(l2)[g2], b2 = import_react10.default.useCallback(
      (h2) => K(T, h2),
      [T]
    );
    return import_react10.default.useSyncExternalStore(
      b2,
      () => lt2(T),
      () => lt2(T)
    );
  }, w3 = (g2) => {
    const T = import_react10.default.useContext(l2)[g2], [b2, h2] = import_react10.default.useState(cn(lt2, T));
    return pe(
      () => K(T, (d2) => {
        d2 !== b2 && h2(ln(d2));
      }),
      [T, b2]
    ), b2;
  }, I = import_react10.default.version.startsWith("18") ? m2 : w3;
  return {
    Component: S3,
    useEmitter: (g2, a2) => {
      const b2 = import_react10.default.useContext(l2)[g2];
      pe(() => K(b2, a2), [a2, b2]);
    },
    useEmitterValue: I,
    usePublisher: p2
  };
}
var Re = import_react10.default.createContext(void 0);
var Yn = import_react10.default.createContext(void 0);
var Zn = typeof document < "u" ? import_react10.default.useLayoutEffect : import_react10.default.useEffect;
function Be(t3) {
  return "self" in t3;
}
function Jo(t3) {
  return "body" in t3;
}
function Xn(t3, e2, n3, o3 = Yt, r3, s3) {
  const i3 = import_react10.default.useRef(null), l2 = import_react10.default.useRef(null), c2 = import_react10.default.useRef(null), u2 = import_react10.default.useCallback(
    (p2) => {
      let m2, w3, I;
      const C = p2.target;
      if (Jo(C) || Be(C)) {
        const a2 = Be(C) ? C : C.defaultView;
        I = s3 ? a2.scrollX : a2.scrollY, m2 = s3 ? a2.document.documentElement.scrollWidth : a2.document.documentElement.scrollHeight, w3 = s3 ? a2.innerWidth : a2.innerHeight;
      } else
        I = s3 ? C.scrollLeft : C.scrollTop, m2 = s3 ? C.scrollWidth : C.scrollHeight, w3 = s3 ? C.offsetWidth : C.offsetHeight;
      const g2 = () => {
        t3({
          scrollHeight: m2,
          scrollTop: Math.max(I, 0),
          viewportHeight: w3
        });
      };
      p2.suppressFlushSync ? g2() : import_react_dom3.default.flushSync(g2), l2.current !== null && (I === l2.current || I <= 0 || I === m2 - w3) && (l2.current = null, e2(true), c2.current && (clearTimeout(c2.current), c2.current = null));
    },
    [t3, e2]
  );
  import_react10.default.useEffect(() => {
    const p2 = r3 || i3.current;
    return o3(r3 || i3.current), u2({ suppressFlushSync: true, target: p2 }), p2.addEventListener("scroll", u2, { passive: true }), () => {
      o3(null), p2.removeEventListener("scroll", u2);
    };
  }, [i3, u2, n3, o3, r3]);
  function f2(p2) {
    const m2 = i3.current;
    if (!m2 || (s3 ? "offsetWidth" in m2 && m2.offsetWidth === 0 : "offsetHeight" in m2 && m2.offsetHeight === 0))
      return;
    const w3 = p2.behavior === "smooth";
    let I, C, g2;
    Be(m2) ? (C = Math.max(
      wt(m2.document.documentElement, s3 ? "width" : "height"),
      s3 ? m2.document.documentElement.scrollWidth : m2.document.documentElement.scrollHeight
    ), I = s3 ? m2.innerWidth : m2.innerHeight, g2 = s3 ? window.scrollX : window.scrollY) : (C = m2[s3 ? "scrollWidth" : "scrollHeight"], I = wt(m2, s3 ? "width" : "height"), g2 = m2[s3 ? "scrollLeft" : "scrollTop"]);
    const a2 = C - I;
    if (p2.top = Math.ceil(Math.max(Math.min(a2, p2.top), 0)), Dn(I, C) || p2.top === g2) {
      t3({ scrollHeight: C, scrollTop: g2, viewportHeight: I }), w3 && e2(true);
      return;
    }
    w3 ? (l2.current = p2.top, c2.current && clearTimeout(c2.current), c2.current = setTimeout(() => {
      c2.current = null, l2.current = null, e2(true);
    }, 1e3)) : l2.current = null, s3 && (p2 = { behavior: p2.behavior, left: p2.top }), m2.scrollTo(p2);
  }
  function S3(p2) {
    s3 && (p2 = { behavior: p2.behavior, left: p2.top }), i3.current.scrollBy(p2);
  }
  return { scrollByCallback: S3, scrollerRef: i3, scrollToCallback: f2 };
}
var Oe = "-webkit-sticky";
var xn = "sticky";
var Jn = jn(() => {
  if (typeof document > "u")
    return xn;
  const t3 = document.createElement("div");
  return t3.style.position = Oe, t3.style.position === Oe ? Oe : xn;
});
function Ye(t3) {
  return t3;
}
var Qo = U(() => {
  const t3 = y((c2) => `Item ${c2}`), e2 = y(null), n3 = y((c2) => `Group ${c2}`), o3 = y({}), r3 = y(Ye), s3 = y("div"), i3 = y(Yt), l2 = (c2, u2 = null) => ct(
    x(
      o3,
      E((f2) => f2[c2]),
      Y()
    ),
    u2
  );
  return {
    components: o3,
    computeItemKey: r3,
    context: e2,
    EmptyPlaceholder: l2("EmptyPlaceholder"),
    FooterComponent: l2("Footer"),
    GroupComponent: l2("Group", "div"),
    groupContent: n3,
    HeaderComponent: l2("Header"),
    HeaderFooterTag: s3,
    ItemComponent: l2("Item", "div"),
    itemContent: t3,
    ListComponent: l2("List", "div"),
    ScrollerComponent: l2("Scroller", "div"),
    scrollerRef: i3,
    ScrollSeekPlaceholder: l2("ScrollSeekPlaceholder"),
    TopItemListComponent: l2("TopItemList")
  };
});
var tr = U(
  ([t3, e2]) => ({ ...t3, ...e2 }),
  X(qn, Qo)
);
var er = ({ height: t3 }) => (0, import_jsx_runtime.jsx)("div", { style: { height: t3 } });
var nr = { overflowAnchor: "none", position: Jn(), zIndex: 1 };
var Qn = { overflowAnchor: "none" };
var or = { ...Qn, display: "inline-block", height: "100%" };
var Tn = import_react10.default.memo(function({ showTopList: e2 = false }) {
  const n3 = M("listState"), o3 = gt("sizeRanges"), r3 = M("useWindowScroll"), s3 = M("customScrollParent"), i3 = gt("windowScrollContainerState"), l2 = gt("scrollContainerState"), c2 = s3 || r3 ? i3 : l2, u2 = M("itemContent"), f2 = M("context"), S3 = M("groupContent"), p2 = M("trackItemSizes"), m2 = M("itemSize"), w3 = M("log"), I = gt("gap"), C = M("horizontalDirection"), { callbackRef: g2 } = On(
    o3,
    m2,
    p2,
    e2 ? Yt : c2,
    w3,
    I,
    s3,
    C,
    M("skipAnimationFrameInResizeObserver")
  ), [a2, T] = import_react10.default.useState(0);
  Je("deviation", (k2) => {
    a2 !== k2 && T(k2);
  });
  const b2 = M("EmptyPlaceholder"), h2 = M("ScrollSeekPlaceholder") || er, d2 = M("ListComponent"), R = M("ItemComponent"), B = M("GroupComponent"), O = M("computeItemKey"), L = M("isSeeking"), V = M("groupIndices").length > 0, D = M("alignToBottom"), J = M("initialItemFinalLocationReached"), nt = e2 ? {} : {
    boxSizing: "border-box",
    ...C ? {
      display: "inline-block",
      height: "100%",
      marginLeft: a2 !== 0 ? a2 : D ? "auto" : 0,
      paddingLeft: n3.offsetTop,
      paddingRight: n3.offsetBottom,
      whiteSpace: "nowrap"
    } : {
      marginTop: a2 !== 0 ? a2 : D ? "auto" : 0,
      paddingBottom: n3.offsetBottom,
      paddingTop: n3.offsetTop
    },
    ...J ? {} : { visibility: "hidden" }
  };
  return !e2 && n3.totalCount === 0 && b2 ? (0, import_jsx_runtime.jsx)(b2, { ...Z(b2, f2) }) : (0, import_jsx_runtime.jsx)(
    d2,
    {
      ...Z(d2, f2),
      "data-testid": e2 ? "virtuoso-top-item-list" : "virtuoso-item-list",
      ref: g2,
      style: nt,
      children: (e2 ? n3.topItems : n3.items).map((k2) => {
        const q = k2.originalIndex, st = O(q + n3.firstItemIndex, k2.data, f2);
        return L ? (0, import_react10.createElement)(
          h2,
          {
            ...Z(h2, f2),
            height: k2.size,
            index: k2.index,
            key: st,
            type: k2.type || "item",
            ...k2.type === "group" ? {} : { groupIndex: k2.groupIndex }
          }
        ) : k2.type === "group" ? (0, import_react10.createElement)(
          B,
          {
            ...Z(B, f2),
            "data-index": q,
            "data-item-index": k2.index,
            "data-known-size": k2.size,
            key: st,
            style: nr
          },
          S3(k2.index, f2)
        ) : (0, import_react10.createElement)(
          R,
          {
            ...Z(R, f2),
            ...to(R, k2.data),
            "data-index": q,
            "data-item-group-index": k2.groupIndex,
            "data-item-index": k2.index,
            "data-known-size": k2.size,
            key: st,
            style: C ? or : Qn
          },
          V ? u2(k2.index, k2.groupIndex, k2.data, f2) : u2(k2.index, k2.data, f2)
        );
      })
    }
  );
});
var rr = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
};
var sr = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
};
var Zt = (t3) => ({
  height: "100%",
  position: "absolute",
  top: 0,
  width: "100%",
  ...t3 ? { display: "flex", flexDirection: "column" } : {}
});
var ir = {
  position: Jn(),
  top: 0,
  width: "100%",
  zIndex: 1
};
function Z(t3, e2) {
  if (typeof t3 != "string")
    return { context: e2 };
}
function to(t3, e2) {
  return { item: typeof t3 == "string" ? void 0 : e2 };
}
var lr = import_react10.default.memo(function() {
  const e2 = M("HeaderComponent"), n3 = gt("headerHeight"), o3 = M("HeaderFooterTag"), r3 = Ht(
    import_react10.default.useMemo(
      () => (i3) => {
        n3(wt(i3, "height"));
      },
      [n3]
    ),
    true,
    M("skipAnimationFrameInResizeObserver")
  ), s3 = M("context");
  return e2 ? (0, import_jsx_runtime.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime.jsx)(e2, { ...Z(e2, s3) }) }) : null;
});
var cr = import_react10.default.memo(function() {
  const e2 = M("FooterComponent"), n3 = gt("footerHeight"), o3 = M("HeaderFooterTag"), r3 = Ht(
    import_react10.default.useMemo(
      () => (i3) => {
        n3(wt(i3, "height"));
      },
      [n3]
    ),
    true,
    M("skipAnimationFrameInResizeObserver")
  ), s3 = M("context");
  return e2 ? (0, import_jsx_runtime.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime.jsx)(e2, { ...Z(e2, s3) }) }) : null;
});
function Ze({ useEmitter: t3, useEmitterValue: e2, usePublisher: n3 }) {
  return import_react10.default.memo(function({ children: s3, style: i3, ...l2 }) {
    const c2 = n3("scrollContainerState"), u2 = e2("ScrollerComponent"), f2 = n3("smoothScrollTargetReached"), S3 = e2("scrollerRef"), p2 = e2("context"), m2 = e2("horizontalDirection") || false, { scrollByCallback: w3, scrollerRef: I, scrollToCallback: C } = Xn(
      c2,
      f2,
      u2,
      S3,
      void 0,
      m2
    );
    return t3("scrollTo", C), t3("scrollBy", w3), (0, import_jsx_runtime.jsx)(
      u2,
      {
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": true,
        ref: I,
        style: { ...m2 ? sr : rr, ...i3 },
        tabIndex: 0,
        ...l2,
        ...Z(u2, p2),
        children: s3
      }
    );
  });
}
function Xe({ useEmitter: t3, useEmitterValue: e2, usePublisher: n3 }) {
  return import_react10.default.memo(function({ children: s3, style: i3, ...l2 }) {
    const c2 = n3("windowScrollContainerState"), u2 = e2("ScrollerComponent"), f2 = n3("smoothScrollTargetReached"), S3 = e2("totalListHeight"), p2 = e2("deviation"), m2 = e2("customScrollParent"), w3 = e2("context"), I = import_react10.default.useRef(null), C = e2("scrollerRef"), { scrollByCallback: g2, scrollerRef: a2, scrollToCallback: T } = Xn(
      c2,
      f2,
      u2,
      C,
      m2
    );
    return Zn(() => {
      var b2;
      return a2.current = m2 || ((b2 = I.current) == null ? void 0 : b2.ownerDocument.defaultView), () => {
        a2.current = null;
      };
    }, [a2, m2]), t3("windowScrollTo", T), t3("scrollBy", g2), (0, import_jsx_runtime.jsx)(
      u2,
      {
        ref: I,
        "data-virtuoso-scroller": true,
        style: { position: "relative", ...i3, ...S3 !== 0 ? { height: S3 + p2 } : {} },
        ...l2,
        ...Z(u2, w3),
        children: s3
      }
    );
  });
}
var ur = ({ children: t3 }) => {
  const e2 = import_react10.default.useContext(Re), n3 = gt("viewportHeight"), o3 = gt("fixedItemHeight"), r3 = M("alignToBottom"), s3 = M("horizontalDirection"), i3 = import_react10.default.useMemo(
    () => ne(n3, (c2) => wt(c2, s3 ? "width" : "height")),
    [n3, s3]
  ), l2 = Ht(i3, true, M("skipAnimationFrameInResizeObserver"));
  return import_react10.default.useEffect(() => {
    e2 && (n3(e2.viewportHeight), o3(e2.itemHeight));
  }, [e2, n3, o3]), (0, import_jsx_runtime.jsx)("div", { "data-viewport-type": "element", ref: l2, style: Zt(r3), children: t3 });
};
var ar = ({ children: t3 }) => {
  const e2 = import_react10.default.useContext(Re), n3 = gt("windowViewportRect"), o3 = gt("fixedItemHeight"), r3 = M("customScrollParent"), s3 = Ge(
    n3,
    r3,
    M("skipAnimationFrameInResizeObserver")
  ), i3 = M("alignToBottom");
  return import_react10.default.useEffect(() => {
    e2 && (o3(e2.itemHeight), n3({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: 100 }));
  }, [e2, n3, o3]), (0, import_jsx_runtime.jsx)("div", { "data-viewport-type": "window", ref: s3, style: Zt(i3), children: t3 });
};
var dr = ({ children: t3 }) => {
  const e2 = M("TopItemListComponent") || "div", n3 = M("headerHeight"), o3 = { ...ir, marginTop: `${n3}px` }, r3 = M("context");
  return (0, import_jsx_runtime.jsx)(e2, { style: o3, ...Z(e2, r3), children: t3 });
};
var fr = import_react10.default.memo(function(e2) {
  const n3 = M("useWindowScroll"), o3 = M("topItemsIndexes").length > 0, r3 = M("customScrollParent"), s3 = M("context"), i3 = r3 || n3 ? pr : mr, l2 = r3 || n3 ? ar : ur;
  return (0, import_jsx_runtime.jsxs)(i3, { ...e2, ...Z(i3, s3), children: [
    o3 && (0, import_jsx_runtime.jsx)(dr, { children: (0, import_jsx_runtime.jsx)(Tn, { showTopList: true }) }),
    (0, import_jsx_runtime.jsxs)(l2, { children: [
      (0, import_jsx_runtime.jsx)(lr, {}),
      (0, import_jsx_runtime.jsx)(Tn, {}),
      (0, import_jsx_runtime.jsx)(cr, {})
    ] })
  ] });
});
var {
  Component: eo,
  useEmitter: Je,
  useEmitterValue: M,
  usePublisher: gt
} = qe(
  tr,
  {
    events: {
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      endReached: "endReached",
      groupIndices: "groupIndices",
      isScrolling: "isScrolling",
      itemsRendered: "itemsRendered",
      rangeChanged: "rangeChanged",
      startReached: "startReached",
      totalListHeightChanged: "totalListHeightChanged"
    },
    methods: {
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState",
      scrollBy: "scrollBy",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollToIndex: "scrollToIndex"
    },
    optional: {
      alignToBottom: "alignToBottom",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      components: "components",
      computeItemKey: "computeItemKey",
      context: "context",
      customScrollParent: "customScrollParent",
      data: "data",
      defaultItemHeight: "defaultItemHeight",
      firstItemIndex: "firstItemIndex",
      fixedItemHeight: "fixedItemHeight",
      followOutput: "followOutput",
      groupContent: "groupContent",
      groupCounts: "groupCounts",
      headerFooterTag: "HeaderFooterTag",
      horizontalDirection: "horizontalDirection",
      increaseViewportBy: "increaseViewportBy",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      itemContent: "itemContent",
      itemSize: "itemSize",
      logLevel: "logLevel",
      overscan: "overscan",
      restoreStateFrom: "restoreStateFrom",
      scrollerRef: "scrollerRef",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver",
      topItemCount: "topItemCount",
      totalCount: "totalCount",
      useWindowScroll: "useWindowScroll"
    },
    required: {}
  },
  fr
);
var mr = Ze({ useEmitter: Je, useEmitterValue: M, usePublisher: gt });
var pr = Xe({ useEmitter: Je, useEmitterValue: M, usePublisher: gt });
var Kr = eo;
var jr = eo;
var hr = U(() => {
  const t3 = y((c2) => (0, import_jsx_runtime.jsxs)("td", { children: [
    "Item $",
    c2
  ] })), e2 = y(null), n3 = y(null), o3 = y(null), r3 = y({}), s3 = y(Ye), i3 = y(Yt), l2 = (c2, u2 = null) => ct(
    x(
      r3,
      E((f2) => f2[c2]),
      Y()
    ),
    u2
  );
  return {
    components: r3,
    computeItemKey: s3,
    context: e2,
    EmptyPlaceholder: l2("EmptyPlaceholder"),
    FillerRow: l2("FillerRow"),
    fixedFooterContent: o3,
    fixedHeaderContent: n3,
    itemContent: t3,
    ScrollerComponent: l2("Scroller", "div"),
    scrollerRef: i3,
    ScrollSeekPlaceholder: l2("ScrollSeekPlaceholder"),
    TableBodyComponent: l2("TableBody", "tbody"),
    TableComponent: l2("Table", "table"),
    TableFooterComponent: l2("TableFoot", "tfoot"),
    TableHeadComponent: l2("TableHead", "thead"),
    TableRowComponent: l2("TableRow", "tr")
  };
});
var gr = U(
  ([t3, e2]) => ({ ...t3, ...e2 }),
  X(qn, hr)
);
var Ir = ({ height: t3 }) => (0, import_jsx_runtime.jsx)("tr", { children: (0, import_jsx_runtime.jsx)("td", { style: { height: t3 } }) });
var Sr = ({ height: t3 }) => (0, import_jsx_runtime.jsx)("tr", { children: (0, import_jsx_runtime.jsx)("td", { style: { border: 0, height: t3, padding: 0 } }) });
var xr = { overflowAnchor: "none" };
var Cn = import_react10.default.memo(function({ showTopList: e2 = false }) {
  const n3 = _("listState"), o3 = _("computeItemKey"), r3 = _("firstItemIndex"), s3 = _("isSeeking"), i3 = _("ScrollSeekPlaceholder") || Ir, l2 = _("context"), c2 = _("TableRowComponent"), u2 = _("fixedHeaderHeight"), f2 = _("itemContent"), S3 = (e2 ? n3.topItems : []).reduce((m2, w3, I) => (I === 0 ? m2.push(w3.size) : m2.push(m2[I - 1] + w3.size), m2), []), p2 = (e2 ? n3.topItems : n3.items).map((m2) => {
    const w3 = m2.originalIndex, I = o3(w3 + r3, m2.data, l2), C = e2 ? w3 === 0 ? 0 : S3[w3 - 1] : 0;
    return s3 ? (0, import_react10.createElement)(
      i3,
      {
        ...Z(i3, l2),
        height: m2.size,
        index: m2.index,
        key: I,
        type: m2.type || "item"
      }
    ) : (0, import_react10.createElement)(
      c2,
      {
        ...Z(c2, l2),
        ...to(c2, m2.data),
        "data-index": w3,
        "data-item-index": m2.index,
        "data-known-size": m2.size,
        key: I,
        style: e2 ? { overflowAnchor: "none", position: "sticky", top: u2 + C, zIndex: 2 } : xr
      },
      f2(m2.index, m2.data, l2)
    );
  });
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: p2 });
});
var Tr = import_react10.default.memo(function() {
  const e2 = _("listState"), n3 = _("topItemsIndexes").length > 0, o3 = Tt("sizeRanges"), r3 = _("useWindowScroll"), s3 = _("customScrollParent"), i3 = Tt("windowScrollContainerState"), l2 = Tt("scrollContainerState"), c2 = s3 || r3 ? i3 : l2, u2 = _("trackItemSizes"), f2 = _("itemSize"), S3 = _("log"), { callbackRef: p2, ref: m2 } = On(
    o3,
    f2,
    u2,
    c2,
    S3,
    void 0,
    s3,
    false,
    _("skipAnimationFrameInResizeObserver")
  ), [w3, I] = import_react10.default.useState(0);
  Qe("deviation", (V) => {
    w3 !== V && (m2.current.style.marginTop = `${V}px`, I(V));
  });
  const C = _("EmptyPlaceholder"), g2 = _("FillerRow") || Sr, a2 = _("TableBodyComponent"), T = _("paddingTopAddition"), b2 = _("statefulTotalCount"), h2 = _("context");
  if (b2 === 0 && C)
    return (0, import_jsx_runtime.jsx)(C, { ...Z(C, h2) });
  const d2 = (n3 ? e2.topItems : []).reduce((V, D) => V + D.size, 0), R = e2.offsetTop + T + w3 - d2, B = e2.offsetBottom, O = R > 0 ? (0, import_jsx_runtime.jsx)(g2, { context: h2, height: R }, "padding-top") : null, L = B > 0 ? (0, import_jsx_runtime.jsx)(g2, { context: h2, height: B }, "padding-bottom") : null;
  return (0, import_jsx_runtime.jsxs)(a2, { "data-testid": "virtuoso-item-list", ref: p2, ...Z(a2, h2), children: [
    O,
    n3 && (0, import_jsx_runtime.jsx)(Cn, { showTopList: true }),
    (0, import_jsx_runtime.jsx)(Cn, {}),
    L
  ] });
});
var Cr = ({ children: t3 }) => {
  const e2 = import_react10.default.useContext(Re), n3 = Tt("viewportHeight"), o3 = Tt("fixedItemHeight"), r3 = Ht(
    import_react10.default.useMemo(() => ne(n3, (s3) => wt(s3, "height")), [n3]),
    true,
    _("skipAnimationFrameInResizeObserver")
  );
  return import_react10.default.useEffect(() => {
    e2 && (n3(e2.viewportHeight), o3(e2.itemHeight));
  }, [e2, n3, o3]), (0, import_jsx_runtime.jsx)("div", { "data-viewport-type": "element", ref: r3, style: Zt(false), children: t3 });
};
var wr = ({ children: t3 }) => {
  const e2 = import_react10.default.useContext(Re), n3 = Tt("windowViewportRect"), o3 = Tt("fixedItemHeight"), r3 = _("customScrollParent"), s3 = Ge(
    n3,
    r3,
    _("skipAnimationFrameInResizeObserver")
  );
  return import_react10.default.useEffect(() => {
    e2 && (o3(e2.itemHeight), n3({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: 100 }));
  }, [e2, n3, o3]), (0, import_jsx_runtime.jsx)("div", { "data-viewport-type": "window", ref: s3, style: Zt(false), children: t3 });
};
var yr = import_react10.default.memo(function(e2) {
  const n3 = _("useWindowScroll"), o3 = _("customScrollParent"), r3 = Tt("fixedHeaderHeight"), s3 = Tt("fixedFooterHeight"), i3 = _("fixedHeaderContent"), l2 = _("fixedFooterContent"), c2 = _("context"), u2 = Ht(
    import_react10.default.useMemo(() => ne(r3, (a2) => wt(a2, "height")), [r3]),
    true,
    _("skipAnimationFrameInResizeObserver")
  ), f2 = Ht(
    import_react10.default.useMemo(() => ne(s3, (a2) => wt(a2, "height")), [s3]),
    true,
    _("skipAnimationFrameInResizeObserver")
  ), S3 = o3 || n3 ? Rr : br, p2 = o3 || n3 ? wr : Cr, m2 = _("TableComponent"), w3 = _("TableHeadComponent"), I = _("TableFooterComponent"), C = i3 ? (0, import_jsx_runtime.jsx)(
    w3,
    {
      ref: u2,
      style: { position: "sticky", top: 0, zIndex: 2 },
      ...Z(w3, c2),
      children: i3()
    },
    "TableHead"
  ) : null, g2 = l2 ? (0, import_jsx_runtime.jsx)(
    I,
    {
      ref: f2,
      style: { bottom: 0, position: "sticky", zIndex: 1 },
      ...Z(I, c2),
      children: l2()
    },
    "TableFoot"
  ) : null;
  return (0, import_jsx_runtime.jsx)(S3, { ...e2, ...Z(S3, c2), children: (0, import_jsx_runtime.jsx)(p2, { children: (0, import_jsx_runtime.jsxs)(m2, { style: { borderSpacing: 0, overflowAnchor: "none" }, ...Z(m2, c2), children: [
    C,
    (0, import_jsx_runtime.jsx)(Tr, {}, "TableBody"),
    g2
  ] }) }) });
});
var {
  Component: vr,
  useEmitter: Qe,
  useEmitterValue: _,
  usePublisher: Tt
} = qe(
  gr,
  {
    events: {
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      endReached: "endReached",
      groupIndices: "groupIndices",
      isScrolling: "isScrolling",
      itemsRendered: "itemsRendered",
      rangeChanged: "rangeChanged",
      startReached: "startReached",
      totalListHeightChanged: "totalListHeightChanged"
    },
    methods: {
      getState: "getState",
      scrollBy: "scrollBy",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollToIndex: "scrollToIndex"
    },
    optional: {
      alignToBottom: "alignToBottom",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      components: "components",
      computeItemKey: "computeItemKey",
      context: "context",
      customScrollParent: "customScrollParent",
      data: "data",
      defaultItemHeight: "defaultItemHeight",
      firstItemIndex: "firstItemIndex",
      fixedFooterContent: "fixedFooterContent",
      fixedHeaderContent: "fixedHeaderContent",
      fixedItemHeight: "fixedItemHeight",
      followOutput: "followOutput",
      groupCounts: "groupCounts",
      increaseViewportBy: "increaseViewportBy",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      itemContent: "itemContent",
      itemSize: "itemSize",
      logLevel: "logLevel",
      overscan: "overscan",
      restoreStateFrom: "restoreStateFrom",
      scrollerRef: "scrollerRef",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      topItemCount: "topItemCount",
      totalCount: "totalCount",
      useWindowScroll: "useWindowScroll"
    },
    required: {}
  },
  yr
);
var br = Ze({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt });
var Rr = Xe({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt });
var wn = {
  bottom: 0,
  itemHeight: 0,
  items: [],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
};
var Hr = {
  bottom: 0,
  itemHeight: 0,
  items: [{ index: 0 }],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
};
var { ceil: yn, floor: Ce, max: ee, min: Fe, round: vn } = Math;
function bn(t3, e2, n3) {
  return Array.from({ length: e2 - t3 + 1 }).map((o3, r3) => ({ data: n3 === null ? null : n3[r3 + t3], index: r3 + t3 }));
}
function Er(t3) {
  return {
    ...Hr,
    items: t3
  };
}
function he(t3, e2) {
  return t3 && t3.width === e2.width && t3.height === e2.height;
}
function kr(t3, e2) {
  return t3 && t3.column === e2.column && t3.row === e2.row;
}
var Br = U(
  ([
    { increaseViewportBy: t3, listBoundary: e2, overscan: n3, visibleRange: o3 },
    { footerHeight: r3, headerHeight: s3, scrollBy: i3, scrollContainerState: l2, scrollTo: c2, scrollTop: u2, smoothScrollTargetReached: f2, viewportHeight: S3 },
    p2,
    m2,
    { didMount: w3, propsReady: I },
    { customScrollParent: C, useWindowScroll: g2, windowScrollContainerState: a2, windowScrollTo: T, windowViewportRect: b2 },
    h2
  ]) => {
    const d2 = y(0), R = y(0), B = y(wn), O = y({ height: 0, width: 0 }), L = y({ height: 0, width: 0 }), V = $(), D = $(), J = y(0), nt = y(null), k2 = y({ column: 0, row: 0 }), q = $(), st = $(), dt2 = y(false), St = y(0), ft2 = y(true), ut = y(false), At = y(false);
    K(
      x(
        w3,
        G(St),
        P(([v2, N2]) => !!N2)
      ),
      () => {
        W(ft2, false);
      }
    ), K(
      x(
        rt(w3, ft2, L, O, St, ut),
        P(([v2, N2, Q, it, , tt]) => v2 && !N2 && Q.height !== 0 && it.height !== 0 && !tt)
      ),
      ([, , , , v2]) => {
        W(ut, true), $e(1, () => {
          W(V, v2);
        }), Rt(x(u2), () => {
          W(e2, [0, 0]), W(ft2, true);
        });
      }
    ), F(
      x(
        st,
        P((v2) => v2 != null && v2.scrollTop > 0),
        vt(0)
      ),
      R
    ), K(
      x(
        w3,
        G(st),
        P(([, v2]) => v2 != null)
      ),
      ([, v2]) => {
        v2 && (W(O, v2.viewport), W(L, v2.item), W(k2, v2.gap), v2.scrollTop > 0 && (W(dt2, true), Rt(x(u2, jt(1)), (N2) => {
          W(dt2, false);
        }), W(c2, { top: v2.scrollTop })));
      }
    ), F(
      x(
        O,
        E(({ height: v2 }) => v2)
      ),
      S3
    ), F(
      x(
        rt(
          A(O, he),
          A(L, he),
          A(k2, (v2, N2) => v2 && v2.column === N2.column && v2.row === N2.row),
          A(u2)
        ),
        E(([v2, N2, Q, it]) => ({
          gap: Q,
          item: N2,
          scrollTop: it,
          viewport: v2
        }))
      ),
      q
    ), F(
      x(
        rt(
          A(d2),
          o3,
          A(k2, kr),
          A(L, he),
          A(O, he),
          A(nt),
          A(R),
          A(dt2),
          A(ft2),
          A(St)
        ),
        P(([, , , , , , , v2]) => !v2),
        E(
          ([
            v2,
            [N2, Q],
            it,
            tt,
            Bt,
            Jt,
            Nt,
            ,
            de,
            Ot
          ]) => {
            const { column: Ft, row: Qt } = it, { height: fe, width: He } = tt, { width: tn } = Bt;
            if (Nt === 0 && (v2 === 0 || tn === 0))
              return wn;
            if (He === 0) {
              const sn = Ue(Ot, v2), so = sn + Math.max(Nt - 1, 0);
              return Er(bn(sn, so, Jt));
            }
            const me = no(tn, He, Ft);
            let Dt, Wt;
            de ? N2 === 0 && Q === 0 && Nt > 0 ? (Dt = 0, Wt = Nt - 1) : (Dt = me * Ce((N2 + Qt) / (fe + Qt)), Wt = me * yn((Q + Qt) / (fe + Qt)) - 1, Wt = Fe(v2 - 1, ee(Wt, me - 1)), Dt = Fe(Wt, ee(0, Dt))) : (Dt = 0, Wt = -1);
            const en = bn(Dt, Wt, Jt), { bottom: nn, top: on } = Rn(Bt, it, tt, en), rn = yn(v2 / me), ro = rn * fe + (rn - 1) * Qt - nn;
            return { bottom: nn, itemHeight: fe, items: en, itemWidth: He, offsetBottom: ro, offsetTop: on, top: on };
          }
        )
      ),
      B
    ), F(
      x(
        nt,
        P((v2) => v2 !== null),
        E((v2) => v2.length)
      ),
      d2
    ), F(
      x(
        rt(O, L, B, k2),
        P(([v2, N2, { items: Q }]) => Q.length > 0 && N2.height !== 0 && v2.height !== 0),
        E(([v2, N2, { items: Q }, it]) => {
          const { bottom: tt, top: Bt } = Rn(v2, it, N2, Q);
          return [Bt, tt];
        }),
        Y(se)
      ),
      e2
    );
    const xt = y(false);
    F(
      x(
        u2,
        G(xt),
        E(([v2, N2]) => N2 || v2 !== 0)
      ),
      xt
    );
    const Xt = pt(
      x(
        rt(B, d2),
        P(([{ items: v2 }]) => v2.length > 0),
        G(xt),
        P(([[v2, N2], Q]) => {
          const tt = v2.items[v2.items.length - 1].index === N2 - 1;
          return (Q || v2.bottom > 0 && v2.itemHeight > 0 && v2.offsetBottom === 0 && v2.items.length === N2) && tt;
        }),
        E(([[, v2]]) => v2 - 1),
        Y()
      )
    ), Mt = pt(
      x(
        A(B),
        P(({ items: v2 }) => v2.length > 0 && v2[0].index === 0),
        vt(0),
        Y()
      )
    ), yt = pt(
      x(
        A(B),
        G(dt2),
        P(([{ items: v2 }, N2]) => v2.length > 0 && !N2),
        E(([{ items: v2 }]) => ({
          endIndex: v2[v2.length - 1].index,
          startIndex: v2[0].index
        })),
        Y(An),
        Lt(0)
      )
    );
    F(yt, m2.scrollSeekRangeChanged), F(
      x(
        V,
        G(O, L, d2, k2),
        E(([v2, N2, Q, it, tt]) => {
          const Bt = Nn(v2), { align: Jt, behavior: Nt, offset: de } = Bt;
          let Ot = Bt.index;
          Ot === "LAST" && (Ot = it - 1), Ot = ee(0, Ot, Fe(it - 1, Ot));
          let Ft = Ae(N2, tt, Q, Ot);
          return Jt === "end" ? Ft = vn(Ft - N2.height + Q.height) : Jt === "center" && (Ft = vn(Ft - N2.height / 2 + Q.height / 2)), de && (Ft += de), { behavior: Nt, top: Ft };
        })
      ),
      c2
    );
    const kt = ct(
      x(
        B,
        E((v2) => v2.offsetBottom + v2.bottom)
      ),
      0
    );
    return F(
      x(
        b2,
        E((v2) => ({ height: v2.visibleHeight, width: v2.visibleWidth }))
      ),
      O
    ), {
      customScrollParent: C,
      // input
      data: nt,
      deviation: J,
      footerHeight: r3,
      gap: k2,
      headerHeight: s3,
      increaseViewportBy: t3,
      initialItemCount: R,
      itemDimensions: L,
      overscan: n3,
      restoreStateFrom: st,
      scrollBy: i3,
      scrollContainerState: l2,
      scrollHeight: D,
      scrollTo: c2,
      scrollToIndex: V,
      scrollTop: u2,
      smoothScrollTargetReached: f2,
      totalCount: d2,
      useWindowScroll: g2,
      viewportDimensions: O,
      windowScrollContainerState: a2,
      windowScrollTo: T,
      windowViewportRect: b2,
      ...m2,
      // output
      gridState: B,
      horizontalDirection: At,
      initialTopMostItemIndex: St,
      totalListHeight: kt,
      ...p2,
      endReached: Xt,
      propsReady: I,
      rangeChanged: yt,
      startReached: Mt,
      stateChanged: q,
      stateRestoreInProgress: dt2,
      ...h2
    };
  },
  X(Ke, at, ae, Kn, Pt, je, Vt)
);
function no(t3, e2, n3) {
  return ee(1, Ce((t3 + n3) / (Ce(e2) + n3)));
}
function Rn(t3, e2, n3, o3) {
  const { height: r3 } = n3;
  if (r3 === void 0 || o3.length === 0)
    return { bottom: 0, top: 0 };
  const s3 = Ae(t3, e2, n3, o3[0].index);
  return { bottom: Ae(t3, e2, n3, o3[o3.length - 1].index) + r3, top: s3 };
}
function Ae(t3, e2, n3, o3) {
  const r3 = no(t3.width, n3.width, e2.column), s3 = Ce(o3 / r3), i3 = s3 * n3.height + ee(0, s3 - 1) * e2.row;
  return i3 > 0 ? i3 + e2.row : i3;
}
var Or = U(() => {
  const t3 = y((S3) => `Item ${S3}`), e2 = y({}), n3 = y(null), o3 = y("virtuoso-grid-item"), r3 = y("virtuoso-grid-list"), s3 = y(Ye), i3 = y("div"), l2 = y(Yt), c2 = (S3, p2 = null) => ct(
    x(
      e2,
      E((m2) => m2[S3]),
      Y()
    ),
    p2
  ), u2 = y(false), f2 = y(false);
  return F(A(f2), u2), {
    components: e2,
    computeItemKey: s3,
    context: n3,
    FooterComponent: c2("Footer"),
    HeaderComponent: c2("Header"),
    headerFooterTag: i3,
    itemClassName: o3,
    ItemComponent: c2("Item", "div"),
    itemContent: t3,
    listClassName: r3,
    ListComponent: c2("List", "div"),
    readyStateChanged: u2,
    reportReadyState: f2,
    ScrollerComponent: c2("Scroller", "div"),
    scrollerRef: l2,
    ScrollSeekPlaceholder: c2("ScrollSeekPlaceholder", "div")
  };
});
var Fr = U(
  ([t3, e2]) => ({ ...t3, ...e2 }),
  X(Br, Or)
);
var Lr = import_react10.default.memo(function() {
  const e2 = et("gridState"), n3 = et("listClassName"), o3 = et("itemClassName"), r3 = et("itemContent"), s3 = et("computeItemKey"), i3 = et("isSeeking"), l2 = It("scrollHeight"), c2 = et("ItemComponent"), u2 = et("ListComponent"), f2 = et("ScrollSeekPlaceholder"), S3 = et("context"), p2 = It("itemDimensions"), m2 = It("gap"), w3 = et("log"), I = et("stateRestoreInProgress"), C = It("reportReadyState"), g2 = Ht(
    import_react10.default.useMemo(
      () => (a2) => {
        const T = a2.parentElement.parentElement.scrollHeight;
        l2(T);
        const b2 = a2.firstChild;
        if (b2) {
          const { height: h2, width: d2 } = b2.getBoundingClientRect();
          p2({ height: h2, width: d2 });
        }
        m2({
          column: Hn("column-gap", getComputedStyle(a2).columnGap, w3),
          row: Hn("row-gap", getComputedStyle(a2).rowGap, w3)
        });
      },
      [l2, p2, m2, w3]
    ),
    true,
    false
  );
  return Zn(() => {
    e2.itemHeight > 0 && e2.itemWidth > 0 && C(true);
  }, [e2]), I ? null : (0, import_jsx_runtime.jsx)(
    u2,
    {
      className: n3,
      ref: g2,
      ...Z(u2, S3),
      "data-testid": "virtuoso-item-list",
      style: { paddingBottom: e2.offsetBottom, paddingTop: e2.offsetTop },
      children: e2.items.map((a2) => {
        const T = s3(a2.index, a2.data, S3);
        return i3 ? (0, import_jsx_runtime.jsx)(
          f2,
          {
            ...Z(f2, S3),
            height: e2.itemHeight,
            index: a2.index,
            width: e2.itemWidth
          },
          T
        ) : (0, import_react10.createElement)(
          c2,
          {
            ...Z(c2, S3),
            className: o3,
            "data-index": a2.index,
            key: T
          },
          r3(a2.index, a2.data, S3)
        );
      })
    }
  );
});
var zr = import_react10.default.memo(function() {
  const e2 = et("HeaderComponent"), n3 = It("headerHeight"), o3 = et("headerFooterTag"), r3 = Ht(
    import_react10.default.useMemo(
      () => (i3) => {
        n3(wt(i3, "height"));
      },
      [n3]
    ),
    true,
    false
  ), s3 = et("context");
  return e2 ? (0, import_jsx_runtime.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime.jsx)(e2, { ...Z(e2, s3) }) }) : null;
});
var Vr = import_react10.default.memo(function() {
  const e2 = et("FooterComponent"), n3 = It("footerHeight"), o3 = et("headerFooterTag"), r3 = Ht(
    import_react10.default.useMemo(
      () => (i3) => {
        n3(wt(i3, "height"));
      },
      [n3]
    ),
    true,
    false
  ), s3 = et("context");
  return e2 ? (0, import_jsx_runtime.jsx)(o3, { ref: r3, children: (0, import_jsx_runtime.jsx)(e2, { ...Z(e2, s3) }) }) : null;
});
var Pr = ({ children: t3 }) => {
  const e2 = import_react10.default.useContext(Yn), n3 = It("itemDimensions"), o3 = It("viewportDimensions"), r3 = Ht(
    import_react10.default.useMemo(
      () => (s3) => {
        o3(s3.getBoundingClientRect());
      },
      [o3]
    ),
    true,
    false
  );
  return import_react10.default.useEffect(() => {
    e2 && (o3({ height: e2.viewportHeight, width: e2.viewportWidth }), n3({ height: e2.itemHeight, width: e2.itemWidth }));
  }, [e2, o3, n3]), (0, import_jsx_runtime.jsx)("div", { ref: r3, style: Zt(false), children: t3 });
};
var Ar = ({ children: t3 }) => {
  const e2 = import_react10.default.useContext(Yn), n3 = It("windowViewportRect"), o3 = It("itemDimensions"), r3 = et("customScrollParent"), s3 = Ge(n3, r3, false);
  return import_react10.default.useEffect(() => {
    e2 && (o3({ height: e2.itemHeight, width: e2.itemWidth }), n3({ offsetTop: 0, visibleHeight: e2.viewportHeight, visibleWidth: e2.viewportWidth }));
  }, [e2, n3, o3]), (0, import_jsx_runtime.jsx)("div", { ref: s3, style: Zt(false), children: t3 });
};
var Mr = import_react10.default.memo(function({ ...e2 }) {
  const n3 = et("useWindowScroll"), o3 = et("customScrollParent"), r3 = o3 || n3 ? Gr : _r, s3 = o3 || n3 ? Ar : Pr, i3 = et("context");
  return (0, import_jsx_runtime.jsx)(r3, { ...e2, ...Z(r3, i3), children: (0, import_jsx_runtime.jsxs)(s3, { children: [
    (0, import_jsx_runtime.jsx)(zr, {}),
    (0, import_jsx_runtime.jsx)(Lr, {}),
    (0, import_jsx_runtime.jsx)(Vr, {})
  ] }) });
});
var {
  Component: Wr,
  useEmitter: oo,
  useEmitterValue: et,
  usePublisher: It
} = qe(
  Fr,
  {
    events: {
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      endReached: "endReached",
      isScrolling: "isScrolling",
      rangeChanged: "rangeChanged",
      readyStateChanged: "readyStateChanged",
      startReached: "startReached",
      stateChanged: "stateChanged"
    },
    methods: {
      scrollBy: "scrollBy",
      scrollTo: "scrollTo",
      scrollToIndex: "scrollToIndex"
    },
    optional: {
      components: "components",
      computeItemKey: "computeItemKey",
      context: "context",
      customScrollParent: "customScrollParent",
      data: "data",
      headerFooterTag: "headerFooterTag",
      increaseViewportBy: "increaseViewportBy",
      initialItemCount: "initialItemCount",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      itemClassName: "itemClassName",
      itemContent: "itemContent",
      listClassName: "listClassName",
      logLevel: "logLevel",
      overscan: "overscan",
      restoreStateFrom: "restoreStateFrom",
      scrollerRef: "scrollerRef",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      totalCount: "totalCount",
      useWindowScroll: "useWindowScroll"
    }
  },
  Mr
);
var _r = Ze({ useEmitter: oo, useEmitterValue: et, usePublisher: It });
var Gr = Xe({ useEmitter: oo, useEmitterValue: et, usePublisher: It });
function Hn(t3, e2, n3) {
  return e2 !== "normal" && !(e2 != null && e2.endsWith("px")) && n3(`${t3} was not resolved to pixel value correctly`, e2, ht.WARN), e2 === "normal" ? 0 : parseInt(e2 != null ? e2 : "0", 10);
}
var Yr = Wr;

// node_modules/react-hook-form/dist/index.esm.mjs
var React8 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject2 = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy3;
  const isArray2 = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy3 = new Date(data);
  } else if (data instanceof Set) {
    copy3 = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray2 || isObject(data))) {
    copy3 = isArray2 ? [] : {};
    if (!isArray2 && !isPlainObject2(data)) {
      copy3 = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy3[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy3;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (object, path, defaultValue) => {
  if (!path || !isObject(object)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean2 = (value) => typeof value === "boolean";
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var set = (object, path, value) => {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length2 = tempPath.length;
  const lastIndex = length2 - 1;
  while (++index2 < length2) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
var HookFormContext = import_react11.default.createContext(null);
var useFormContext = () => import_react11.default.useContext(HookFormContext);
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var useDeepEqualEffect = (effect, deps) => {
  const ref = React8.useRef(deps);
  if (!deepEqual(deps, ref.current)) {
    ref.current = deps;
  }
  React8.useEffect(effect, ref.current);
};
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = import_react11.default.useState(control._formState);
  const _localProxyFormState = import_react11.default.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  useDeepEqualEffect(() => control._subscribe({
    name,
    formState: _localProxyFormState.current,
    exact,
    callback: (formState2) => {
      !disabled && updateFormState({
        ...control._formState,
        ...formState2
      });
    }
  }), [name, disabled, exact]);
  import_react11.default.useEffect(() => {
    _localProxyFormState.current.isValid && control._setValid(true);
  }, [control]);
  return import_react11.default.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact } = props || {};
  const [value, updateValue] = import_react11.default.useState(control._getWatch(name, defaultValue));
  useDeepEqualEffect(() => control._subscribe({
    name,
    formState: {
      values: true
    },
    exact,
    callback: (formState) => !disabled && updateValue(generateWatchOutput(name, control._names, formState.values || control._formValues, false, defaultValue))
  }), [name, defaultValue, disabled, exact]);
  import_react11.default.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _props = import_react11.default.useRef(props);
  const _registerProps = import_react11.default.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean2(props.disabled) ? { disabled: props.disabled } : {}
  }));
  const fieldState = import_react11.default.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get(formState.errors, name)
    }
  }), [formState, name]);
  const onChange2 = import_react11.default.useCallback((event) => _registerProps.current.onChange({
    target: {
      value: getEventValue(event),
      name
    },
    type: EVENTS.CHANGE
  }), [name]);
  const onBlur = import_react11.default.useCallback(() => _registerProps.current.onBlur({
    target: {
      value: get(control._formValues, name),
      name
    },
    type: EVENTS.BLUR
  }), [name, control._formValues]);
  const ref = import_react11.default.useCallback((elm) => {
    const field2 = get(control._fields, name);
    if (field2 && elm) {
      field2._f.ref = {
        focus: () => elm.focus(),
        select: () => elm.select(),
        setCustomValidity: (message2) => elm.setCustomValidity(message2),
        reportValidity: () => elm.reportValidity()
      };
    }
  }, [control._fields, name]);
  const field = import_react11.default.useMemo(() => ({
    name,
    value,
    ...isBoolean2(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
    onChange: onChange2,
    onBlur,
    ref
  }), [name, disabled, formState.disabled, onChange2, onBlur, ref, value]);
  import_react11.default.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    control.register(name, {
      ..._props.current.rules,
      ...isBoolean2(_props.current.disabled) ? { disabled: _props.current.disabled } : {}
    });
    const updateMounted = (name2, value2) => {
      const field2 = get(control._fields, name2);
      if (field2 && field2._f) {
        field2._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    !isArrayField && control.register(name);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  import_react11.default.useEffect(() => {
    control._setDisabledField({
      disabled,
      name
    });
  }, [disabled, name, control]);
  return import_react11.default.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
var Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message2) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message2 || true
  }
} : {};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var createSubject = () => {
  let _observers = [];
  const next2 = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o3) => o3 !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next: next2,
    subscribe,
    unsubscribe
  };
};
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioInput = (element) => element.type === "radio";
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
function baseGet(object, updatePath) {
  const length2 = updatePath.slice(0, -1).length;
  let index2 = 0;
  while (index2 < length2) {
    object = isUndefined(object) ? index2++ : object[updatePath[index2++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index2 = paths.length - 1;
  const key = paths[index2];
  if (childObject) {
    delete childObject[key];
  }
  if (index2 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = { value: true, isValid: true };
var getCheckboxValue = (options2) => {
  if (Array.isArray(options2)) {
    if (options2.length > 1) {
      const values = options2.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options2[0].checked && !options2[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options2[0].attributes && !isUndefined(options2[0].attributes.value) ? isUndefined(options2[0].value) || options2[0].value === "" ? validResult : { value: options2[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options2) => Array.isArray(options2) ? options2.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var isRegex = (value) => value instanceof RegExp;
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options2) => options2.mount && (options2.required || options2.min || options2.max || options2.maxLength || options2.minLength || options2.pattern || options2.validate);
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
var iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isMessage = (value) => isString(value);
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean2(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabledFieldNames.has(name)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message2) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean2(message2) ? "" : message2 || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message2 = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message: message2,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message2)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean2(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message: message2 } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message: message2,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max);
    const minOutput = getValueAndMessage(min);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message: message2 } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message: message2,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isReady: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  const _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.values || _options.defaultValues) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  let _proxySubscribeFormState = {
    ..._proxyFormState
  };
  const _subjects = {
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _setValid = async (shouldUpdateValid) => {
    if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
      const isValid3 = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid3 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid3
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _setValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!_options.disabled) {
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
        isPreviousDirty = !!get(_formState.dirtyFields, name);
        isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid3, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean2(isValid3) && _formState.isValid !== isValid3;
    if (_options.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean2(isValid3) ? { isValid: isValid3 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _runSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _runSchema(names);
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => !_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options2 = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.state.next({
              name,
              values: cloneObject(_formValues)
            });
          }
        }
      }
    }
    (options2.shouldDirty || options2.shouldTouch) && updateTouchAndDirty(name, fieldValue, options2.shouldTouch, options2.shouldDirty, true);
    options2.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options2) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options2) : setFieldValue(fieldName, fieldValue, options2);
    }
  };
  const setValue = (name, value, options2 = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: cloneObject(_formValues)
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options2.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options2) : setFieldValue(name, cloneValue, options2);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.state.next({
      name: _state.mount ? name : void 0,
      values: cloneObject(_formValues)
    });
  };
  const onChange2 = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));
    };
    if (field) {
      let error;
      let isValid3;
      const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.state.next({
        name,
        type: event.type,
        values: cloneObject(_formValues)
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
          if (_options.mode === "onBlur") {
            if (isBlurEvent) {
              _setValid();
            }
          } else if (!isBlurEvent) {
            _setValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _runSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid3 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid3 = false;
          } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
            isValid3 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid3, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options2 = {}) => {
    let isValid3;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid3 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid3;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _setValid();
    } else {
      validationResult = isValid3 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid3 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid3 } : {},
      errors: _formState.errors
    });
    options2.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options2) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};
    const { ref: currentRef, message: message2, type, ...restOfErrorTree } = currentError;
    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options2 && options2.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.state.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const _subscribe = (props2) => _subjects.state.subscribe({
    next: (formState) => {
      if (shouldSubscribeByName(props2.name, formState.name, props2.exact) && shouldRenderFormState(formState, props2.formState || _proxyFormState, _setFormState, props2.reRenderRoot)) {
        props2.callback({
          values: { ..._formValues },
          ..._formState,
          ...formState
        });
      }
    }
  }).unsubscribe;
  const subscribe = (props2) => {
    _state.mount = true;
    _proxySubscribeFormState = {
      ..._proxySubscribeFormState,
      ...props2.formState
    };
    return _subscribe({
      ...props2,
      formState: _proxySubscribeFormState
    });
  };
  const unregister = (name, options2 = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options2.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options2.keepError && unset(_formState.errors, fieldName);
      !options2.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options2.keepTouched && unset(_formState.touchedFields, fieldName);
      !options2.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options2.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.state.next({
      values: cloneObject(_formValues)
    });
    _subjects.state.next({
      ..._formState,
      ...!options2.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options2.keepIsValid && _setValid();
  };
  const _setDisabledField = ({ disabled, name }) => {
    if (isBoolean2(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
      disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
    }
  };
  const register = (name, options2 = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean2(options2.disabled) || isBoolean2(_options.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options2
      }
    });
    _names.mount.add(name);
    if (field) {
      _setDisabledField({
        disabled: isBoolean2(options2.disabled) ? options2.disabled : _options.disabled,
        name
      });
    } else {
      updateValidAndValue(name, true, options2.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options2.disabled || _options.disabled } : {},
      ..._options.progressive ? {
        required: !!options2.required,
        min: getRuleValue(options2.min),
        max: getRuleValue(options2.max),
        minLength: getRuleValue(options2.minLength),
        maxLength: getRuleValue(options2.maxLength),
        pattern: getRuleValue(options2.pattern)
      } : {},
      name,
      onChange: onChange2,
      onBlur: onChange2,
      ref: (ref) => {
        if (ref) {
          register(name, options2);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options2.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean2(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    let onValidError = void 0;
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _runSchema();
      _formState.errors = errors;
      fieldValues = values;
    } else {
      await executeBuiltInValidation(_fields);
    }
    if (_names.disabled.size) {
      for (const name of _names.disabled) {
        set(fieldValues, name, void 0);
      }
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e2);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options2 = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options2.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(name, options2.defaultValue);
        set(_defaultValues, name, cloneObject(options2.defaultValue));
      }
      if (!options2.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options2.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options2.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options2.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _setValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        for (const fieldName of _names.mount) {
          setValue(fieldName, get(values, fieldName));
        }
      }
      _formValues = cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.state.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options2 = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options2.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _setFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  const methods = {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _subscribe,
      _runSchema,
      _getWatch,
      _getDirty,
      _setValid,
      _setFieldArray,
      _setDisabledField,
      _setErrors,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _removeUnmounted,
      _disableForm,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    subscribe,
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
  return {
    ...methods,
    formControl: methods
  };
}
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react11.default.useLayoutEffect : import_react11.default.useEffect;
function useForm(props = {}) {
  const _formControl = import_react11.default.useRef(void 0);
  const _values = import_react11.default.useRef(void 0);
  const [formState, updateFormState] = import_react11.default.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    isReady: false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...props.formControl ? props.formControl : createFormControl(props),
      formState
    };
    if (props.formControl && props.defaultValues && !isFunction(props.defaultValues)) {
      props.formControl.reset(props.defaultValues, props.resetOptions);
    }
  }
  const control = _formControl.current.control;
  control._options = props;
  useIsomorphicLayoutEffect2(() => {
    const sub = control._subscribe({
      formState: control._proxyFormState,
      callback: () => updateFormState({ ...control._formState }),
      reRenderRoot: true
    });
    updateFormState((data) => ({
      ...data,
      isReady: true
    }));
    control._formState.isReady = true;
    return sub;
  }, [control]);
  import_react11.default.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  import_react11.default.useEffect(() => {
    if (props.mode) {
      control._options.mode = props.mode;
    }
    if (props.reValidateMode) {
      control._options.reValidateMode = props.reValidateMode;
    }
    if (props.errors && !isEmptyObject(props.errors)) {
      control._setErrors(props.errors);
    }
  }, [control, props.errors, props.mode, props.reValidateMode]);
  import_react11.default.useEffect(() => {
    props.shouldUnregister && control._subjects.state.next({
      values: control._getWatch()
    });
  }, [control, props.shouldUnregister]);
  import_react11.default.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty2 = control._getDirty();
      if (isDirty2 !== formState.isDirty) {
        control._subjects.state.next({
          isDirty: isDirty2
        });
      }
    }
  }, [control, formState.isDirty]);
  import_react11.default.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [control, props.values]);
  import_react11.default.useEffect(() => {
    if (!control._state.mount) {
      control._setValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}

// node_modules/@hookform/resolvers/dist/resolvers.mjs
var s = (e2, s3, o3) => {
  if (e2 && "reportValidity" in e2) {
    const r3 = get(o3, s3);
    e2.setCustomValidity(r3 && r3.message || ""), e2.reportValidity();
  }
};
var o = (t3, e2) => {
  for (const o3 in e2.fields) {
    const r3 = e2.fields[o3];
    r3 && r3.ref && "reportValidity" in r3.ref ? s(r3.ref, o3, t3) : r3.refs && r3.refs.forEach((e3) => s(e3, o3, t3));
  }
};
var r = (s3, r3) => {
  r3.shouldUseNativeValidation && o(s3, r3);
  const f2 = {};
  for (const o3 in s3) {
    const n3 = get(r3.fields, o3), a2 = Object.assign(s3[o3] || {}, { ref: n3 && n3.ref });
    if (i(r3.names || Object.keys(s3), o3)) {
      const s4 = Object.assign({}, get(f2, o3));
      set(s4, "root", a2), set(f2, o3, s4);
    } else set(f2, o3, a2);
  }
  return f2;
};
var i = (t3, e2) => t3.some((t4) => t4.startsWith(e2 + "."));

// node_modules/@hookform/resolvers/zod/dist/zod.mjs
var n = function(r3, e2) {
  for (var n3 = {}; r3.length; ) {
    var t3 = r3[0], s3 = t3.code, i3 = t3.message, a2 = t3.path.join(".");
    if (!n3[a2]) if ("unionErrors" in t3) {
      var u2 = t3.unionErrors[0].errors[0];
      n3[a2] = { message: u2.message, type: u2.code };
    } else n3[a2] = { message: i3, type: s3 };
    if ("unionErrors" in t3 && t3.unionErrors.forEach(function(e3) {
      return e3.errors.forEach(function(e4) {
        return r3.push(e4);
      });
    }), e2) {
      var c2 = n3[a2].types, f2 = c2 && c2[t3.code];
      n3[a2] = appendErrors(a2, e2, n3, s3, f2 ? [].concat(f2, t3.message) : t3.message);
    }
    r3.shift();
  }
  return n3;
};
var t = function(o3, t3, s3) {
  return void 0 === s3 && (s3 = {}), function(i3, a2, u2) {
    try {
      return Promise.resolve(function(e2, n3) {
        try {
          var a3 = Promise.resolve(o3["sync" === s3.mode ? "parse" : "parseAsync"](i3, t3)).then(function(e3) {
            return u2.shouldUseNativeValidation && o({}, u2), { errors: {}, values: s3.raw ? i3 : e3 };
          });
        } catch (r3) {
          return n3(r3);
        }
        return a3 && a3.then ? a3.then(void 0, n3) : a3;
      }(0, function(r3) {
        if (function(r4) {
          return Array.isArray(null == r4 ? void 0 : r4.errors);
        }(r3)) return { values: {}, errors: r(n(r3.errors, !u2.shouldUseNativeValidation && "all" === u2.criteriaMode), u2) };
        throw r3;
      }));
    } catch (r3) {
      return Promise.reject(r3);
    }
  };
};

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t3 = typeof data;
  switch (t3) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
};
var overrideErrorMap = errorMap;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s3 of results) {
      if (s3.status === "aborted")
        return INVALID;
      if (s3.status === "dirty")
        status.dirty();
      arrayValue.push(s3.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x3) => x3.status === "aborted";
var isDirty = (x3) => x3.status === "dirty";
var isValid = (x3) => x3.status === "valid";
var isAsync = (x3) => typeof Promise !== "undefined" && x3 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2 === null || message2 === void 0 ? void 0 : message2.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 !== null && message2 !== void 0 ? message2 : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message2 !== null && message2 !== void 0 ? message2 : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message2 !== null && message2 !== void 0 ? message2 : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = (val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  nanoid(message2) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  base64(message2) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
  }
  base64url(message2) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message2)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    var _a, _b;
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
      offset: (_a = options2 === null || options2 === void 0 ? void 0 : options2.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options2 === null || options2 === void 0 ? void 0 : options2.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  date(message2) {
    return this._addCheck({ kind: "date", message: message2 });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options2 === null || options2 === void 0 ? void 0 : options2.precision) === "undefined" ? null : options2 === null || options2 === void 0 ? void 0 : options2.precision,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  duration(message2) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2 === null || options2 === void 0 ? void 0 : options2.position,
      ...errorUtil.errToObj(options2 === null || options2 === void 0 ? void 0 : options2.message)
    });
  }
  startsWith(value, message2) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value, message2) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len, message2) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len, message2) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message2).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options2) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size, message2) {
    return this.min(size, message2).max(size, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new _ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze2 = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze2(data)) : freeze2(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p2 === "string" ? { message: p2 } : p2;
  return p22;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r3 = check(data);
      if (r3 instanceof Promise) {
        return r3.then((r4) => {
          var _a2, _b2;
          if (!r4) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r3) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z2 = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/formatDistance.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token2, count, options2) => {
  let result;
  const tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildFormatLongFn.js
function buildFormatLongFn(args) {
  return (options2 = {}) => {
    const width = options2.width ? String(options2.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/formatLong.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/formatRelative.js
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token2, _date, _baseDate, _options) => formatRelativeLocale[token2];

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildLocalizeFn.js
function buildLocalizeFn(args) {
  return (value, options2) => {
    const context = (options2 == null ? void 0 : options2.context) ? String(options2.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options2 == null ? void 0 : options2.width) ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options2 == null ? void 0 : options2.width) ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/localize.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildMatchFn.js
function buildMatchFn(args) {
  return (string, options2 = {}) => {
    const width = options2.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options2.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options2.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/_lib/buildMatchPatternFn.js
function buildMatchPatternFn(args) {
  return (string, options2 = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US/_lib/match.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/sanity-plugin-media/node_modules/date-fns/locale/en-US.js
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match: match2,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/defaultOptions.js
var defaultOptions2 = {};
function getDefaultOptions() {
  return defaultOptions2;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/constants.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInDay = 864e5;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;
var constructFromSymbol = Symbol.for("constructDateFrom");

// node_modules/sanity-plugin-media/node_modules/date-fns/constructFrom.js
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/toDate.js
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.js
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/normalizeDates.js
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    context || dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfDay.js
function startOfDay(date, options2) {
  const _date = toDate(date, options2 == null ? void 0 : options2.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/differenceInCalendarDays.js
function differenceInCalendarDays(laterDate, earlierDate, options2) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options2 == null ? void 0 : options2.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfYear.js
function startOfYear(date, options2) {
  const date_ = toDate(date, options2 == null ? void 0 : options2.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getDayOfYear.js
function getDayOfYear(date, options2) {
  const _date = toDate(date, options2 == null ? void 0 : options2.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfWeek.js
function startOfWeek(date, options2) {
  var _a, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date, options2 == null ? void 0 : options2.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfISOWeek.js
function startOfISOWeek(date, options2) {
  return startOfWeek(date, { ...options2, weekStartsOn: 1 });
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getISOWeekYear.js
function getISOWeekYear(date, options2) {
  const _date = toDate(date, options2 == null ? void 0 : options2.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfISOWeekYear.js
function startOfISOWeekYear(date, options2) {
  const year = getISOWeekYear(date, options2);
  const fourthOfJanuary = constructFrom((options2 == null ? void 0 : options2.in) || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getISOWeek.js
function getISOWeek(date, options2) {
  const _date = toDate(date, options2 == null ? void 0 : options2.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getWeekYear.js
function getWeekYear(date, options2) {
  var _a, _b, _c, _d;
  const _date = toDate(date, options2 == null ? void 0 : options2.in);
  const year = _date.getFullYear();
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom((options2 == null ? void 0 : options2.in) || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options2);
  const firstWeekOfThisYear = constructFrom((options2 == null ? void 0 : options2.in) || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options2);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/sanity-plugin-media/node_modules/date-fns/startOfWeekYear.js
function startOfWeekYear(date, options2) {
  var _a, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options2);
  const firstWeek = constructFrom((options2 == null ? void 0 : options2.in) || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options2);
  return _date;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/getWeek.js
function getWeek(date, options2) {
  const _date = toDate(date, options2 == null ? void 0 : options2.in);
  const diff = +startOfWeek(_date, options2) - +startOfWeekYear(_date, options2);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/addLeadingZeros.js
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/format/lightFormatters.js
var lightFormatters = {
  // Year
  y(date, token2) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  // Month
  M(date, token2) {
    const month = date.getMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token2) {
    return addLeadingZeros(date.getDate(), token2.length);
  },
  // AM or PM
  a(date, token2) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token2) {
    return addLeadingZeros(date.getHours() % 12 || 12, token2.length);
  },
  // Hour [0-23]
  H(date, token2) {
    return addLeadingZeros(date.getHours(), token2.length);
  },
  // Minute
  m(date, token2) {
    return addLeadingZeros(date.getMinutes(), token2.length);
  },
  // Second
  s(date, token2) {
    return addLeadingZeros(date.getSeconds(), token2.length);
  },
  // Fraction of second
  S(date, token2) {
    const numberOfDigits = token2.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/format/formatters.js
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function(date, token2, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token2) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token2, localize2) {
    if (token2 === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token2);
  },
  // Local week-numbering year
  Y: function(date, token2, localize2, options2) {
    const signedWeekYear = getWeekYear(date, options2);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  // ISO week-numbering year
  R: function(date, token2) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token2) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token2.length);
  },
  // Quarter
  Q: function(date, token2, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token2) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token2, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token2) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token2, localize2) {
    const month = date.getMonth();
    switch (token2) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token2);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token2, localize2) {
    const month = date.getMonth();
    switch (token2) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token2, localize2, options2) {
    const week = getWeek(date, options2);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token2.length);
  },
  // ISO week of year
  I: function(date, token2, localize2) {
    const isoWeek = getISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  // Day of the month
  d: function(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token2);
  },
  // Day of year
  D: function(date, token2, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  // Day of week
  E: function(date, token2, localize2) {
    const dayOfWeek = date.getDay();
    switch (token2) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token2, localize2, options2) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token2, localize2, options2) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token2, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token2, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token2, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token2, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token2, localize2) {
    if (token2 === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token2);
  },
  // Hour [0-23]
  H: function(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token2);
  },
  // Hour [0-11]
  K: function(date, token2, localize2) {
    const hours = date.getHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Hour [1-24]
  k: function(date, token2, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token2.length);
  },
  // Minute
  m: function(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token2);
  },
  // Second
  s: function(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token2);
  },
  // Fraction of second
  S: function(date, token2) {
    return lightFormatters.S(date, token2);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token2, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token2) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token2, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  // Milliseconds timestamp
  T: function(date, token2, _localize) {
    return addLeadingZeros(+date, token2.length);
  }
};
function formatTimezoneShort(offset, delimiter2 = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter2) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter2);
}
function formatTimezone(offset, delimiter2 = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter2 + minutes;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/format/longFormatters.js
var dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// node_modules/sanity-plugin-media/node_modules/date-fns/_lib/protectedTokens.js
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return dayOfYearTokenRE.test(token2);
}
function isProtectedWeekYearToken(token2) {
  return weekYearTokenRE.test(token2);
}
function warnOrThrowProtectedError(token2, format2, input) {
  const _message = message(token2, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token2)) throw new RangeError(_message);
}
function message(token2, format2, input) {
  const subject = token2[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token2.toLowerCase()}\` instead of \`${token2}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// node_modules/sanity-plugin-media/node_modules/date-fns/isDate.js
function isDate2(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/sanity-plugin-media/node_modules/date-fns/isValid.js
function isValid2(date) {
  return !(!isDate2(date) && typeof date !== "number" || isNaN(+toDate(date)));
}

// node_modules/sanity-plugin-media/node_modules/date-fns/format.js
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(date, formatStr, options2) {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  const defaultOptions3 = getDefaultOptions();
  const locale = (options2 == null ? void 0 : options2.locale) ?? defaultOptions3.locale ?? enUS;
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_f = (_e2 = options2 == null ? void 0 : options2.locale) == null ? void 0 : _e2.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_h = (_g = defaultOptions3.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
  const originalDate = toDate(date, options2 == null ? void 0 : options2.in);
  if (!isValid2(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token2 = part.value;
    if (!(options2 == null ? void 0 : options2.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token2) || !(options2 == null ? void 0 : options2.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token2)) {
      warnOrThrowProtectedError(token2, formatStr, String(date));
    }
    const formatter = formatters[token2[0]];
    return formatter(originalDate, token2, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString(input) {
  const matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
var format_default = format;

// node_modules/filesize/lib/filesize.esm.js
var ARRAY = "array";
var BIT = "bit";
var BITS = "bits";
var BYTE = "byte";
var BYTES = "bytes";
var EMPTY2 = "";
var EXPONENT = "exponent";
var FUNCTION = "function";
var IEC = "iec";
var INVALID_NUMBER = "Invalid number";
var INVALID_ROUND = "Invalid rounding method";
var JEDEC = "jedec";
var OBJECT = "object";
var PERIOD = ".";
var ROUND = "round";
var S = "s";
var SI_KBIT = "kbit";
var SI_KBYTE = "kB";
var SPACE = " ";
var STRING = "string";
var ZERO = "0";
var strings = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function filesize(arg, {
  bits = false,
  pad = false,
  base = -1,
  round = 2,
  locale = EMPTY2,
  localeOptions = {},
  separator = EMPTY2,
  spacer = SPACE,
  symbols = {},
  standard = EMPTY2,
  output = STRING,
  fullform = false,
  fullforms = [],
  exponent = -1,
  roundingMethod = ROUND,
  precision = 0
} = {}) {
  let e2 = exponent, num = Number(arg), result = [], val = 0, u2 = EMPTY2;
  if (base === -1 && standard.length === 0) {
    base = 10;
    standard = JEDEC;
  } else if (base === -1 && standard.length > 0) {
    standard = standard === IEC ? IEC : JEDEC;
    base = standard === IEC ? 2 : 10;
  } else {
    base = base === 2 ? 2 : 10;
    standard = base === 10 ? JEDEC : standard === JEDEC ? JEDEC : IEC;
  }
  const ceil = base === 10 ? 1e3 : 1024, full = fullform === true, neg = num < 0, roundingFunc = Math[roundingMethod];
  if (isNaN(arg)) {
    throw new TypeError(INVALID_NUMBER);
  }
  if (typeof roundingFunc !== FUNCTION) {
    throw new TypeError(INVALID_ROUND);
  }
  if (neg) {
    num = -num;
  }
  if (e2 === -1 || isNaN(e2)) {
    e2 = Math.floor(Math.log(num) / Math.log(ceil));
    if (e2 < 0) {
      e2 = 0;
    }
  }
  if (e2 > 8) {
    if (precision > 0) {
      precision += 8 - e2;
    }
    e2 = 8;
  }
  if (output === EXPONENT) {
    return e2;
  }
  if (num === 0) {
    result[0] = 0;
    u2 = result[1] = strings.symbol[standard][bits ? BITS : BYTES][e2];
  } else {
    val = num / (base === 2 ? Math.pow(2, e2 * 10) : Math.pow(1e3, e2));
    if (bits) {
      val = val * 8;
      if (val >= ceil && e2 < 8) {
        val = val / ceil;
        e2++;
      }
    }
    const p2 = Math.pow(10, e2 > 0 ? round : 0);
    result[0] = roundingFunc(val * p2) / p2;
    if (result[0] === ceil && e2 < 8 && exponent === -1) {
      result[0] = 1;
      e2++;
    }
    u2 = result[1] = base === 10 && e2 === 1 ? bits ? SI_KBIT : SI_KBYTE : strings.symbol[standard][bits ? BITS : BYTES][e2];
  }
  if (neg) {
    result[0] = -result[0];
  }
  if (precision > 0) {
    result[0] = result[0].toPrecision(precision);
  }
  result[1] = symbols[result[1]] || result[1];
  if (locale === true) {
    result[0] = result[0].toLocaleString();
  } else if (locale.length > 0) {
    result[0] = result[0].toLocaleString(locale, localeOptions);
  } else if (separator.length > 0) {
    result[0] = result[0].toString().replace(PERIOD, separator);
  }
  if (pad && Number.isInteger(result[0]) === false && round > 0) {
    const x3 = separator || PERIOD, tmp = result[0].toString().split(x3), s3 = tmp[1] || EMPTY2, l2 = s3.length, n3 = round - l2;
    result[0] = `${tmp[0]}${x3}${s3.padEnd(l2 + n3, ZERO)}`;
  }
  if (full) {
    result[1] = fullforms[e2] ? fullforms[e2] : strings.fullform[standard][e2] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY2 : S);
  }
  return output === ARRAY ? result : output === OBJECT ? {
    value: result[0],
    symbol: result[1],
    exponent: e2,
    unit: u2
  } : result.join(spacer);
}
filesize.partial = (opt) => (arg) => filesize(arg, opt);

// node_modules/sanity-plugin-media/dist/index.mjs
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);

// node_modules/react-file-icon/dist/react-file-icon.esm.js
var import_react12 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/colord/index.mjs
var r2 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
var t2 = function(r3) {
  return "string" == typeof r3 ? r3.length > 0 : "number" == typeof r3;
};
var n2 = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = Math.pow(10, t3)), Math.round(n3 * r3) / n3 + 0;
};
var e = function(r3, t3, n3) {
  return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = 1), r3 > n3 ? n3 : r3 > t3 ? r3 : t3;
};
var u = function(r3) {
  return (r3 = isFinite(r3) ? r3 % 360 : 0) > 0 ? r3 : r3 + 360;
};
var a = function(r3) {
  return { r: e(r3.r, 0, 255), g: e(r3.g, 0, 255), b: e(r3.b, 0, 255), a: e(r3.a) };
};
var o2 = function(r3) {
  return { r: n2(r3.r), g: n2(r3.g), b: n2(r3.b), a: n2(r3.a, 3) };
};
var i2 = /^#([0-9a-f]{3,8})$/i;
var s2 = function(r3) {
  var t3 = r3.toString(16);
  return t3.length < 2 ? "0" + t3 : t3;
};
var h = function(r3) {
  var t3 = r3.r, n3 = r3.g, e2 = r3.b, u2 = r3.a, a2 = Math.max(t3, n3, e2), o3 = a2 - Math.min(t3, n3, e2), i3 = o3 ? a2 === t3 ? (n3 - e2) / o3 : a2 === n3 ? 2 + (e2 - t3) / o3 : 4 + (t3 - n3) / o3 : 0;
  return { h: 60 * (i3 < 0 ? i3 + 6 : i3), s: a2 ? o3 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
};
var b = function(r3) {
  var t3 = r3.h, n3 = r3.s, e2 = r3.v, u2 = r3.a;
  t3 = t3 / 360 * 6, n3 /= 100, e2 /= 100;
  var a2 = Math.floor(t3), o3 = e2 * (1 - n3), i3 = e2 * (1 - (t3 - a2) * n3), s3 = e2 * (1 - (1 - t3 + a2) * n3), h2 = a2 % 6;
  return { r: 255 * [e2, i3, o3, o3, s3, e2][h2], g: 255 * [s3, e2, e2, i3, o3, o3][h2], b: 255 * [o3, o3, s3, e2, e2, i3][h2], a: u2 };
};
var g = function(r3) {
  return { h: u(r3.h), s: e(r3.s, 0, 100), l: e(r3.l, 0, 100), a: e(r3.a) };
};
var d = function(r3) {
  return { h: n2(r3.h), s: n2(r3.s), l: n2(r3.l), a: n2(r3.a, 3) };
};
var f = function(r3) {
  return b((n3 = (t3 = r3).s, { h: t3.h, s: (n3 *= ((e2 = t3.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n3 / (e2 + n3) * 100 : 0, v: e2 + n3, a: t3.a }));
  var t3, n3, e2;
};
var c = function(r3) {
  return { h: (t3 = h(r3)).h, s: (u2 = (200 - (n3 = t3.s)) * (e2 = t3.v) / 100) > 0 && u2 < 200 ? n3 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t3.a };
  var t3, n3, e2, u2;
};
var l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
var y2 = { string: [[function(r3) {
  var t3 = i2.exec(r3);
  return t3 ? (r3 = t3[1]).length <= 4 ? { r: parseInt(r3[0] + r3[0], 16), g: parseInt(r3[1] + r3[1], 16), b: parseInt(r3[2] + r3[2], 16), a: 4 === r3.length ? n2(parseInt(r3[3] + r3[3], 16) / 255, 2) : 1 } : 6 === r3.length || 8 === r3.length ? { r: parseInt(r3.substr(0, 2), 16), g: parseInt(r3.substr(2, 2), 16), b: parseInt(r3.substr(4, 2), 16), a: 8 === r3.length ? n2(parseInt(r3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r3) {
  var t3 = v.exec(r3) || m.exec(r3);
  return t3 ? t3[2] !== t3[4] || t3[4] !== t3[6] ? null : a({ r: Number(t3[1]) / (t3[2] ? 100 / 255 : 1), g: Number(t3[3]) / (t3[4] ? 100 / 255 : 1), b: Number(t3[5]) / (t3[6] ? 100 / 255 : 1), a: void 0 === t3[7] ? 1 : Number(t3[7]) / (t3[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t3) {
  var n3 = l.exec(t3) || p.exec(t3);
  if (!n3) return null;
  var e2, u2, a2 = g({ h: (e2 = n3[1], u2 = n3[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r2[u2] || 1)), s: Number(n3[3]), l: Number(n3[4]), a: void 0 === n3[5] ? 1 : Number(n3[5]) / (n3[6] ? 100 : 1) });
  return f(a2);
}, "hsl"]], object: [[function(r3) {
  var n3 = r3.r, e2 = r3.g, u2 = r3.b, o3 = r3.a, i3 = void 0 === o3 ? 1 : o3;
  return t2(n3) && t2(e2) && t2(u2) ? a({ r: Number(n3), g: Number(e2), b: Number(u2), a: Number(i3) }) : null;
}, "rgb"], [function(r3) {
  var n3 = r3.h, e2 = r3.s, u2 = r3.l, a2 = r3.a, o3 = void 0 === a2 ? 1 : a2;
  if (!t2(n3) || !t2(e2) || !t2(u2)) return null;
  var i3 = g({ h: Number(n3), s: Number(e2), l: Number(u2), a: Number(o3) });
  return f(i3);
}, "hsl"], [function(r3) {
  var n3 = r3.h, a2 = r3.s, o3 = r3.v, i3 = r3.a, s3 = void 0 === i3 ? 1 : i3;
  if (!t2(n3) || !t2(a2) || !t2(o3)) return null;
  var h2 = function(r4) {
    return { h: u(r4.h), s: e(r4.s, 0, 100), v: e(r4.v, 0, 100), a: e(r4.a) };
  }({ h: Number(n3), s: Number(a2), v: Number(o3), a: Number(s3) });
  return b(h2);
}, "hsv"]] };
var N = function(r3, t3) {
  for (var n3 = 0; n3 < t3.length; n3++) {
    var e2 = t3[n3][0](r3);
    if (e2) return [e2, t3[n3][1]];
  }
  return [null, void 0];
};
var x2 = function(r3) {
  return "string" == typeof r3 ? N(r3.trim(), y2.string) : "object" == typeof r3 && null !== r3 ? N(r3, y2.object) : [null, void 0];
};
var M2 = function(r3, t3) {
  var n3 = c(r3);
  return { h: n3.h, s: e(n3.s + 100 * t3, 0, 100), l: n3.l, a: n3.a };
};
var H2 = function(r3) {
  return (299 * r3.r + 587 * r3.g + 114 * r3.b) / 1e3 / 255;
};
var $2 = function(r3, t3) {
  var n3 = c(r3);
  return { h: n3.h, s: n3.s, l: e(n3.l + 100 * t3, 0, 100), a: n3.a };
};
var j2 = function() {
  function r3(r4) {
    this.parsed = x2(r4)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r3.prototype.isValid = function() {
    return null !== this.parsed;
  }, r3.prototype.brightness = function() {
    return n2(H2(this.rgba), 2);
  }, r3.prototype.isDark = function() {
    return H2(this.rgba) < 0.5;
  }, r3.prototype.isLight = function() {
    return H2(this.rgba) >= 0.5;
  }, r3.prototype.toHex = function() {
    return r4 = o2(this.rgba), t3 = r4.r, e2 = r4.g, u2 = r4.b, i3 = (a2 = r4.a) < 1 ? s2(n2(255 * a2)) : "", "#" + s2(t3) + s2(e2) + s2(u2) + i3;
    var r4, t3, e2, u2, a2, i3;
  }, r3.prototype.toRgb = function() {
    return o2(this.rgba);
  }, r3.prototype.toRgbString = function() {
    return r4 = o2(this.rgba), t3 = r4.r, n3 = r4.g, e2 = r4.b, (u2 = r4.a) < 1 ? "rgba(" + t3 + ", " + n3 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t3 + ", " + n3 + ", " + e2 + ")";
    var r4, t3, n3, e2, u2;
  }, r3.prototype.toHsl = function() {
    return d(c(this.rgba));
  }, r3.prototype.toHslString = function() {
    return r4 = d(c(this.rgba)), t3 = r4.h, n3 = r4.s, e2 = r4.l, (u2 = r4.a) < 1 ? "hsla(" + t3 + ", " + n3 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t3 + ", " + n3 + "%, " + e2 + "%)";
    var r4, t3, n3, e2, u2;
  }, r3.prototype.toHsv = function() {
    return r4 = h(this.rgba), { h: n2(r4.h), s: n2(r4.s), v: n2(r4.v), a: n2(r4.a, 3) };
    var r4;
  }, r3.prototype.invert = function() {
    return w2({ r: 255 - (r4 = this.rgba).r, g: 255 - r4.g, b: 255 - r4.b, a: r4.a });
    var r4;
  }, r3.prototype.saturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2(M2(this.rgba, r4));
  }, r3.prototype.desaturate = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2(M2(this.rgba, -r4));
  }, r3.prototype.grayscale = function() {
    return w2(M2(this.rgba, -1));
  }, r3.prototype.lighten = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2($2(this.rgba, r4));
  }, r3.prototype.darken = function(r4) {
    return void 0 === r4 && (r4 = 0.1), w2($2(this.rgba, -r4));
  }, r3.prototype.rotate = function(r4) {
    return void 0 === r4 && (r4 = 15), this.hue(this.hue() + r4);
  }, r3.prototype.alpha = function(r4) {
    return "number" == typeof r4 ? w2({ r: (t3 = this.rgba).r, g: t3.g, b: t3.b, a: r4 }) : n2(this.rgba.a, 3);
    var t3;
  }, r3.prototype.hue = function(r4) {
    var t3 = c(this.rgba);
    return "number" == typeof r4 ? w2({ h: r4, s: t3.s, l: t3.l, a: t3.a }) : n2(t3.h);
  }, r3.prototype.isEqual = function(r4) {
    return this.toHex() === w2(r4).toHex();
  }, r3;
}();
var w2 = function(r3) {
  return r3 instanceof j2 ? r3 : new j2(r3);
};
var S2 = [];
var k = function(r3) {
  r3.forEach(function(r4) {
    S2.indexOf(r4) < 0 && (r4(j2, y2), S2.push(r4));
  });
};

// node_modules/colord/plugins/names.mjs
function names_default(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r3 = {};
  for (var d2 in a2) r3[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d3, i3, n3 = r3[this.toHex()];
    if (n3) return n3;
    if (null == f3 ? void 0 : f3.closest) {
      var o3 = this.toRgb(), t3 = 1 / 0, b2 = "black";
      if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o3, i3 = l2[g2], Math.pow(d3.r - i3.r, 2) + Math.pow(d3.g - i3.g, 2) + Math.pow(d3.b - i3.b, 2));
        u2 < t3 && (t3 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r4 = f3.toLowerCase(), d3 = "transparent" === r4 ? "#0000" : a2[r4];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}

// node_modules/react-file-icon/dist/react-file-icon.esm.js
var glyphs = {
  "3d": import_react12.default.createElement("path", {
    d: "M18 14.625V3.375L9 0 0 3.375v11.25L9 18l9-3.375zM9 2.136l5.918 2.22-5.98 2.242-5.919-2.22L9 2.137zM2 13.239V5.065l6.438 2.414v8.174L2 13.24zM9.438 15.7L16 13.239V5.018l-6.563 2.46V15.7z",
    transform: "translate(15 10)",
    fillRule: "evenodd"
  }),
  acrobat: import_react12.default.createElement("path", {
    d: "M10.15 1.095C9.938.33 9.42-.051 8.984.005c-.528.068-1.09.382-1.314.876-.63 1.416.685 5.582.887 6.279-1.28 3.863-5.66 11.5-7.806 12.017-.045-.505.225-1.965 3.055-3.785.146-.157.315-.348.393-.472-2.392 1.168-5.492 3.044-3.628 4.448.102.079.259.146.439.213 1.426.528 3.425-1.201 5.435-5.121 2.213-.73 3.999-1.28 6.526-1.662 2.762 1.875 4.616 2.257 5.874 1.774.348-.135.898-.573 1.055-1.145-1.022 1.258-3.414.382-5.323-.82 1.763-.191 3.582-.303 4.369-.056 1 .314.965.808.954.876.079-.27.191-.708-.022-1.056-.842-1.37-4.706-.573-6.11-.427-2.212-1.336-3.74-3.717-4.358-5.436.573-2.212 1.19-3.818.742-5.413zm-.954 4.638C8.826 4.42 8.309 1.5 9.14.556c1.628.932.618 3.144.056 5.177zm3.044 6.514c-2.134.393-3.583.944-5.66 1.764.617-1.202 1.785-4.268 2.346-6.29.787 1.573 1.741 3.111 3.314 4.526z",
    transform: "translate(14 9)",
    fillRule: "evenodd"
  }),
  android: import_react12.default.createElement("path", {
    d: "M17.6,9.48l1.84-3.18c0.16-0.31,0.04-0.69-0.26-0.85c-0.29-0.15-0.65-0.06-0.83,0.22l-1.88,3.24 c-2.86-1.21-6.08-1.21-8.94,0L5.65,5.67c-0.19-0.29-0.58-0.38-0.87-0.2C4.5,5.65,4.41,6.01,4.56,6.3L6.4,9.48 C3.3,11.25,1.28,14.44,1,18h22C22.72,14.44,20.7,11.25,17.6,9.48z M7,15.25c-0.69,0-1.25-0.56-1.25-1.25 c0-0.69,0.56-1.25,1.25-1.25S8.25,13.31,8.25,14C8.25,14.69,7.69,15.25,7,15.25z M17,15.25c-0.69,0-1.25-0.56-1.25-1.25 c0-0.69,0.56-1.25,1.25-1.25s1.25,0.56,1.25,1.25C18.25,14.69,17.69,15.25,17,15.25z",
    transform: "translate(12 8)"
  }),
  audio: import_react12.default.createElement("path", {
    d: "M.25 4.75v4.5h3L7 13V1L3.25 4.75h-3zM10.375 7A3.375 3.375 0 0 0 8.5 3.977v6.037A3.355 3.355 0 0 0 10.375 7zM8.5.421v1.545A5.254 5.254 0 0 1 12.25 7a5.254 5.254 0 0 1-3.75 5.032v1.545A6.747 6.747 0 0 0 13.75 7 6.747 6.747 0 0 0 8.5.421z",
    transform: "translate(17 12)",
    fillRule: "evenodd"
  }),
  binary: import_react12.default.createElement("path", {
    d: "M2.338 6.112c1.192 0 1.928-1.072 1.928-2.68 0-1.56-.576-2.504-1.8-2.504C1.274.928.538 2 .538 3.608c0 1.56.576 2.504 1.8 2.504zM1.61 3.408c0-1.008.24-1.568.776-1.568.376 0 .616.336.728.888l-1.504.776v-.096zM2.418 5.2c-.368 0-.608-.32-.72-.856l1.496-.768v.056c0 1.008-.24 1.568-.776 1.568zm7.03.8l.088-.944H8.36V.896L7.272.984v.592l-1.184.112.024.824h1.16v2.544h-1.32V6zm5.199 0l.088-.944h-1.176V.896L12.47.984v.592l-1.184.112.024.824h1.16v2.544h-1.32V6zM4.25 14l.088-.944H3.162v-4.16l-1.088.088v.592L.89 9.688l.024.824h1.16v2.544H.754V14zm5.198 0l.088-.944H8.36v-4.16l-1.088.088v.592l-1.184.112.024.824h1.16v2.544h-1.32V14zm3.287.112c1.192 0 1.928-1.072 1.928-2.68 0-1.56-.576-2.504-1.8-2.504-1.192 0-1.928 1.072-1.928 2.68 0 1.56.576 2.504 1.8 2.504zm-.728-2.704c0-1.008.24-1.568.776-1.568.376 0 .616.336.728.888l-1.504.776v-.096zm.808 1.792c-.368 0-.608-.32-.72-.856l1.496-.768v.056c0 1.008-.24 1.568-.776 1.568z",
    transform: "translate(16 11)",
    fillRule: "evenodd"
  }),
  code: import_react12.default.createElement("path", {
    d: "M4.078 13.67c-1.875-.527-2.812-1.738-2.812-3.634V9.49C1.266 8.437.844 7.911 0 7.911V6.138c.844 0 1.266-.529 1.266-1.586v-.64c.015-.938.257-1.696.726-2.274C2.466 1.06 3.162.64 4.078.38l.492 1.375c-.656.25-.997.95-1.023 2.102v.695c0 1.167-.482 1.99-1.445 2.469.963.479 1.445 1.304 1.445 2.476v.688c.026 1.15.367 1.851 1.023 2.101l-.492 1.383zm7.844 0c1.875-.527 2.812-1.738 2.812-3.634V9.49c0-1.052.422-1.578 1.266-1.578V6.138c-.844 0-1.266-.529-1.266-1.586v-.64c-.015-.938-.257-1.696-.726-2.274-.474-.578-1.17-.998-2.086-1.258l-.492 1.375c.656.25.997.95 1.023 2.102v.695c0 1.167.482 1.99 1.445 2.469-.963.479-1.445 1.304-1.445 2.476v.688c-.026 1.15-.367 1.851-1.023 2.101l.492 1.383z",
    transform: "translate(16 13)",
    fillRule: "evenodd"
  }),
  code2: import_react12.default.createElement("path", {
    d: "M7.4 10.6L2.8 6l4.6-4.6L6 0 0 6l6 6 1.4-1.4zm5.2 0L17.2 6l-4.6-4.6L14 0l6 6-6 6-1.4-1.4z",
    transform: "translate(14 14)",
    fillRule: "evenodd"
  }),
  compressed: import_react12.default.createElement("path", {
    d: "M.25 0A.25.25 0 0 0 0 .25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 1.75V.25A.25.25 0 0 0 1.75 0H.25zM1 17a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1H1zm0 4v3h2v-3H1zM2 2.25A.25.25 0 0 1 2.25 2h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5A.25.25 0 0 1 2 3.75v-1.5zM.25 4a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 5.75v-1.5A.25.25 0 0 0 1.75 4H.25zM2 6.25A.25.25 0 0 1 2.25 6h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5A.25.25 0 0 1 2 7.75v-1.5zM.25 8a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5A.25.25 0 0 0 2 9.75v-1.5A.25.25 0 0 0 1.75 8H.25zM2 10.25a.25.25 0 0 1 .25-.25h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5a.25.25 0 0 1-.25-.25v-1.5zM.25 12a.25.25 0 0 0-.25.25v1.5c0 .138.112.25.25.25h1.5a.25.25 0 0 0 .25-.25v-1.5a.25.25 0 0 0-.25-.25H.25zM2 14.25a.25.25 0 0 1 .25-.25h1.5a.25.25 0 0 1 .25.25v1.5a.25.25 0 0 1-.25.25h-1.5a.25.25 0 0 1-.25-.25v-1.5z",
    transform: "translate(15 1)",
    fillRule: "evenodd"
  }),
  document: import_react12.default.createElement("path", {
    d: "M12 4H0v2h12V4zM0 10h18V8H0v2zM0 0v2h18V0H0z",
    transform: "translate(15 15)",
    fillRule: "evenodd"
  }),
  drive: import_react12.default.createElement("path", {
    d: "M2.199.289A.5.5 0 0 1 2.652 0h8.696a.5.5 0 0 1 .453.289l1.867 4a.5.5 0 0 1-.453.711H.785a.5.5 0 0 1-.453-.711l1.867-4zM13 6H1a.752.752 0 0 0-.75.75v4.5c0 .412.338.75.75.75h12c.412 0 .75-.338.75-.75v-4.5A.752.752 0 0 0 13 6zm-9.75 4.5c-.825 0-1.5-.675-1.5-1.5s.675-1.5 1.5-1.5 1.5.675 1.5 1.5-.675 1.5-1.5 1.5z",
    transform: "translate(17 13)",
    fillRule: "evenodd"
  }),
  font: import_react12.default.createElement("path", {
    d: "M3.722 8.702l-.686 1.89c-.053.14-.094.28-.123.421-.03.135-.044.252-.044.352 0 .304.097.527.29.668.2.14.501.21.905.21h.414V13H.083v-.756h.343c.176 0 .325-.018.448-.053a.81.81 0 0 0 .334-.22c.1-.105.193-.249.281-.43.094-.182.197-.416.308-.704L5.787.15h1.406l4.07 11.136c.07.187.14.343.21.466.077.123.165.222.264.298.1.07.214.12.343.15.129.03.281.044.457.044h.237V13H7.826v-.756h.413c.72 0 1.081-.287 1.081-.862 0-.1-.014-.202-.044-.307a3.274 3.274 0 0 0-.105-.36l-.72-2.013H3.72zM7.009 4.65c-.188-.533-.36-1.031-.519-1.494a15.92 15.92 0 0 1-.378-1.354 7.12 7.12 0 0 1-.15.633 16.95 16.95 0 0 1-.395 1.283c-.082.229-.175.484-.28.765L4.063 7.796h4.061L7.009 4.65zm8.411 5.74c0 .562.117.984.351 1.265.24.275.61.413 1.108.413.363 0 .691-.059.984-.176.3-.117.551-.284.756-.5.211-.218.372-.481.483-.792.112-.31.168-.656.168-1.037V8.104l-1.152.053c-.51.023-.937.088-1.283.193-.34.1-.615.243-.826.43a1.546 1.546 0 0 0-.457.678c-.088.27-.132.58-.132.931zm2.18-6.32c-.346 0-.627.05-.844.15a1.182 1.182 0 0 0-.501.404 1.594 1.594 0 0 0-.237.624c-.041.24-.062.5-.062.782-.498 0-.879-.085-1.143-.255-.257-.17-.386-.463-.386-.879 0-.31.085-.574.255-.79.17-.218.401-.393.694-.528.299-.14.644-.243 1.037-.308a7.76 7.76 0 0 1 1.257-.097c.55 0 1.031.056 1.441.167.41.106.753.282 1.029.528.275.246.48.568.615.967.14.392.21.876.21 1.45v4.667c0 .252.021.46.062.624a.928.928 0 0 0 .194.395c.088.1.202.17.343.211.146.041.319.062.518.062h.053V13H19.7l-.281-1.547h-.15c-.187.252-.369.483-.544.694-.176.211-.37.393-.58.545-.211.152-.452.27-.721.352a3.053 3.053 0 0 1-.958.131c-.399 0-.77-.058-1.116-.175a2.369 2.369 0 0 1-.888-.519 2.516 2.516 0 0 1-.58-.896c-.14-.364-.211-.791-.211-1.284 0-.955.34-1.664 1.02-2.127.68-.462 1.707-.714 3.084-.755l1.495-.053V6.285a6.93 6.93 0 0 0-.053-.888 1.778 1.778 0 0 0-.229-.703 1.14 1.14 0 0 0-.51-.457c-.216-.111-.51-.167-.878-.167z",
    transform: "translate(13 12)",
    fillRule: "evenodd"
  }),
  image: import_react12.default.createElement("path", {
    d: "M13 0L9.25 5l2.85 3.8-1.6 1.2C8.81 7.75 6 4 6 4l-6 8h22L13 0z",
    transform: "translate(13 14)",
    fillRule: "evenodd"
  }),
  presentation: import_react12.default.createElement("path", {
    d: "M2 4H0v10c0 1.1.9 2 2 2h14v-2H2V4zm16-4H6C4.9 0 4 .9 4 2v8c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V2c0-1.1-.9-2-2-2zm0 10H6V2h12v8z",
    transform: "matrix(-1 0 0 1 34 12)",
    fillRule: "evenodd"
  }),
  settings: import_react12.default.createElement("path", {
    d: "M13.572 8.735c.03-.24.053-.48.053-.735s-.023-.495-.053-.735l1.583-1.237a.378.378 0 0 0 .09-.48l-1.5-2.595a.377.377 0 0 0-.457-.165l-1.868.75a5.48 5.48 0 0 0-1.268-.735L9.868.815A.366.366 0 0 0 9.5.5h-3a.366.366 0 0 0-.367.315l-.285 1.988a5.762 5.762 0 0 0-1.268.735l-1.868-.75a.366.366 0 0 0-.457.165l-1.5 2.595a.37.37 0 0 0 .09.48l1.583 1.237c-.03.24-.053.488-.053.735 0 .248.022.495.053.735L.845 9.973a.378.378 0 0 0-.09.48l1.5 2.595c.09.165.292.225.458.165l1.867-.75c.39.3.81.547 1.268.735l.285 1.987c.022.18.18.315.367.315h3a.366.366 0 0 0 .367-.315l.285-1.988a5.762 5.762 0 0 0 1.268-.734l1.867.75c.173.067.368 0 .458-.165l1.5-2.595a.378.378 0 0 0-.09-.48l-1.582-1.238zM8 10.625A2.628 2.628 0 0 1 5.375 8 2.628 2.628 0 0 1 8 5.375 2.628 2.628 0 0 1 10.625 8 2.628 2.628 0 0 1 8 10.625z",
    transform: "translate(16 11)",
    fillRule: "evenodd"
  }),
  spreadsheet: import_react12.default.createElement("path", {
    d: "M0 8h6V5H0v3zm0 5h6v-3H0v3zM0 3h6V0H0v3zm8 5h12V5H8v3zm0 5h12v-3H8v3zM8 0v3h12V0H8z",
    transform: "translate(14 14)",
    fillRule: "evenodd"
  }),
  vector: import_react12.default.createElement("path", {
    d: "M14.5 2V1a1 1 0 0 0-1-1h-3a1 1 0 0 0-1 1v1H3.937a2 2 0 1 0 0 1h3.936A9 9 0 0 0 3 11v1h2v-1a7.003 7.003 0 0 1 4.594-6.576A1 1 0 0 0 10.5 5h3a1 1 0 0 0 .906-.576A7.003 7.003 0 0 1 19 11v1h2v-1a9 9 0 0 0-4.873-8h3.936a2 2 0 1 0 0-1H14.5zm-1-1h-3v3h3V1zM2 1.5a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm19 1a1 1 0 1 0 2 0 1 1 0 0 0-2 0z",
    transform: "translate(12 14)",
    fillRule: "evenodd"
  }),
  video: import_react12.default.createElement("path", {
    d: "M10.75 3.875V1.25A.752.752 0 0 0 10 .5H1a.752.752 0 0 0-.75.75v7.5c0 .412.338.75.75.75h9c.412 0 .75-.338.75-.75V6.125l3 3V.875l-3 3z",
    transform: "translate(17 14)"
  })
};
k([names_default]);
var propTypes = {
  /** Color of icon background */
  color: import_prop_types.default.string,
  /** Text to display in label */
  extension: import_prop_types.default.string,
  /** Displays the corner fold */
  fold: import_prop_types.default.bool,
  /** Color of the corner fold */
  foldColor: import_prop_types.default.string,
  /** Color of file type icon */
  glyphColor: import_prop_types.default.string,
  /** Color of page gradient */
  gradientColor: import_prop_types.default.string,
  /** Opacity of page gradient */
  gradientOpacity: import_prop_types.default.number,
  /** Color of label */
  labelColor: import_prop_types.default.string,
  /** Color of label text */
  labelTextColor: import_prop_types.default.string,
  /** Displays the label in all caps */
  labelUppercase: import_prop_types.default.bool,
  /** Corner radius of the file icon */
  radius: import_prop_types.default.number,
  /** Type of glyph icon to display */
  type: import_prop_types.default.oneOf(["3d", "acrobat", "android", "audio", "binary", "code", "code2", "compressed", "document", "drive", "font", "image", "presentation", "settings", "spreadsheet", "vector", "video"])
};
var VIEWBOX = {
  WIDTH: 40,
  HEIGHT: 48
};
var ICON = {
  WIDTH: VIEWBOX.WIDTH,
  HEIGHT: VIEWBOX.HEIGHT,
  X_OFFSET: 0
};
var FOLD = {
  HEIGHT: 12
};
var LABEL_HEIGHT = 14;
var useId = import_react12.default.useId || /* @__PURE__ */ function() {
  var i3 = 0;
  return function() {
    return i3++;
  };
}();
var FileIcon = function FileIcon2(_ref3) {
  var _ref$color = _ref3.color, color = _ref$color === void 0 ? "whitesmoke" : _ref$color, extension = _ref3.extension, _ref$fold = _ref3.fold, fold = _ref$fold === void 0 ? true : _ref$fold, foldColor = _ref3.foldColor, glyphColor = _ref3.glyphColor, _ref$gradientColor = _ref3.gradientColor, gradientColor = _ref$gradientColor === void 0 ? "white" : _ref$gradientColor, _ref$gradientOpacity = _ref3.gradientOpacity, gradientOpacity = _ref$gradientOpacity === void 0 ? 0.25 : _ref$gradientOpacity, labelColor = _ref3.labelColor, _ref$labelTextColor = _ref3.labelTextColor, labelTextColor = _ref$labelTextColor === void 0 ? "white" : _ref$labelTextColor, _ref$labelUppercase = _ref3.labelUppercase, labelUppercase = _ref$labelUppercase === void 0 ? false : _ref$labelUppercase, _ref$radius = _ref3.radius, radius = _ref$radius === void 0 ? 4 : _ref$radius, type = _ref3.type;
  var id = useId();
  var UNIQUE_ID = typeof jest === "undefined" ? id : "";
  return import_react12.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 " + VIEWBOX.WIDTH + " " + VIEWBOX.HEIGHT,
    width: "100%",
    style: {
      maxWidth: "100%"
    }
  }, import_react12.default.createElement("defs", null, import_react12.default.createElement("clipPath", {
    id: "pageRadius" + UNIQUE_ID
  }, import_react12.default.createElement("rect", {
    x: ICON.X_OFFSET,
    y: "0",
    rx: radius,
    ry: radius,
    width: ICON.WIDTH,
    height: ICON.HEIGHT
  })), import_react12.default.createElement("clipPath", {
    id: "foldCrop" + UNIQUE_ID
  }, import_react12.default.createElement("rect", {
    width: ICON.WIDTH,
    height: FOLD.HEIGHT,
    transform: "rotate(-45 0 " + FOLD.HEIGHT + ")"
  })), import_react12.default.createElement("linearGradient", {
    x1: "100%",
    y1: "0%",
    y2: "100%",
    id: "pageGradient" + UNIQUE_ID
  }, import_react12.default.createElement("stop", {
    stopColor: gradientColor,
    stopOpacity: gradientOpacity,
    offset: "0%"
  }), import_react12.default.createElement("stop", {
    stopColor: gradientColor,
    stopOpacity: "0",
    offset: "66.67%"
  }))), import_react12.default.createElement("g", {
    id: "file",
    clipPath: "url(#pageRadius" + UNIQUE_ID + ")"
  }, fold ? import_react12.default.createElement(import_react12.default.Fragment, null, import_react12.default.createElement("path", {
    d: "M" + ICON.X_OFFSET + " 0 h " + (ICON.WIDTH - FOLD.HEIGHT) + " L " + (ICON.WIDTH + ICON.X_OFFSET) + " " + FOLD.HEIGHT + " v " + (ICON.HEIGHT - FOLD.HEIGHT) + " H " + ICON.X_OFFSET + " Z",
    fill: color
  }), import_react12.default.createElement("path", {
    d: "M" + ICON.X_OFFSET + " 0 h " + (ICON.WIDTH - FOLD.HEIGHT) + " L " + (ICON.WIDTH + ICON.X_OFFSET) + " " + FOLD.HEIGHT + " v " + (ICON.HEIGHT - FOLD.HEIGHT) + " H " + ICON.X_OFFSET + " Z",
    fill: "url(#pageGradient" + UNIQUE_ID + ")"
  })) : import_react12.default.createElement(import_react12.default.Fragment, null, import_react12.default.createElement("rect", {
    x: ICON.X_OFFSET,
    y: "0",
    width: ICON.WIDTH,
    height: ICON.HEIGHT,
    fill: color
  }), import_react12.default.createElement("rect", {
    x: ICON.X_OFFSET,
    y: "0",
    width: ICON.WIDTH,
    height: ICON.HEIGHT,
    fill: "url(#pageGradient" + UNIQUE_ID + ")"
  }))), fold && import_react12.default.createElement("g", {
    transform: "translate(28 " + FOLD.HEIGHT + ") rotate(-90)"
  }, import_react12.default.createElement("rect", {
    width: ICON.WIDTH,
    height: ICON.HEIGHT,
    fill: foldColor || w2(color).darken(0.1).toHex(),
    rx: radius,
    ry: radius,
    clipPath: "url(#foldCrop" + UNIQUE_ID + ")"
  })), extension && import_react12.default.createElement(import_react12.default.Fragment, null, import_react12.default.createElement("g", {
    id: "label" + UNIQUE_ID
  }, import_react12.default.createElement("rect", {
    fill: labelColor || w2(color).darken(0.3).toHex(),
    x: ICON.X_OFFSET,
    y: ICON.HEIGHT - LABEL_HEIGHT,
    width: ICON.WIDTH,
    height: LABEL_HEIGHT,
    clipPath: "url(#pageRadius" + UNIQUE_ID + ")"
  })), import_react12.default.createElement("g", {
    id: "labelText" + UNIQUE_ID,
    transform: "translate(" + ICON.X_OFFSET + " 34)"
  }, import_react12.default.createElement("text", {
    x: ICON.WIDTH / 2,
    y: "10",
    fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    fontSize: "9",
    fill: labelTextColor,
    textAnchor: "middle",
    style: {
      fontWeight: "bold",
      textAlign: "center",
      pointerEvents: "none",
      textTransform: labelUppercase ? "uppercase" : "none",
      userSelect: "none"
    }
  }, extension))), type && import_react12.default.createElement("g", {
    transform: "translate(-4 " + (!extension ? 6 : 0) + ")",
    fill: glyphColor || w2(color).darken(0.15).toHex()
  }, glyphs[type]));
};
FileIcon.propTypes = propTypes;
var defaultStyles2 = {
  "3dm": {
    labelColor: "#8D1A11",
    type: "3d"
  },
  "3ds": {
    labelColor: "#5FB9AD",
    type: "3d"
  },
  "3g2": {
    type: "video"
  },
  "3gp": {
    type: "video"
  },
  "7zip": {
    type: "compressed"
  },
  aab: {
    type: "android",
    labelColor: "#3DDC84"
  },
  aac: {
    type: "audio"
  },
  aep: {
    type: "video"
  },
  ai: {
    color: "#423325",
    gradientOpacity: 0,
    labelColor: "#423325",
    labelTextColor: "#FF7F18",
    labelUppercase: true,
    foldColor: "#FF7F18",
    radius: 2
  },
  aif: {
    type: "audio"
  },
  aiff: {
    type: "audio"
  },
  apk: {
    type: "android",
    labelColor: "#3DDC84"
  },
  apkm: {
    type: "android",
    labelColor: "#3DDC84"
  },
  apks: {
    type: "android",
    labelColor: "#3DDC84"
  },
  asf: {
    type: "video"
  },
  asp: {
    type: "code"
  },
  aspx: {
    type: "code"
  },
  avi: {
    type: "video"
  },
  bin: {
    type: "binary"
  },
  bmp: {
    type: "image"
  },
  c: {
    type: "code"
  },
  cpp: {
    type: "code"
  },
  cs: {
    type: "code"
  },
  css: {
    type: "code"
  },
  csv: {
    type: "spreadsheet"
  },
  cue: {
    type: "document"
  },
  dll: {
    type: "settings"
  },
  dmg: {
    type: "drive"
  },
  doc: {
    color: "#2C5898",
    foldColor: "#254A80",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#2C5898",
    labelUppercase: true,
    type: "document"
  },
  docx: {
    color: "#2C5898",
    foldColor: "#254A80",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#2C5898",
    labelUppercase: true,
    type: "document"
  },
  dwg: {
    type: "vector"
  },
  dxf: {
    type: "vector"
  },
  eot: {
    type: "font"
  },
  eps: {
    type: "vector"
  },
  exe: {
    type: "settings"
  },
  flac: {
    type: "audio"
  },
  flv: {
    type: "video"
  },
  fnt: {
    type: "font"
  },
  fodp: {
    type: "presentation"
  },
  fods: {
    type: "spreadsheet"
  },
  fodt: {
    type: "document"
  },
  fon: {
    type: "font"
  },
  gif: {
    type: "image"
  },
  gz: {
    type: "compressed"
  },
  heic: {
    type: "image"
  },
  htm: {
    type: "code"
  },
  html: {
    type: "code"
  },
  indd: {
    color: "#4B2B36",
    gradientOpacity: 0,
    labelColor: "#4B2B36",
    labelTextColor: "#FF408C",
    labelUppercase: true,
    foldColor: "#FF408C",
    radius: 2
  },
  ini: {
    type: "settings"
  },
  java: {
    type: "code"
  },
  jpeg: {
    type: "image"
  },
  jpg: {
    type: "image"
  },
  js: {
    labelColor: "#F7DF1E",
    type: "code"
  },
  json: {
    type: "code"
  },
  jsx: {
    labelColor: "#00D8FF",
    type: "code"
  },
  m4a: {
    type: "audio"
  },
  m4v: {
    type: "video"
  },
  max: {
    labelColor: "#5FB9AD",
    type: "3d"
  },
  md: {
    type: "document"
  },
  mid: {
    type: "audio"
  },
  mkv: {
    type: "video"
  },
  mov: {
    type: "video"
  },
  mp3: {
    type: "audio"
  },
  mp4: {
    type: "video"
  },
  mpeg: {
    type: "video"
  },
  mpg: {
    type: "video"
  },
  obj: {
    type: "3d"
  },
  odp: {
    type: "presentation"
  },
  ods: {
    type: "spreadsheet"
  },
  odt: {
    type: "document"
  },
  ogg: {
    type: "audio"
  },
  ogv: {
    type: "video"
  },
  otf: {
    type: "font"
  },
  pdf: {
    labelColor: "#D93831",
    type: "acrobat"
  },
  php: {
    labelColor: "#8892BE",
    type: "code"
  },
  pkg: {
    type: "3d"
  },
  plist: {
    type: "settings"
  },
  png: {
    type: "image"
  },
  ppt: {
    color: "#D14423",
    foldColor: "#AB381D",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#D14423",
    labelUppercase: true,
    type: "presentation"
  },
  pptx: {
    color: "#D14423",
    foldColor: "#AB381D",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#D14423",
    labelUppercase: true,
    type: "presentation"
  },
  pr: {
    type: "video"
  },
  ps: {
    type: "vector"
  },
  psd: {
    color: "#34364E",
    gradientOpacity: 0,
    labelColor: "#34364E",
    labelTextColor: "#31C5F0",
    labelUppercase: true,
    foldColor: "#31C5F0",
    radius: 2
  },
  py: {
    labelColor: "#FFDE57",
    type: "code"
  },
  rar: {
    type: "compressed"
  },
  rb: {
    labelColor: "#BB271A",
    type: "code"
  },
  rm: {
    type: "video"
  },
  rtf: {
    type: "document"
  },
  scss: {
    labelColor: "#C16A98",
    type: "code"
  },
  sitx: {
    type: "compressed"
  },
  skp: {
    type: "3d"
  },
  svg: {
    type: "vector"
  },
  swf: {
    type: "video"
  },
  sys: {
    type: "settings"
  },
  tar: {
    type: "compressed"
  },
  tex: {
    type: "document"
  },
  tif: {
    type: "image"
  },
  tiff: {
    type: "image"
  },
  ts: {
    labelColor: "#3478C7",
    type: "code"
  },
  ttf: {
    type: "font"
  },
  txt: {
    type: "document"
  },
  wav: {
    type: "audio"
  },
  webm: {
    type: "video"
  },
  wmv: {
    type: "video"
  },
  woff: {
    type: "font"
  },
  wpd: {
    type: "document"
  },
  wps: {
    type: "document"
  },
  xapk: {
    type: "android",
    labelColor: "#3DDC84"
  },
  xlr: {
    type: "spreadsheet"
  },
  xls: {
    color: "#1A754C",
    foldColor: "#16613F",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#1A754C",
    labelUppercase: true,
    type: "spreadsheet"
  },
  xlsx: {
    color: "#1A754C",
    foldColor: "#16613F",
    glyphColor: "rgba(255,255,255,0.4)",
    labelColor: "#1A754C",
    labelUppercase: true,
    type: "spreadsheet"
  },
  yml: {
    type: "code"
  },
  zip: {
    type: "compressed"
  },
  zipx: {
    type: "compressed"
  }
};

// node_modules/react-select/creatable/dist/react-select-creatable.esm.js
var React10 = __toESM(require_react());
var import_react14 = __toESM(require_react());

// node_modules/react-select/dist/useCreatable-84008237.esm.js
var import_react13 = __toESM(require_react());
var _excluded5 = ["allowCreateWhileLoading", "createOptionPosition", "formatCreateLabel", "isValidNewOption", "getNewOptionData", "onCreateOption", "options", "onChange"];
var compareOption = function compareOption2() {
  var inputValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  var option = arguments.length > 1 ? arguments[1] : void 0;
  var accessors = arguments.length > 2 ? arguments[2] : void 0;
  var candidate = String(inputValue).toLowerCase();
  var optionValue = String(accessors.getOptionValue(option)).toLowerCase();
  var optionLabel = String(accessors.getOptionLabel(option)).toLowerCase();
  return optionValue === candidate || optionLabel === candidate;
};
var builtins = {
  formatCreateLabel: function formatCreateLabel(inputValue) {
    return 'Create "'.concat(inputValue, '"');
  },
  isValidNewOption: function isValidNewOption(inputValue, selectValue, selectOptions, accessors) {
    return !(!inputValue || selectValue.some(function(option) {
      return compareOption(inputValue, option, accessors);
    }) || selectOptions.some(function(option) {
      return compareOption(inputValue, option, accessors);
    }));
  },
  getNewOptionData: function getNewOptionData(inputValue, optionLabel) {
    return {
      label: optionLabel,
      value: inputValue,
      __isNew__: true
    };
  }
};
function useCreatable(_ref3) {
  var _ref$allowCreateWhile = _ref3.allowCreateWhileLoading, allowCreateWhileLoading = _ref$allowCreateWhile === void 0 ? false : _ref$allowCreateWhile, _ref$createOptionPosi = _ref3.createOptionPosition, createOptionPosition = _ref$createOptionPosi === void 0 ? "last" : _ref$createOptionPosi, _ref$formatCreateLabe = _ref3.formatCreateLabel, formatCreateLabel2 = _ref$formatCreateLabe === void 0 ? builtins.formatCreateLabel : _ref$formatCreateLabe, _ref$isValidNewOption = _ref3.isValidNewOption, isValidNewOption2 = _ref$isValidNewOption === void 0 ? builtins.isValidNewOption : _ref$isValidNewOption, _ref$getNewOptionData = _ref3.getNewOptionData, getNewOptionData2 = _ref$getNewOptionData === void 0 ? builtins.getNewOptionData : _ref$getNewOptionData, onCreateOption = _ref3.onCreateOption, _ref$options = _ref3.options, propsOptions = _ref$options === void 0 ? [] : _ref$options, propsOnChange = _ref3.onChange, restSelectProps = _objectWithoutProperties(_ref3, _excluded5);
  var _restSelectProps$getO = restSelectProps.getOptionValue, getOptionValue$12 = _restSelectProps$getO === void 0 ? getOptionValue$1 : _restSelectProps$getO, _restSelectProps$getO2 = restSelectProps.getOptionLabel, getOptionLabel$12 = _restSelectProps$getO2 === void 0 ? getOptionLabel$1 : _restSelectProps$getO2, inputValue = restSelectProps.inputValue, isLoading = restSelectProps.isLoading, isMulti = restSelectProps.isMulti, value = restSelectProps.value, name = restSelectProps.name;
  var newOption = (0, import_react13.useMemo)(function() {
    return isValidNewOption2(inputValue, cleanValue(value), propsOptions, {
      getOptionValue: getOptionValue$12,
      getOptionLabel: getOptionLabel$12
    }) ? getNewOptionData2(inputValue, formatCreateLabel2(inputValue)) : void 0;
  }, [formatCreateLabel2, getNewOptionData2, getOptionLabel$12, getOptionValue$12, inputValue, isValidNewOption2, propsOptions, value]);
  var options2 = (0, import_react13.useMemo)(function() {
    return (allowCreateWhileLoading || !isLoading) && newOption ? createOptionPosition === "first" ? [newOption].concat(_toConsumableArray(propsOptions)) : [].concat(_toConsumableArray(propsOptions), [newOption]) : propsOptions;
  }, [allowCreateWhileLoading, createOptionPosition, isLoading, newOption, propsOptions]);
  var onChange2 = (0, import_react13.useCallback)(function(newValue, actionMeta) {
    if (actionMeta.action !== "select-option") {
      return propsOnChange(newValue, actionMeta);
    }
    var valueArray = Array.isArray(newValue) ? newValue : [newValue];
    if (valueArray[valueArray.length - 1] === newOption) {
      if (onCreateOption) onCreateOption(inputValue);
      else {
        var newOptionData = getNewOptionData2(inputValue, inputValue);
        var newActionMeta = {
          action: "create-option",
          name,
          option: newOptionData
        };
        propsOnChange(valueTernary(isMulti, [].concat(_toConsumableArray(cleanValue(value)), [newOptionData]), newOptionData), newActionMeta);
      }
      return;
    }
    propsOnChange(newValue, actionMeta);
  }, [getNewOptionData2, inputValue, isMulti, name, newOption, onCreateOption, propsOnChange, value]);
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    options: options2,
    onChange: onChange2
  });
}

// node_modules/react-select/creatable/dist/react-select-creatable.esm.js
var import_react_dom4 = __toESM(require_react_dom());
var CreatableSelect = (0, import_react14.forwardRef)(function(props, ref) {
  var creatableProps = useStateManager(props);
  var selectProps = useCreatable(creatableProps);
  return React10.createElement(Select, _extends({
    ref
  }, selectProps));
});
var CreatableSelect$1 = CreatableSelect;

// node_modules/sanity-plugin-media/node_modules/date-fns/formatRelative.js
function formatRelative2(date, baseDate, options2) {
  var _a, _b, _c, _d;
  const [date_, baseDate_] = normalizeDates(options2 == null ? void 0 : options2.in, date, baseDate);
  const defaultOptions3 = getDefaultOptions();
  const locale = (options2 == null ? void 0 : options2.locale) ?? defaultOptions3.locale ?? enUS;
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const diff = differenceInCalendarDays(date_, baseDate_);
  if (isNaN(diff)) {
    throw new RangeError("Invalid time value");
  }
  let token2;
  if (diff < -6) {
    token2 = "other";
  } else if (diff < -1) {
    token2 = "lastWeek";
  } else if (diff < 0) {
    token2 = "yesterday";
  } else if (diff < 1) {
    token2 = "today";
  } else if (diff < 2) {
    token2 = "tomorrow";
  } else if (diff < 7) {
    token2 = "nextWeek";
  } else {
    token2 = "other";
  }
  const formatStr = locale.formatRelative(token2, date_, baseDate_, {
    locale,
    weekStartsOn
  });
  return format(date_, formatStr, { locale, weekStartsOn });
}
var formatRelative_default = formatRelative2;

// node_modules/react-dropzone/dist/es/index.js
var import_react16 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/file-selector/dist/es5/file.js
var COMMON_MIME_TYPES = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function toFileWithPath(file, path) {
  var f2 = withMimeType(file);
  if (typeof f2.path !== "string") {
    var webkitRelativePath = file.webkitRelativePath;
    Object.defineProperty(f2, "path", {
      value: typeof path === "string" ? path : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
      writable: false,
      configurable: false,
      enumerable: true
    });
  }
  return f2;
}
function withMimeType(file) {
  var name = file.name;
  var hasExtension = name && name.lastIndexOf(".") !== -1;
  if (hasExtension && !file.type) {
    var ext = name.split(".").pop().toLowerCase();
    var type = COMMON_MIME_TYPES.get(ext);
    if (type) {
      Object.defineProperty(file, "type", {
        value: type,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }
  }
  return file;
}

// node_modules/file-selector/dist/es5/file-selector.js
var FILES_TO_IGNORE = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function fromEvent(evt) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      if (isObject2(evt) && isDataTransfer(evt)) {
        return [2, getDataTransferFiles(evt.dataTransfer, evt.type)];
      } else if (isChangeEvt(evt)) {
        return [2, getInputFiles(evt)];
      } else if (Array.isArray(evt) && evt.every(function(item) {
        return "getFile" in item && typeof item.getFile === "function";
      })) {
        return [2, getFsHandleFiles(evt)];
      }
      return [2, []];
    });
  });
}
function isDataTransfer(value) {
  return isObject2(value.dataTransfer);
}
function isChangeEvt(value) {
  return isObject2(value) && isObject2(value.target);
}
function isObject2(v2) {
  return typeof v2 === "object" && v2 !== null;
}
function getInputFiles(evt) {
  return fromList(evt.target.files).map(function(file) {
    return toFileWithPath(file);
  });
}
function getFsHandleFiles(handles) {
  return __awaiter(this, void 0, void 0, function() {
    var files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, Promise.all(handles.map(function(h2) {
            return h2.getFile();
          }))];
        case 1:
          files = _a.sent();
          return [2, files.map(function(file) {
            return toFileWithPath(file);
          })];
      }
    });
  });
}
function getDataTransferFiles(dt2, type) {
  return __awaiter(this, void 0, void 0, function() {
    var items, files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (dt2 === null) {
            return [2, []];
          }
          if (!dt2.items) return [3, 2];
          items = fromList(dt2.items).filter(function(item) {
            return item.kind === "file";
          });
          if (type !== "drop") {
            return [2, items];
          }
          return [4, Promise.all(items.map(toFilePromises))];
        case 1:
          files = _a.sent();
          return [2, noIgnoredFiles(flatten(files))];
        case 2:
          return [2, noIgnoredFiles(fromList(dt2.files).map(function(file) {
            return toFileWithPath(file);
          }))];
      }
    });
  });
}
function noIgnoredFiles(files) {
  return files.filter(function(file) {
    return FILES_TO_IGNORE.indexOf(file.name) === -1;
  });
}
function fromList(items) {
  if (items === null) {
    return [];
  }
  var files = [];
  for (var i3 = 0; i3 < items.length; i3++) {
    var file = items[i3];
    files.push(file);
  }
  return files;
}
function toFilePromises(item) {
  if (typeof item.webkitGetAsEntry !== "function") {
    return fromDataTransferItem(item);
  }
  var entry = item.webkitGetAsEntry();
  if (entry && entry.isDirectory) {
    return fromDirEntry(entry);
  }
  return fromDataTransferItem(item);
}
function flatten(items) {
  return items.reduce(function(acc, files) {
    return __spread(acc, Array.isArray(files) ? flatten(files) : [files]);
  }, []);
}
function fromDataTransferItem(item) {
  var file = item.getAsFile();
  if (!file) {
    return Promise.reject(item + " is not a File");
  }
  var fwp = toFileWithPath(file);
  return Promise.resolve(fwp);
}
function fromEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
    });
  });
}
function fromDirEntry(entry) {
  var reader = entry.createReader();
  return new Promise(function(resolve, reject) {
    var entries = [];
    function readEntries() {
      var _this = this;
      reader.readEntries(function(batch) {
        return __awaiter(_this, void 0, void 0, function() {
          var files, err_1, items;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!batch.length) return [3, 5];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, Promise.all(entries)];
              case 2:
                files = _a.sent();
                resolve(files);
                return [3, 4];
              case 3:
                err_1 = _a.sent();
                reject(err_1);
                return [3, 4];
              case 4:
                return [3, 6];
              case 5:
                items = Promise.all(batch.map(fromEntry));
                entries.push(items);
                readEntries();
                _a.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(err) {
        reject(err);
      });
    }
    readEntries();
  });
}
function fromFileEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve, reject) {
        entry.file(function(file) {
          var fwp = toFileWithPath(file, entry.fullPath);
          resolve(fwp);
        }, function(err) {
          reject(err);
        });
      })];
    });
  });
}

// node_modules/react-dropzone/dist/es/utils/index.js
var import_attr_accept = __toESM(require_es());
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray2(arr, i3) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i3) || _unsupportedIterableToArray2(arr, i3) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray2(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor) n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set") return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray2(o3, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
    arr2[i3] = arr[i3];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i3) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n2 = (_s = _i.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i3 && _arr.length === i3) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr)) return arr;
}
var FILE_INVALID_TYPE = "file-invalid-type";
var FILE_TOO_LARGE = "file-too-large";
var FILE_TOO_SMALL = "file-too-small";
var TOO_MANY_FILES = "too-many-files";
var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr2(accept) {
  accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
  var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(", ")) : accept;
  return {
    code: FILE_INVALID_TYPE,
    message: "File type must be ".concat(messageSuffix)
  };
};
var getTooLargeRejectionErr = function getTooLargeRejectionErr2(maxSize) {
  return {
    code: FILE_TOO_LARGE,
    message: "File is larger than ".concat(maxSize, " ").concat(maxSize === 1 ? "byte" : "bytes")
  };
};
var getTooSmallRejectionErr = function getTooSmallRejectionErr2(minSize) {
  return {
    code: FILE_TOO_SMALL,
    message: "File is smaller than ".concat(minSize, " ").concat(minSize === 1 ? "byte" : "bytes")
  };
};
var TOO_MANY_FILES_REJECTION = {
  code: TOO_MANY_FILES,
  message: "Too many files"
};
function fileAccepted(file, accept) {
  var isAcceptable = file.type === "application/x-moz-file" || (0, import_attr_accept.default)(file, accept);
  return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
}
function fileMatchSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize) return [false, getTooLargeRejectionErr(maxSize)];
      if (file.size < minSize) return [false, getTooSmallRejectionErr(minSize)];
    } else if (isDefined(minSize) && file.size < minSize) return [false, getTooSmallRejectionErr(minSize)];
    else if (isDefined(maxSize) && file.size > maxSize) return [false, getTooLargeRejectionErr(maxSize)];
  }
  return [true, null];
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function allFilesAccepted(_ref3) {
  var files = _ref3.files, accept = _ref3.accept, minSize = _ref3.minSize, maxSize = _ref3.maxSize, multiple = _ref3.multiple, maxFiles = _ref3.maxFiles;
  if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {
    return false;
  }
  return files.every(function(file) {
    var _fileAccepted = fileAccepted(file, accept), _fileAccepted2 = _slicedToArray2(_fileAccepted, 1), accepted = _fileAccepted2[0];
    var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray2(_fileMatchSize, 1), sizeMatch = _fileMatchSize2[0];
    return accepted && sizeMatch;
  });
}
function isPropagationStopped(event) {
  if (typeof event.isPropagationStopped === "function") {
    return event.isPropagationStopped();
  } else if (typeof event.cancelBubble !== "undefined") {
    return event.cancelBubble;
  }
  return false;
}
function isEvtWithFiles(event) {
  if (!event.dataTransfer) {
    return !!event.target && !!event.target.files;
  }
  return Array.prototype.some.call(event.dataTransfer.types, function(type) {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function onDocumentDragOver(event) {
  event.preventDefault();
}
function isIe(userAgent) {
  return userAgent.indexOf("MSIE") !== -1 || userAgent.indexOf("Trident/") !== -1;
}
function isEdge(userAgent) {
  return userAgent.indexOf("Edge/") !== -1;
}
function isIeOrEdge() {
  var userAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return isIe(userAgent) || isEdge(userAgent);
}
function composeEventHandlers() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return fns.some(function(fn2) {
      if (!isPropagationStopped(event) && fn2) {
        fn2.apply(void 0, [event].concat(args));
      }
      return isPropagationStopped(event);
    });
  };
}
function canUseFileSystemAccessAPI() {
  return "showOpenFilePicker" in window;
}
function filePickerOptionsTypes(accept) {
  accept = typeof accept === "string" ? accept.split(",") : accept;
  return [{
    description: "everything",
    // TODO: Need to handle filtering more elegantly than this!
    accept: Array.isArray(accept) ? accept.filter(function(item) {
      return item === "audio/*" || item === "video/*" || item === "image/*" || item === "text/*" || /\w+\/[-+.\w]+/g.test(item);
    }).reduce(function(a2, b2) {
      return _objectSpread(_objectSpread({}, a2), {}, _defineProperty2({}, b2, []));
    }, {}) : {}
  }];
}

// node_modules/react-dropzone/dist/es/index.js
var _excluded6 = ["children"];
var _excluded22 = ["open"];
var _excluded32 = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"];
var _excluded42 = ["refKey", "onChange", "onClick"];
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray3(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray3(arr);
}
function _slicedToArray3(arr, i3) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i3) || _unsupportedIterableToArray3(arr, i3) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray3(o3, minLen);
  var n3 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n3 === "Object" && o3.constructor) n3 = o3.constructor.name;
  if (n3 === "Map" || n3 === "Set") return Array.from(o3);
  if (n3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return _arrayLikeToArray3(o3, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
    arr2[i3] = arr[i3];
  }
  return arr2;
}
function _iterableToArrayLimit3(arr, i3) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i = _i.call(arr); !(_n2 = (_s = _i.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i3 && _arr.length === i3) break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr)) return arr;
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = null != arguments[i3] ? arguments[i3] : {};
    i3 % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
      key = sourceSymbolKeys[i3];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var Dropzone = (0, import_react16.forwardRef)(function(_ref3, ref) {
  var children = _ref3.children, params = _objectWithoutProperties2(_ref3, _excluded6);
  var _useDropzone = useDropzone(params), open = _useDropzone.open, props = _objectWithoutProperties2(_useDropzone, _excluded22);
  (0, import_react16.useImperativeHandle)(ref, function() {
    return {
      open
    };
  }, [open]);
  return import_react16.default.createElement(import_react16.Fragment, null, children(_objectSpread3(_objectSpread3({}, props), {}, {
    open
  })));
});
Dropzone.displayName = "Dropzone";
var defaultProps2 = {
  disabled: false,
  getFilesFromEvent: fromEvent,
  maxSize: Infinity,
  minSize: 0,
  multiple: true,
  maxFiles: 0,
  preventDropOnDocument: true,
  noClick: false,
  noKeyboard: false,
  noDrag: false,
  noDragEventsBubbling: false,
  validator: null,
  useFsAccessApi: false
};
Dropzone.defaultProps = defaultProps2;
Dropzone.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.draggedFiles Files in active drag
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: import_prop_types2.default.func,
  /**
   * Set accepted file types.
   * See https://github.com/okonet/attr-accept for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all.
   * See: https://github.com/react-dropzone/react-dropzone/issues/276
   */
  accept: import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.arrayOf(import_prop_types2.default.string)]),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: import_prop_types2.default.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: import_prop_types2.default.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: import_prop_types2.default.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: import_prop_types2.default.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: import_prop_types2.default.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: import_prop_types2.default.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: import_prop_types2.default.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: import_prop_types2.default.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: import_prop_types2.default.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: import_prop_types2.default.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: import_prop_types2.default.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: import_prop_types2.default.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: import_prop_types2.default.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: import_prop_types2.default.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: import_prop_types2.default.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: import_prop_types2.default.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: import_prop_types2.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: import_prop_types2.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: import_prop_types2.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: import_prop_types2.default.func,
  /**
   * Custom validation function
   * @param {File} file
   * @returns {FileError|FileError[]}
   */
  validator: import_prop_types2.default.func
};
var initialState2 = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  draggedFiles: [],
  acceptedFiles: [],
  fileRejections: []
};
function useDropzone() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _defaultProps$options = _objectSpread3(_objectSpread3({}, defaultProps2), options2), accept = _defaultProps$options.accept, disabled = _defaultProps$options.disabled, getFilesFromEvent = _defaultProps$options.getFilesFromEvent, maxSize = _defaultProps$options.maxSize, minSize = _defaultProps$options.minSize, multiple = _defaultProps$options.multiple, maxFiles = _defaultProps$options.maxFiles, onDragEnter = _defaultProps$options.onDragEnter, onDragLeave = _defaultProps$options.onDragLeave, onDragOver = _defaultProps$options.onDragOver, onDrop = _defaultProps$options.onDrop, onDropAccepted = _defaultProps$options.onDropAccepted, onDropRejected = _defaultProps$options.onDropRejected, onFileDialogCancel = _defaultProps$options.onFileDialogCancel, onFileDialogOpen = _defaultProps$options.onFileDialogOpen, useFsAccessApi = _defaultProps$options.useFsAccessApi, preventDropOnDocument = _defaultProps$options.preventDropOnDocument, noClick = _defaultProps$options.noClick, noKeyboard = _defaultProps$options.noKeyboard, noDrag = _defaultProps$options.noDrag, noDragEventsBubbling = _defaultProps$options.noDragEventsBubbling, validator = _defaultProps$options.validator;
  var onFileDialogOpenCb = (0, import_react16.useMemo)(function() {
    return typeof onFileDialogOpen === "function" ? onFileDialogOpen : noop6;
  }, [onFileDialogOpen]);
  var onFileDialogCancelCb = (0, import_react16.useMemo)(function() {
    return typeof onFileDialogCancel === "function" ? onFileDialogCancel : noop6;
  }, [onFileDialogCancel]);
  var rootRef = (0, import_react16.useRef)(null);
  var inputRef = (0, import_react16.useRef)(null);
  var _useReducer = (0, import_react16.useReducer)(reducer, initialState2), _useReducer2 = _slicedToArray3(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var isFocused = state.isFocused, isFileDialogActive = state.isFileDialogActive, draggedFiles = state.draggedFiles;
  var onWindowFocus = function onWindowFocus2() {
    if (isFileDialogActive) {
      setTimeout(function() {
        if (inputRef.current) {
          var files = inputRef.current.files;
          if (!files.length) {
            dispatch({
              type: "closeDialog"
            });
            onFileDialogCancelCb();
          }
        }
      }, 300);
    }
  };
  (0, import_react16.useEffect)(function() {
    if (useFsAccessApi && canUseFileSystemAccessAPI()) {
      return function() {
      };
    }
    window.addEventListener("focus", onWindowFocus, false);
    return function() {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [inputRef, isFileDialogActive, onFileDialogCancelCb, useFsAccessApi]);
  var dragTargetsRef = (0, import_react16.useRef)([]);
  var onDocumentDrop = function onDocumentDrop2(event) {
    if (rootRef.current && rootRef.current.contains(event.target)) {
      return;
    }
    event.preventDefault();
    dragTargetsRef.current = [];
  };
  (0, import_react16.useEffect)(function() {
    if (preventDropOnDocument) {
      document.addEventListener("dragover", onDocumentDragOver, false);
      document.addEventListener("drop", onDocumentDrop, false);
    }
    return function() {
      if (preventDropOnDocument) {
        document.removeEventListener("dragover", onDocumentDragOver);
        document.removeEventListener("drop", onDocumentDrop);
      }
    };
  }, [rootRef, preventDropOnDocument]);
  var onDragEnterCb = (0, import_react16.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [].concat(_toConsumableArray2(dragTargetsRef.current), [event.target]);
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(draggedFiles2) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        dispatch({
          draggedFiles: draggedFiles2,
          isDragActive: true,
          type: "setDraggedFiles"
        });
        if (onDragEnter) {
          onDragEnter(event);
        }
      });
    }
  }, [getFilesFromEvent, onDragEnter, noDragEventsBubbling]);
  var onDragOverCb = (0, import_react16.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var hasFiles = isEvtWithFiles(event);
    if (hasFiles && event.dataTransfer) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch (_unused) {
      }
    }
    if (hasFiles && onDragOver) {
      onDragOver(event);
    }
    return false;
  }, [onDragOver, noDragEventsBubbling]);
  var onDragLeaveCb = (0, import_react16.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var targets = dragTargetsRef.current.filter(function(target) {
      return rootRef.current && rootRef.current.contains(target);
    });
    var targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1) {
      targets.splice(targetIdx, 1);
    }
    dragTargetsRef.current = targets;
    if (targets.length > 0) {
      return;
    }
    dispatch({
      isDragActive: false,
      type: "setDraggedFiles",
      draggedFiles: []
    });
    if (isEvtWithFiles(event) && onDragLeave) {
      onDragLeave(event);
    }
  }, [rootRef, onDragLeave, noDragEventsBubbling]);
  var setFiles = (0, import_react16.useCallback)(function(files, event) {
    var acceptedFiles = [];
    var fileRejections = [];
    files.forEach(function(file) {
      var _fileAccepted = fileAccepted(file, accept), _fileAccepted2 = _slicedToArray3(_fileAccepted, 2), accepted = _fileAccepted2[0], acceptError = _fileAccepted2[1];
      var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray3(_fileMatchSize, 2), sizeMatch = _fileMatchSize2[0], sizeError = _fileMatchSize2[1];
      var customErrors = validator ? validator(file) : null;
      if (accepted && sizeMatch && !customErrors) {
        acceptedFiles.push(file);
      } else {
        var errors = [acceptError, sizeError];
        if (customErrors) {
          errors = errors.concat(customErrors);
        }
        fileRejections.push({
          file,
          errors: errors.filter(function(e2) {
            return e2;
          })
        });
      }
    });
    if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {
      acceptedFiles.forEach(function(file) {
        fileRejections.push({
          file,
          errors: [TOO_MANY_FILES_REJECTION]
        });
      });
      acceptedFiles.splice(0);
    }
    dispatch({
      acceptedFiles,
      fileRejections,
      type: "setFiles"
    });
    if (onDrop) {
      onDrop(acceptedFiles, fileRejections, event);
    }
    if (fileRejections.length > 0 && onDropRejected) {
      onDropRejected(fileRejections, event);
    }
    if (acceptedFiles.length > 0 && onDropAccepted) {
      onDropAccepted(acceptedFiles, event);
    }
  }, [dispatch, multiple, accept, minSize, maxSize, maxFiles, onDrop, onDropAccepted, onDropRejected, validator]);
  var onDropCb = (0, import_react16.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [];
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        setFiles(files, event);
      });
    }
    dispatch({
      type: "reset"
    });
  }, [getFilesFromEvent, setFiles, noDragEventsBubbling]);
  var openFileDialog = (0, import_react16.useCallback)(function() {
    if (useFsAccessApi && canUseFileSystemAccessAPI()) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      var opts = {
        multiple,
        types: filePickerOptionsTypes(accept)
      };
      window.showOpenFilePicker(opts).then(function(handles) {
        return getFilesFromEvent(handles);
      }).then(function(files) {
        return setFiles(files, null);
      }).catch(function(e2) {
        return onFileDialogCancelCb(e2);
      }).finally(function() {
        return dispatch({
          type: "closeDialog"
        });
      });
      return;
    }
    if (inputRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      inputRef.current.value = null;
      inputRef.current.click();
    }
  }, [dispatch, onFileDialogOpenCb, onFileDialogCancelCb, useFsAccessApi, setFiles, accept, multiple]);
  var onKeyDownCb = (0, import_react16.useCallback)(function(event) {
    if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {
      return;
    }
    if (event.keyCode === 32 || event.keyCode === 13) {
      event.preventDefault();
      openFileDialog();
    }
  }, [rootRef, inputRef, openFileDialog]);
  var onFocusCb = (0, import_react16.useCallback)(function() {
    dispatch({
      type: "focus"
    });
  }, []);
  var onBlurCb = (0, import_react16.useCallback)(function() {
    dispatch({
      type: "blur"
    });
  }, []);
  var onClickCb = (0, import_react16.useCallback)(function() {
    if (noClick) {
      return;
    }
    if (isIeOrEdge()) {
      setTimeout(openFileDialog, 0);
    } else {
      openFileDialog();
    }
  }, [inputRef, noClick, openFileDialog]);
  var composeHandler = function composeHandler2(fn2) {
    return disabled ? null : fn2;
  };
  var composeKeyboardHandler = function composeKeyboardHandler2(fn2) {
    return noKeyboard ? null : composeHandler(fn2);
  };
  var composeDragHandler = function composeDragHandler2(fn2) {
    return noDrag ? null : composeHandler(fn2);
  };
  var stopPropagation = function stopPropagation2(event) {
    if (noDragEventsBubbling) {
      event.stopPropagation();
    }
  };
  var getRootProps = (0, import_react16.useMemo)(function() {
    return function() {
      var _ref23 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$refKey = _ref23.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, role = _ref23.role, onKeyDown = _ref23.onKeyDown, onFocus2 = _ref23.onFocus, onBlur = _ref23.onBlur, onClick = _ref23.onClick, onDragEnter2 = _ref23.onDragEnter, onDragOver2 = _ref23.onDragOver, onDragLeave2 = _ref23.onDragLeave, onDrop2 = _ref23.onDrop, rest = _objectWithoutProperties2(_ref23, _excluded32);
      return _objectSpread3(_objectSpread3(_defineProperty3({
        onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
        onFocus: composeKeyboardHandler(composeEventHandlers(onFocus2, onFocusCb)),
        onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
        onDragEnter: composeDragHandler(composeEventHandlers(onDragEnter2, onDragEnterCb)),
        onDragOver: composeDragHandler(composeEventHandlers(onDragOver2, onDragOverCb)),
        onDragLeave: composeDragHandler(composeEventHandlers(onDragLeave2, onDragLeaveCb)),
        onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb)),
        role: typeof role === "string" && role !== "" ? role : "button"
      }, refKey, rootRef), !disabled && !noKeyboard ? {
        tabIndex: 0
      } : {}), rest);
    };
  }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled]);
  var onInputElementClick = (0, import_react16.useCallback)(function(event) {
    event.stopPropagation();
  }, []);
  var getInputProps = (0, import_react16.useMemo)(function() {
    return function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, onChange2 = _ref3.onChange, onClick = _ref3.onClick, rest = _objectWithoutProperties2(_ref3, _excluded42);
      var inputProps = _defineProperty3({
        accept,
        multiple,
        type: "file",
        style: {
          display: "none"
        },
        onChange: composeHandler(composeEventHandlers(onChange2, onDropCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
        autoComplete: "off",
        tabIndex: -1
      }, refKey, inputRef);
      return _objectSpread3(_objectSpread3({}, inputProps), rest);
    };
  }, [inputRef, accept, multiple, onDropCb, disabled]);
  var fileCount = draggedFiles.length;
  var isDragAccept = fileCount > 0 && allFilesAccepted({
    files: draggedFiles,
    accept,
    minSize,
    maxSize,
    multiple,
    maxFiles
  });
  var isDragReject = fileCount > 0 && !isDragAccept;
  return _objectSpread3(_objectSpread3({}, state), {}, {
    isDragAccept,
    isDragReject,
    isFocused: isFocused && !disabled,
    getRootProps,
    getInputProps,
    rootRef,
    inputRef,
    open: composeHandler(openFileDialog)
  });
}
function reducer(state, action) {
  switch (action.type) {
    case "focus":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        isFocused: true
      });
    case "blur":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        isFocused: false
      });
    case "openDialog":
      return _objectSpread3(_objectSpread3({}, initialState2), {}, {
        isFileDialogActive: true
      });
    case "closeDialog":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        isFileDialogActive: false
      });
    case "setDraggedFiles":
      var isDragActive = action.isDragActive, draggedFiles = action.draggedFiles;
      return _objectSpread3(_objectSpread3({}, state), {}, {
        draggedFiles,
        isDragActive
      });
    case "setFiles":
      return _objectSpread3(_objectSpread3({}, state), {}, {
        acceptedFiles: action.acceptedFiles,
        fileRejections: action.fileRejections
      });
    case "reset":
      return _objectSpread3({}, initialState2);
    default:
      return state;
  }
}
function noop6() {
}

// node_modules/sanity-plugin-media/dist/index.mjs
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3.default : x3;
}
var lib = {};
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1, Object.defineProperty(lib, "__esModule", {
    value: true
  });
  for (var IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  }, ALIASES = {
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  }, CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  }, f2 = 1; f2 < 20; f2++)
    CODES["f" + f2] = 111 + f2;
  function isHotkey2(hotkey, options2, event) {
    options2 && !("byKey" in options2) && (event = options2, options2 = null), Array.isArray(hotkey) || (hotkey = [hotkey]);
    var array = hotkey.map(function(string) {
      return parseHotkey(string, options2);
    }), check = function(e2) {
      return array.some(function(object) {
        return compareHotkey(object, e2);
      });
    }, ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey2(hotkey, event);
  }
  function isKeyHotkey(hotkey, event) {
    return isHotkey2(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options2) {
    var byKey = options2 && options2.byKey, ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values = hotkey.split("+"), length2 = values.length;
    for (var k2 in MODIFIERS)
      ret[MODIFIERS[k2]] = false;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value, optional = value.endsWith("?") && value.length > 1;
        optional && (value = value.slice(0, -1));
        var name = toKeyName(value), modifier = MODIFIERS[name];
        if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name])
          throw new TypeError('Unknown modifier: "' + value + '"');
        (length2 === 1 || !modifier) && (byKey ? ret.key = name : ret.which = toKeyCode(value)), modifier && (ret[modifier] = optional ? null : true);
      }
    } catch (err) {
      _didIteratorError = true, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    return ret;
  }
  function compareHotkey(object, event) {
    for (var key in object) {
      var expected = object[key], actual = void 0;
      if (expected != null && (key === "key" && event.key != null ? actual = event.key.toLowerCase() : key === "which" ? actual = expected === 91 && event.which === 93 ? 91 : event.which : actual = event[key], !(actual == null && expected === false) && actual !== expected))
        return false;
    }
    return true;
  }
  function toKeyCode(name) {
    name = toKeyName(name);
    var code = CODES[name] || name.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name) {
    return name = name.toLowerCase(), name = ALIASES[name] || name, name;
  }
  return lib.default = isHotkey2, lib.isHotkey = isHotkey2, lib.isCodeHotkey = isCodeHotkey, lib.isKeyHotkey = isKeyHotkey, lib.parseHotkey = parseHotkey, lib.compareHotkey = compareHotkey, lib.toKeyCode = toKeyCode, lib.toKeyName = toKeyName, lib;
}
var libExports = requireLib();
var isHotkey = getDefaultExportFromCjs(libExports);
var useKeyPress = (hotkey, onPress) => {
  const keyPressed = (0, import_react17.useRef)(false), downHandler = (0, import_react17.useCallback)(
    (e2) => {
      isHotkey(hotkey, e2) && (keyPressed.current = true, onPress && onPress());
    },
    [hotkey, onPress]
  ), upHandler = (0, import_react17.useCallback)(() => {
    keyPressed.current = false;
  }, []);
  return (0, import_react17.useEffect)(() => (window.addEventListener("keydown", downHandler), window.addEventListener("keyup", upHandler), () => {
    window.removeEventListener("keydown", downHandler), window.removeEventListener("keyup", upHandler);
  }), [downHandler, upHandler]), keyPressed;
};
var divider = { type: "divider" };
var inputs = {
  altText: {
    assetTypes: ["file", "image"],
    field: "altText",
    name: "altText",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Alt text",
    type: "string",
    value: ""
  },
  creditLine: {
    assetTypes: ["file", "image"],
    field: "creditLine",
    name: "creditLine",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Credit",
    type: "string",
    value: ""
  },
  description: {
    assetTypes: ["file", "image"],
    field: "description",
    name: "description",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Description",
    type: "string",
    value: ""
  },
  fileName: {
    assetTypes: ["file", "image"],
    field: "originalFilename",
    name: "filename",
    operatorType: "includes",
    operatorTypes: ["includes", "doesNotInclude"],
    title: "File name",
    type: "string",
    value: ""
  },
  height: {
    assetTypes: ["image"],
    field: "metadata.dimensions.height",
    name: "height",
    operatorType: "greaterThan",
    operatorTypes: [
      "greaterThan",
      "greaterThanOrEqualTo",
      "lessThan",
      "lessThanOrEqualTo",
      null,
      "equalTo"
    ],
    title: "Height",
    type: "number",
    value: 400
  },
  inCurrentDocument: {
    assetTypes: ["file", "image"],
    name: "inCurrentDocument",
    operatorType: "is",
    options: [
      {
        name: "true",
        title: "True",
        value: groq`_id in $documentAssetIds`
      },
      {
        name: "false",
        title: "False",
        value: groq`!(_id in $documentAssetIds)`
      }
    ],
    selectOnly: true,
    title: "In use in current document",
    type: "select",
    value: "true"
  },
  inUse: {
    assetTypes: ["file", "image"],
    name: "inUse",
    operatorType: "is",
    options: [
      {
        name: "true",
        title: "True",
        value: groq`count(*[references(^._id)]) > 0`
      },
      {
        name: "false",
        title: "False",
        value: groq`count(*[references(^._id)]) == 0`
      }
    ],
    title: "In use",
    type: "select",
    value: "true"
  },
  isOpaque: {
    assetTypes: ["image"],
    field: "metadata.isOpaque",
    name: "isOpaque",
    operatorType: "equalTo",
    options: [
      {
        name: "true",
        title: "True",
        value: "false"
      },
      {
        name: "false",
        title: "False",
        value: "true"
      }
    ],
    title: "Has transparency",
    type: "select",
    value: "true"
  },
  orientation: {
    assetTypes: ["image"],
    name: "orientation",
    operatorType: "is",
    operatorTypes: ["is", "isNot"],
    options: [
      {
        name: "portrait",
        title: "Portrait",
        value: "metadata.dimensions.aspectRatio < 1"
      },
      {
        name: "landscape",
        title: "Landscape",
        value: "metadata.dimensions.aspectRatio > 1"
      },
      {
        name: "square",
        title: "Square",
        value: "metadata.dimensions.aspectRatio == 1"
      }
    ],
    title: "Orientation",
    type: "select",
    value: "portrait"
  },
  size: {
    assetTypes: ["file", "image"],
    field: "size",
    modifier: "kb",
    modifiers: [
      {
        name: "kb",
        title: "KB",
        fieldModifier: (fieldName) => `round(${fieldName} / 1000)`
      },
      {
        name: "mb",
        title: "MB",
        fieldModifier: (fieldName) => `round(${fieldName} / 1000000)`
      }
    ],
    name: "size",
    operatorType: "greaterThan",
    operatorTypes: [
      "greaterThan",
      "greaterThanOrEqualTo",
      "lessThan",
      "lessThanOrEqualTo",
      null,
      "equalTo"
    ],
    title: "File size",
    type: "number",
    value: 0
  },
  tag: {
    assetTypes: ["file", "image"],
    field: "opt.media.tags",
    name: "tag",
    operatorType: "references",
    operatorTypes: ["references", "doesNotReference", null, "empty", "notEmpty"],
    title: "Tags",
    type: "searchable"
  },
  title: {
    assetTypes: ["file", "image"],
    field: "title",
    name: "title",
    operatorType: "empty",
    operatorTypes: ["empty", "notEmpty", null, "includes", "doesNotInclude"],
    title: "Title",
    type: "string",
    value: ""
  },
  type: {
    assetTypes: ["file", "image"],
    name: "type",
    operatorType: "is",
    operatorTypes: ["is", "isNot"],
    options: [
      {
        name: "image",
        title: "Image",
        value: 'mimeType match "image*"'
      },
      {
        name: "video",
        title: "Video",
        value: 'mimeType match "video*"'
      },
      {
        name: "audio",
        title: "Audio",
        value: 'mimeType match "audio*"'
      },
      {
        name: "pdf",
        title: "PDF",
        value: 'mimeType == "application/pdf"'
      }
    ],
    title: "File type",
    type: "select",
    value: "image"
  },
  width: {
    assetTypes: ["image"],
    field: "metadata.dimensions.width",
    name: "width",
    operatorType: "greaterThan",
    operatorTypes: [
      "greaterThan",
      "greaterThanOrEqualTo",
      "lessThan",
      "lessThanOrEqualTo",
      null,
      "equalTo"
    ],
    title: "Width",
    type: "number",
    value: 400
  }
};
var operators = {
  doesNotInclude: {
    fn: (value, field) => value ? `!(${field} match '*${value}*')` : void 0,
    label: "does not include"
  },
  doesNotReference: {
    fn: (value, _field) => value ? `!references('${value}')` : void 0,
    label: "does not include"
  },
  empty: {
    fn: (_value, field) => `!defined(${field})`,
    hideInput: true,
    label: "is empty"
  },
  equalTo: {
    fn: (value, field) => value ? `${field} == ${value}` : void 0,
    label: "is equal to"
  },
  greaterThan: {
    fn: (value, field) => value ? `${field} > ${value}` : void 0,
    label: "is greater than"
  },
  greaterThanOrEqualTo: {
    fn: (value, field) => value ? `${field} >= ${value}` : void 0,
    label: "is greater than or equal to"
  },
  includes: {
    fn: (value, field) => value ? `${field} match '*${value}*'` : void 0,
    label: "includes"
  },
  is: {
    fn: (value, _field) => `${value}`,
    label: "is"
  },
  isNot: {
    fn: (value, _field) => `!(${value})`,
    label: "is not"
  },
  lessThan: {
    fn: (value, field) => value ? `${field} < ${value}` : void 0,
    label: "is less than"
  },
  lessThanOrEqualTo: {
    fn: (value, field) => value ? `${field} <= ${value}` : void 0,
    label: "is less than or equal to"
  },
  notEmpty: {
    fn: (_value, field) => `defined(${field})`,
    hideInput: true,
    label: "is not empty"
  },
  references: {
    fn: (value, _field) => value ? `references('${value}')` : void 0,
    label: "includes"
  }
};
var ORDER_OPTIONS = [
  {
    direction: "desc",
    field: "_createdAt"
  },
  {
    direction: "asc",
    field: "_createdAt"
  },
  // Divider
  null,
  {
    direction: "desc",
    field: "_updatedAt"
  },
  {
    direction: "asc",
    field: "_updatedAt"
  },
  // Divider
  null,
  {
    direction: "asc",
    field: "originalFilename"
  },
  {
    direction: "desc",
    field: "originalFilename"
  },
  // Divider
  null,
  {
    direction: "desc",
    field: "size"
  },
  {
    direction: "asc",
    field: "size"
  }
];
var FACETS = [
  inputs.tag,
  divider,
  inputs.inUse,
  inputs.inCurrentDocument,
  divider,
  inputs.title,
  inputs.altText,
  inputs.creditLine,
  inputs.description,
  divider,
  inputs.isOpaque,
  divider,
  inputs.fileName,
  inputs.size,
  inputs.type,
  divider,
  inputs.orientation,
  inputs.width,
  inputs.height
];
var GRID_TEMPLATE_COLUMNS = {
  SMALL: "3rem 100px auto 1.5rem",
  LARGE: "3rem 100px auto 5.5rem 5.5rem 3.5rem 8.5rem 4.75rem 2rem"
};
var PANEL_HEIGHT = 32;
var TAG_DOCUMENT_NAME = "media.tag";
var TAGS_PANEL_WIDTH = 250;
var AssetSourceDispatchContext = (0, import_react17.createContext)(void 0);
var AssetBrowserDispatchProvider = (props) => {
  const { children, onSelect } = props, contextValue = {
    onSelect
  };
  return (0, import_jsx_runtime2.jsx)(AssetSourceDispatchContext.Provider, { value: contextValue, children });
};
var useAssetSourceActions = () => {
  const context = (0, import_react17.useContext)(AssetSourceDispatchContext);
  if (context === void 0)
    throw new Error("useAssetSourceActions must be used within an AssetSourceDispatchProvider");
  return context;
};
var useVersionedClient = () => useClient({ apiVersion: "2022-10-01" });
var ORDER_DICTIONARY = {
  _createdAt: {
    asc: "Last created: Oldest first",
    desc: "Last created: Newest first"
  },
  _updatedAt: {
    asc: "Last updated: Oldest first",
    desc: "Last updated: Newest first"
  },
  mimeType: {
    asc: "MIME type: A to Z",
    desc: "MIME type: Z to A"
  },
  originalFilename: {
    asc: "File name: A to Z",
    desc: "File name: Z to A"
  },
  size: {
    asc: "File size: Smallest first",
    desc: "File size: Largest first"
  }
};
var getOrderTitle = (field, direction) => ORDER_DICTIONARY[field][direction];
var debugThrottle = (throttled) => function(source) {
  return iif(
    () => !!throttled,
    source.pipe(
      delay(3e3),
      mergeMap((v2) => Math.random() > 0.5 ? throwError({
        message: "Test error",
        statusCode: 500
      }) : of(v2))
    ),
    source
  );
};
var constructFilter = ({
  assetTypes,
  searchFacets,
  searchQuery
}) => {
  const documentAssetTypes = assetTypes.map((type) => `sanity.${type}Asset`), baseFilter = groq`
    _type in ${JSON.stringify(documentAssetTypes)} && !(_id in path("drafts.**"))
  `, searchFacetFragments = searchFacets.reduce((acc, facet) => {
    var _a;
    if (facet.type === "number") {
      const { field, modifier, modifiers, operatorType, value } = facet, operator = operators[operatorType], currentModifier = modifiers == null ? void 0 : modifiers.find((m2) => m2.name === modifier), facetField = (currentModifier == null ? void 0 : currentModifier.fieldModifier) ? currentModifier.fieldModifier(field) : field, fragment = operator.fn(value, facetField);
      fragment && acc.push(fragment);
    }
    if (facet.type === "searchable") {
      const { field, operatorType, value } = facet, fragment = operators[operatorType].fn(value == null ? void 0 : value.value, field);
      fragment && acc.push(fragment);
    }
    if (facet.type === "select") {
      const { field, operatorType, options: options2, value } = facet, operator = operators[operatorType], currentOptionValue = (_a = options2 == null ? void 0 : options2.find((l2) => l2.name === value)) == null ? void 0 : _a.value, fragment = operator.fn(currentOptionValue, field);
      fragment && acc.push(fragment);
    }
    if (facet.type === "string") {
      const { field, operatorType, value } = facet, fragment = operators[operatorType].fn(value, field);
      fragment && acc.push(fragment);
    }
    return acc;
  }, []);
  return [
    // Base filter
    baseFilter,
    // Search query (if present)
    // NOTE: Currently this only searches direct fields on sanity.fileAsset/sanity.imageAsset and NOT referenced tags
    // It's possible to add this by adding the following line to the searchQuery, but it's quite slow
    // references(*[_type == "media.tag" && name.current == "${searchQuery.trim()}"]._id)
    ...searchQuery ? [
      groq`[_id, altText, assetId, creditLine, description, originalFilename, title, url] match '*${searchQuery.trim()}*'`
    ] : [],
    // Search facets
    ...searchFacetFragments
  ].join(" && ");
};
var checkTagName = (client, name) => function(source) {
  return source.pipe(
    mergeMap(() => from(
      client.fetch(groq`count(*[_type == "${TAG_DOCUMENT_NAME}" && name.current == $name])`, {
        name
      })
    )),
    mergeMap((existingTagCount) => existingTagCount > 0 ? throwError({
      message: "Tag already exists",
      statusCode: 409
    }) : of(true))
  );
};
var getTagSelectOptions = (tags) => tags.reduce((acc, val) => {
  var _a;
  const tag = val == null ? void 0 : val.tag;
  return tag && acc.push({
    label: (_a = tag == null ? void 0 : tag.name) == null ? void 0 : _a.current,
    value: tag == null ? void 0 : tag._id
  }), acc;
}, []);
var ASSETS_ACTIONS = {
  tagsAddComplete: createAction(
    "actions/tagsAddComplete",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  ),
  tagsAddError: createAction(
    "actions/tagsAddError",
    function({ assets, error, tag }) {
      return { payload: { assets, error, tag } };
    }
  ),
  tagsAddRequest: createAction(
    "actions/tagsAddRequest",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  ),
  tagsRemoveComplete: createAction(
    "actions/tagsRemoveComplete",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  ),
  tagsRemoveError: createAction(
    "actions/tagsRemoveError",
    function({ assets, error, tag }) {
      return { payload: { assets, error, tag } };
    }
  ),
  tagsRemoveRequest: createAction(
    "actions/tagsRemoveRequest",
    function({ assets, tag }) {
      return { payload: { assets, tag } };
    }
  )
};
var DIALOG_ACTIONS = {
  showTagCreate: createAction("dialog/showTagCreate"),
  showTagEdit: createAction("dialog/showTagEdit", function({ tagId }) {
    return {
      payload: { tagId }
    };
  })
};
var initialState$7 = {
  allIds: [],
  byIds: {},
  creating: false,
  creatingError: void 0,
  fetchCount: -1,
  fetching: false,
  fetchingError: void 0,
  panelVisible: true
};
var tagsSlice = createSlice({
  name: "tags",
  initialState: initialState$7,
  extraReducers: (builder) => {
    builder.addCase(DIALOG_ACTIONS.showTagCreate, (state) => {
      delete state.creatingError;
    }).addCase(DIALOG_ACTIONS.showTagEdit, (state, action) => {
      const { tagId } = action.payload;
      delete state.byIds[tagId].error;
    }).addMatcher(
      isAnyOf(
        ASSETS_ACTIONS.tagsAddComplete,
        ASSETS_ACTIONS.tagsAddError,
        ASSETS_ACTIONS.tagsRemoveComplete,
        ASSETS_ACTIONS.tagsRemoveError
      ),
      (state, action) => {
        const { tag } = action.payload;
        state.byIds[tag._id].updating = false;
      }
    ).addMatcher(
      isAnyOf(ASSETS_ACTIONS.tagsAddRequest, ASSETS_ACTIONS.tagsRemoveRequest),
      (state, action) => {
        const { tag } = action.payload;
        state.byIds[tag._id].updating = true;
      }
    );
  },
  reducers: {
    createComplete(state, action) {
      const { tag } = action.payload;
      state.creating = false, state.allIds.includes(tag._id) || state.allIds.push(tag._id), state.byIds[tag._id] = {
        _type: "tag",
        picked: false,
        tag,
        updating: false
      };
    },
    createError(state, action) {
      state.creating = false, state.creatingError = action.payload.error;
    },
    createRequest(state, _action) {
      state.creating = true, delete state.creatingError;
    },
    deleteComplete(state, action) {
      const { tagId } = action.payload, deleteIndex = state.allIds.indexOf(tagId);
      deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[tagId];
    },
    deleteError(state, action) {
      const { error, tag } = action.payload, tagId = tag == null ? void 0 : tag._id;
      state.byIds[tagId].error = error, state.byIds[tagId].updating = false;
    },
    deleteRequest(state, action) {
      var _a, _b;
      const tagId = (_b = (_a = action.payload) == null ? void 0 : _a.tag) == null ? void 0 : _b._id;
      state.byIds[tagId].picked = false, state.byIds[tagId].updating = true, Object.keys(state.byIds).forEach((key) => {
        delete state.byIds[key].error;
      });
    },
    fetchComplete(state, action) {
      const { tags } = action.payload;
      tags == null ? void 0 : tags.forEach((tag) => {
        state.allIds.push(tag._id), state.byIds[tag._id] = {
          _type: "tag",
          picked: false,
          tag,
          updating: false
        };
      }), state.fetching = false, state.fetchCount = tags.length || 0, delete state.fetchingError;
    },
    fetchError(state, action) {
      const { error } = action.payload;
      state.fetching = false, state.fetchingError = error;
    },
    fetchRequest: {
      reducer: (state, _action) => {
        state.fetching = true, delete state.fetchingError;
      },
      prepare: () => ({ payload: { query: groq`
          {
            "items": *[
              _type == "${TAG_DOCUMENT_NAME}"
              && !(_id in path("drafts.**"))
            ] {
              _createdAt,
              _updatedAt,
              _id,
              _rev,
              _type,
              name
            } | order(name.current asc),
          }
        ` } })
    },
    // Queue batch tag creation
    listenerCreateQueue(_state, _action) {
    },
    // Apply created tags (via sanity real-time events)
    listenerCreateQueueComplete(state, action) {
      const { tags } = action.payload;
      tags == null ? void 0 : tags.forEach((tag) => {
        state.byIds[tag._id] = {
          _type: "tag",
          picked: false,
          tag,
          updating: false
        }, state.allIds.includes(tag._id) || state.allIds.push(tag._id);
      });
    },
    // Queue batch tag deletion
    listenerDeleteQueue(_state, _action) {
    },
    // Apply deleted tags (via sanity real-time events)
    listenerDeleteQueueComplete(state, action) {
      const { tagIds } = action.payload;
      tagIds == null ? void 0 : tagIds.forEach((tagId) => {
        const deleteIndex = state.allIds.indexOf(tagId);
        deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[tagId];
      });
    },
    // Queue batch tag updates
    listenerUpdateQueue(_state, _action) {
    },
    // Apply updated tags (via sanity real-time events)
    listenerUpdateQueueComplete(state, action) {
      const { tags } = action.payload;
      tags == null ? void 0 : tags.forEach((tag) => {
        state.byIds[tag._id] && (state.byIds[tag._id].tag = tag);
      });
    },
    // Set tag panel visibility
    panelVisibleSet(state, action) {
      const { panelVisible } = action.payload;
      state.panelVisible = panelVisible;
    },
    // Sort all tags by name
    sort(state) {
      state.allIds.sort((a2, b2) => {
        const tagA = state.byIds[a2].tag.name.current, tagB = state.byIds[b2].tag.name.current;
        return tagA < tagB ? -1 : tagA > tagB ? 1 : 0;
      });
    },
    updateComplete(state, action) {
      const { tag } = action.payload;
      state.byIds[tag._id].tag = tag, state.byIds[tag._id].updating = false;
    },
    updateError(state, action) {
      const { error, tag } = action.payload, tagId = tag == null ? void 0 : tag._id;
      state.byIds[tagId].error = error, state.byIds[tagId].updating = false;
    },
    updateRequest(state, action) {
      const { tag } = action.payload;
      state.byIds[tag == null ? void 0 : tag._id].updating = true;
    }
  }
});
var tagsCreateEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.createRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assetId, name } = action.payload;
    return of(action).pipe(
      debugThrottle(state.debug.badConnection),
      checkTagName(client, name),
      mergeMap(
        () => client.observable.create({
          _type: TAG_DOCUMENT_NAME,
          name: {
            _type: "slug",
            current: name
          }
        })
      ),
      mergeMap((result) => of(tagsSlice.actions.createComplete({ assetId, tag: result }))),
      catchError(
        (error) => of(
          tagsSlice.actions.createError({
            error: {
              message: (error == null ? void 0 : error.message) || "Internal error",
              statusCode: (error == null ? void 0 : error.statusCode) || 500
            },
            name
          })
        )
      )
    );
  })
);
var tagsDeleteEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.deleteRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Fetch assets which reference this tag
      mergeMap(
        () => client.observable.fetch(
          groq`*[
              _type in ["sanity.fileAsset", "sanity.imageAsset"]
              && references(*[_type == "media.tag" && name.current == $tagName]._id)
            ] {
              _id,
              _rev,
              opt
            }`,
          { tagName: tag.name.current }
        )
      ),
      // Create transaction which remove tag references from all matched assets and delete tag
      mergeMap((assets) => {
        const transaction = assets.map((asset) => ({
          id: asset._id,
          patch: {
            // this will cause the transaction to fail if the document has been modified since it was fetched.
            ifRevisionID: asset._rev,
            unset: [`opt.media.tags[_ref == "${tag._id}"]`]
          }
        })).reduce(
          (tx, patch) => tx.patch(patch.id, patch.patch),
          client.transaction()
        );
        return transaction.delete(tag._id), from(transaction.commit());
      }),
      // Dispatch complete action
      mergeMap(() => of(tagsSlice.actions.deleteComplete({ tagId: tag._id }))),
      catchError(
        (error) => of(
          tagsSlice.actions.deleteError({
            error: {
              message: (error == null ? void 0 : error.message) || "Internal error",
              statusCode: (error == null ? void 0 : error.statusCode) || 500
            },
            tag
          })
        )
      )
    );
  })
);
var tagsFetchEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.fetchRequest.match),
  withLatestFrom(state$),
  switchMap(([action, state]) => {
    const { query } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Fetch tags
      mergeMap(
        () => client.observable.fetch(query)
      ),
      // Dispatch complete action
      mergeMap((result) => {
        const { items } = result;
        return of(tagsSlice.actions.fetchComplete({ tags: items }));
      }),
      catchError(
        (error) => of(
          tagsSlice.actions.fetchError({
            error: {
              message: (error == null ? void 0 : error.message) || "Internal error",
              statusCode: (error == null ? void 0 : error.statusCode) || 500
            }
          })
        )
      )
    );
  })
);
var tagsListenerCreateQueueEpic = (action$) => action$.pipe(
  filter(tagsSlice.actions.listenerCreateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const tags = actions == null ? void 0 : actions.map((action) => action.payload.tag);
    return of(tagsSlice.actions.listenerCreateQueueComplete({ tags }));
  })
);
var tagsListenerDeleteQueueEpic = (action$) => action$.pipe(
  filter(tagsSlice.actions.listenerDeleteQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const tagIds = actions == null ? void 0 : actions.map((action) => action.payload.tagId);
    return of(tagsSlice.actions.listenerDeleteQueueComplete({ tagIds }));
  })
);
var tagsListenerUpdateQueueEpic = (action$) => action$.pipe(
  filter(tagsSlice.actions.listenerUpdateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const tags = actions == null ? void 0 : actions.map((action) => action.payload.tag);
    return of(tagsSlice.actions.listenerUpdateQueueComplete({ tags }));
  })
);
var tagsSortEpic = (action$) => action$.pipe(
  ofType(
    tagsSlice.actions.listenerCreateQueueComplete.type,
    tagsSlice.actions.listenerUpdateQueueComplete.type
  ),
  bufferTime(1e3),
  filter((actions) => actions.length > 0),
  mergeMap(() => of(tagsSlice.actions.sort()))
);
var tagsUpdateEpic = (action$, state$, { client }) => action$.pipe(
  filter(tagsSlice.actions.updateRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    var _a;
    const { closeDialogId, formData, tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Check if tag name is available, throw early if not
      checkTagName(client, (_a = formData == null ? void 0 : formData.name) == null ? void 0 : _a.current),
      // Patch document (Update tag)
      mergeMap(
        () => from(
          client.patch(tag._id).set({ name: { _type: "slug", current: formData == null ? void 0 : formData.name.current } }).commit()
        )
      ),
      // Dispatch complete action
      mergeMap((updatedTag) => of(
        tagsSlice.actions.updateComplete({
          closeDialogId,
          tag: updatedTag
        })
      )),
      catchError(
        (error) => of(
          tagsSlice.actions.updateError({
            error: {
              message: (error == null ? void 0 : error.message) || "Internal error",
              statusCode: (error == null ? void 0 : error.statusCode) || 500
            },
            tag
          })
        )
      )
    );
  })
);
var selectTagsByIds = (state) => state.tags.byIds;
var selectTagsAllIds = (state) => state.tags.allIds;
var selectTags = createSelector(
  [selectTagsByIds, selectTagsAllIds],
  (byIds, allIds) => allIds.map((id) => byIds[id])
);
var selectTagById = createSelector(
  [selectTagsByIds, (_state, tagId) => tagId],
  (byIds, tagId) => byIds[tagId]
);
var selectTagSelectOptions = (asset) => (state) => {
  var _a, _b, _c;
  const tags = (_c = (_b = (_a = asset == null ? void 0 : asset.opt) == null ? void 0 : _a.media) == null ? void 0 : _b.tags) == null ? void 0 : _c.reduce((acc, v2) => {
    const tagItem = state.tags.byIds[v2._ref];
    return (tagItem == null ? void 0 : tagItem.tag) && acc.push(tagItem), acc;
  }, []);
  return tags && (tags == null ? void 0 : tags.length) > 0 ? getTagSelectOptions(tags) : null;
};
var tagsActions = { ...tagsSlice.actions };
var tagsReducer = tagsSlice.reducer;
var initialState$6 = {
  facets: [],
  query: ""
};
var searchSlice = createSlice({
  name: "search",
  initialState: initialState$6,
  reducers: {
    // Add search facet
    facetsAdd(state, action) {
      state.facets.push({ ...action.payload.facet, id: v4_default() });
    },
    // Clear all search facets
    facetsClear(state) {
      state.facets = [];
    },
    // Remove search facet by name
    facetsRemoveByName(state, action) {
      state.facets = state.facets.filter((facet) => facet.name !== action.payload.facetName);
    },
    // Remove search facet by name
    facetsRemoveByTag(state, action) {
      state.facets = state.facets.filter(
        (facet) => {
          var _a;
          return !(facet.name === "tag" && facet.type === "searchable" && (facet.operatorType === "references" || facet.operatorType === "doesNotReference") && ((_a = facet.value) == null ? void 0 : _a.value) === action.payload.tagId);
        }
      );
    },
    // Remove search facet by name
    facetsRemoveById(state, action) {
      state.facets = state.facets.filter((facet) => facet.id !== action.payload.facetId);
    },
    // Update an existing search facet
    facetsUpdate(state, action) {
      const { modifier, name, operatorType, value } = action.payload, facet = state.facets.find((f2) => f2.name === name);
      facet && (facet.type === "number" && modifier && (facet.modifier = modifier), operatorType && (facet.operatorType = operatorType), typeof value < "u" && (facet.value = value), state.facets = state.facets.filter((f2) => f2.name !== facet.name || f2.id === facet.id));
    },
    // Update an existing search facet
    facetsUpdateById(state, action) {
      const { modifier, id, operatorType, value } = action.payload;
      state.facets.forEach((facet, index2) => {
        facet.id === id && (facet.type === "number" && modifier && (facet.modifier = modifier), operatorType && (facet.operatorType = operatorType), typeof value < "u" && (state.facets[index2].value = value));
      });
    },
    // Update existing search query
    querySet(state, action) {
      var _a;
      state.query = (_a = action.payload) == null ? void 0 : _a.searchQuery;
    }
  }
});
var searchFacetTagUpdateEpic = (action$, state$) => action$.pipe(
  filter(tagsActions.updateComplete.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    var _a, _b, _c, _d, _e2;
    const { tag } = action.payload, currentSearchFacetTag = (_a = state.search.facets) == null ? void 0 : _a.find((facet) => facet.name === "tag"), tagItem = state.tags.byIds[tag._id];
    return (currentSearchFacetTag == null ? void 0 : currentSearchFacetTag.type) === "searchable" && ((_b = currentSearchFacetTag.value) == null ? void 0 : _b.value) === tag._id ? of(
      searchSlice.actions.facetsUpdate({
        name: "tag",
        value: {
          label: (_d = (_c = tagItem == null ? void 0 : tagItem.tag) == null ? void 0 : _c.name) == null ? void 0 : _d.current,
          value: (_e2 = tagItem == null ? void 0 : tagItem.tag) == null ? void 0 : _e2._id
        }
      })
    ) : EMPTY;
  })
);
var selectIsSearchFacetTag = createSelector(
  [
    (state) => state.search.facets,
    (_state, tagId) => tagId
  ],
  (searchFacets, tagId) => searchFacets.some(
    (facet) => {
      var _a;
      return facet.name === "tag" && facet.type === "searchable" && (facet.operatorType === "references" || facet.operatorType === "doesNotReference") && ((_a = facet.value) == null ? void 0 : _a.value) === tagId;
    }
  )
);
var searchActions = { ...searchSlice.actions };
var searchReducer = searchSlice.reducer;
var UPLOADS_ACTIONS = {
  uploadComplete: createAction(
    "uploads/uploadComplete",
    function({ asset }) {
      return {
        payload: { asset }
      };
    }
  )
};
var defaultOrder = ORDER_OPTIONS[0];
var initialState$5 = {
  allIds: [],
  assetTypes: [],
  byIds: {},
  fetchCount: -1,
  fetching: false,
  fetchingError: void 0,
  lastPicked: void 0,
  order: {
    direction: defaultOrder.direction,
    field: defaultOrder.field,
    title: getOrderTitle(defaultOrder.field, defaultOrder.direction)
  },
  pageIndex: 0,
  pageSize: 100,
  // totalCount: -1,
  view: "grid"
};
var assetsSlice = createSlice({
  name: "assets",
  initialState: initialState$5,
  extraReducers: (builder) => {
    builder.addCase(UPLOADS_ACTIONS.uploadComplete, (state, action) => {
      const { asset } = action.payload;
      state.byIds[asset._id] = {
        _type: "asset",
        asset,
        picked: false,
        updating: false
      };
    }).addCase(ASSETS_ACTIONS.tagsAddComplete, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsAddError, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsAddRequest, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = true;
      });
    }).addCase(ASSETS_ACTIONS.tagsRemoveComplete, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsRemoveError, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = false;
      });
    }).addCase(ASSETS_ACTIONS.tagsRemoveRequest, (state, action) => {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset.asset._id].updating = true;
      });
    });
  },
  reducers: {
    // Clear asset order
    clear(state) {
      state.allIds = [];
    },
    // Remove assets and update page index
    deleteComplete(state, action) {
      const { assetIds } = action.payload;
      assetIds == null ? void 0 : assetIds.forEach((id) => {
        const deleteIndex = state.allIds.indexOf(id);
        deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[id];
      }), state.pageIndex = Math.floor(state.allIds.length / state.pageSize) - 1;
    },
    deleteError(state, action) {
      var _a, _b, _c, _d;
      const { assetIds, error } = action.payload, itemErrors = (_d = (_c = (_b = (_a = error == null ? void 0 : error.response) == null ? void 0 : _a.body) == null ? void 0 : _b.error) == null ? void 0 : _c.items) == null ? void 0 : _d.map(
        (item) => item.error
      );
      assetIds == null ? void 0 : assetIds.forEach((id) => {
        state.byIds[id].updating = false;
      }), itemErrors == null ? void 0 : itemErrors.forEach((item) => {
        state.byIds[item.id].error = item.description;
      });
    },
    deleteRequest(state, action) {
      const { assets } = action.payload;
      assets.forEach((asset) => {
        state.byIds[asset == null ? void 0 : asset._id].updating = true;
      }), Object.keys(state.byIds).forEach((key) => {
        delete state.byIds[key].error;
      });
    },
    fetchComplete(state, action) {
      var _a;
      const assets = ((_a = action.payload) == null ? void 0 : _a.assets) || [];
      assets && assets.forEach((asset) => {
        state.allIds.includes(asset._id) || state.allIds.push(asset._id), state.byIds[asset._id] = {
          _type: "asset",
          asset,
          picked: false,
          updating: false
        };
      }), state.fetching = false, state.fetchCount = assets.length || 0, delete state.fetchingError;
    },
    fetchError(state, action) {
      const error = action.payload;
      state.fetching = false, state.fetchingError = error;
    },
    fetchRequest: {
      reducer: (state, _action) => {
        state.fetching = true, delete state.fetchingError;
      },
      prepare: ({
        params = {},
        queryFilter,
        selector = "",
        sort = groq`order(_updatedAt desc)`
      }) => {
        const query = groq`
          {
            "items": *[${queryFilter}] {
              _id,
              _type,
              _createdAt,
              _updatedAt,
              altText,
              creditLine,
              description,
              extension,
              metadata {
                dimensions,
                exif,
                isOpaque,
              },
              mimeType,
              opt {
                media
              },
              originalFilename,
              size,
              source {
                name
              },
              title,
              url
            } ${sort || selector ? "|" : ""} ${sort} ${selector},
          }
        `;
        return { payload: { params, query } };
      }
    },
    insertUploads(state, action) {
      const { results } = action.payload;
      Object.entries(results).forEach(([hash2, assetId]) => {
        assetId && !state.allIds.includes(hash2) && state.allIds.push(assetId);
      });
    },
    listenerCreateQueue(_state, _action) {
    },
    listenerCreateQueueComplete(state, action) {
      const { assets } = action.payload;
      assets == null ? void 0 : assets.forEach((asset) => {
        var _a;
        ((_a = state.byIds[asset == null ? void 0 : asset._id]) == null ? void 0 : _a.asset) && (state.byIds[asset._id].asset = asset);
      });
    },
    listenerDeleteQueue(_state, _action) {
    },
    listenerDeleteQueueComplete(state, action) {
      const { assetIds } = action.payload;
      assetIds == null ? void 0 : assetIds.forEach((assetId) => {
        const deleteIndex = state.allIds.indexOf(assetId);
        deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[assetId];
      });
    },
    listenerUpdateQueue(_state, _action) {
    },
    listenerUpdateQueueComplete(state, action) {
      const { assets } = action.payload;
      assets == null ? void 0 : assets.forEach((asset) => {
        var _a;
        ((_a = state.byIds[asset == null ? void 0 : asset._id]) == null ? void 0 : _a.asset) && (state.byIds[asset._id].asset = asset);
      });
    },
    loadNextPage() {
    },
    loadPageIndex(state, action) {
      state.pageIndex = action.payload.pageIndex;
    },
    orderSet(state, action) {
      var _a;
      state.order = (_a = action.payload) == null ? void 0 : _a.order, state.pageIndex = 0;
    },
    pick(state, action) {
      const { assetId, picked } = action.payload;
      state.byIds[assetId].picked = picked, state.lastPicked = picked ? assetId : void 0;
    },
    pickAll(state) {
      state.allIds.forEach((id) => {
        state.byIds[id].picked = true;
      });
    },
    pickClear(state) {
      state.lastPicked = void 0, Object.values(state.byIds).forEach((asset) => {
        state.byIds[asset.asset._id].picked = false;
      });
    },
    pickRange(state, action) {
      const startIndex = state.allIds.findIndex((id) => id === action.payload.startId), endIndex = state.allIds.findIndex((id) => id === action.payload.endId), indices = [startIndex, endIndex].sort((a2, b2) => a2 - b2);
      state.allIds.slice(indices[0], indices[1] + 1).forEach((key) => {
        state.byIds[key].picked = true;
      }), state.lastPicked = state.allIds[endIndex];
    },
    sort(state) {
      state.allIds.sort((a2, b2) => {
        const tagA = state.byIds[a2].asset[state.order.field], tagB = state.byIds[b2].asset[state.order.field];
        return tagA < tagB ? state.order.direction === "asc" ? -1 : 1 : tagA > tagB ? state.order.direction === "asc" ? 1 : -1 : 0;
      });
    },
    updateComplete(state, action) {
      const { asset } = action.payload;
      state.byIds[asset._id].updating = false, state.byIds[asset._id].asset = asset;
    },
    updateError(state, action) {
      const { asset, error } = action.payload, assetId = asset == null ? void 0 : asset._id;
      state.byIds[assetId].error = error.message, state.byIds[assetId].updating = false;
    },
    updateRequest(state, action) {
      var _a, _b;
      const assetId = (_b = (_a = action.payload) == null ? void 0 : _a.asset) == null ? void 0 : _b._id;
      state.byIds[assetId].updating = true;
    },
    viewSet(state, action) {
      var _a;
      state.view = (_a = action.payload) == null ? void 0 : _a.view;
    }
  }
});
var assetsDeleteEpic = (action$, _state$, { client }) => action$.pipe(
  filter(assetsActions.deleteRequest.match),
  mergeMap((action) => {
    const { assets } = action.payload, assetIds = assets.map((asset) => asset._id);
    return of(assets).pipe(
      mergeMap(
        () => client.observable.delete({
          query: groq`*[_id in ${JSON.stringify(assetIds)}]`
        })
      ),
      mergeMap(() => of(assetsActions.deleteComplete({ assetIds }))),
      catchError((error) => of(assetsActions.deleteError({ assetIds, error })))
    );
  })
);
var assetsFetchEpic = (action$, state$, { client }) => action$.pipe(
  filter(assetsActions.fetchRequest.match),
  withLatestFrom(state$),
  switchMap(([action, state]) => {
    var _a, _b;
    const params = (_a = action.payload) == null ? void 0 : _a.params, query = (_b = action.payload) == null ? void 0 : _b.query;
    return of(action).pipe(
      debugThrottle(state.debug.badConnection),
      mergeMap(
        () => client.observable.fetch(query, params)
      ),
      mergeMap((result) => {
        const {
          items
          // totalCount
        } = result;
        return of(assetsActions.fetchComplete({ assets: items }));
      }),
      catchError(
        (error) => of(
          assetsActions.fetchError({
            message: (error == null ? void 0 : error.message) || "Internal error",
            statusCode: (error == null ? void 0 : error.statusCode) || 500
          })
        )
      )
    );
  })
);
var assetsFetchPageIndexEpic = (action$, state$) => action$.pipe(
  filter(assetsActions.loadPageIndex.match),
  withLatestFrom(state$),
  switchMap(([action, state]) => {
    var _a, _b, _c, _d, _e2, _f;
    const pageSize = state.assets.pageSize, start = action.payload.pageIndex * pageSize, end = start + pageSize, documentId = (_a = state == null ? void 0 : state.selected.document) == null ? void 0 : _a._id, documentAssetIds = (_b = state == null ? void 0 : state.selected) == null ? void 0 : _b.documentAssetIds, constructedFilter = constructFilter({
      assetTypes: state.assets.assetTypes,
      searchFacets: state.search.facets,
      searchQuery: state.search.query
    }), params = {
      ...documentId ? { documentId } : {},
      documentAssetIds
    };
    return of(
      assetsActions.fetchRequest({
        params,
        queryFilter: constructedFilter,
        selector: groq`[${start}...${end}]`,
        sort: groq`order(${(_d = (_c = state.assets) == null ? void 0 : _c.order) == null ? void 0 : _d.field} ${(_f = (_e2 = state.assets) == null ? void 0 : _e2.order) == null ? void 0 : _f.direction})`
      })
    );
  })
);
var assetsFetchNextPageEpic = (action$, state$) => action$.pipe(
  filter(assetsActions.loadNextPage.match),
  withLatestFrom(state$),
  switchMap(
    ([_action, state]) => of(assetsActions.loadPageIndex({ pageIndex: state.assets.pageIndex + 1 }))
  )
);
var assetsFetchAfterDeleteAllEpic = (action$, state$) => action$.pipe(
  filter(assetsActions.deleteComplete.match),
  withLatestFrom(state$),
  switchMap(([_action, state]) => {
    if (state.assets.allIds.length === 0) {
      const nextPageIndex = Math.floor(state.assets.allIds.length / state.assets.pageSize);
      return of(assetsActions.loadPageIndex({ pageIndex: nextPageIndex }));
    }
    return EMPTY;
  })
);
var filterAssetWithoutTag = (tag) => (asset) => {
  var _a, _b, _c, _d;
  return (((_d = (_c = (_b = (_a = asset == null ? void 0 : asset.asset) == null ? void 0 : _a.opt) == null ? void 0 : _b.media) == null ? void 0 : _c.tags) == null ? void 0 : _d.findIndex((t3) => t3._ref === (tag == null ? void 0 : tag._id))) ?? -1) < 0;
};
var patchOperationTagAppend = ({ tag }) => (patch) => patch.setIfMissing({ opt: {} }).setIfMissing({ "opt.media": {} }).setIfMissing({ "opt.media.tags": [] }).append("opt.media.tags", [{ _key: nanoid(), _ref: tag == null ? void 0 : tag._id, _type: "reference", _weak: true }]);
var patchOperationTagUnset = ({ asset, tag }) => (patch) => {
  var _a;
  return patch.ifRevisionId((_a = asset == null ? void 0 : asset.asset) == null ? void 0 : _a._rev).unset([`opt.media.tags[_ref == "${tag._id}"]`]);
};
var assetsOrderSetEpic = (action$) => action$.pipe(
  filter(assetsActions.orderSet.match),
  mergeMap(() => of(
    assetsActions.clear(),
    //
    assetsActions.loadPageIndex({ pageIndex: 0 })
  ))
);
var assetsSearchEpic = (action$) => action$.pipe(
  ofType(
    searchActions.facetsAdd.type,
    searchActions.facetsClear.type,
    searchActions.facetsRemoveById.type,
    searchActions.facetsRemoveByName.type,
    searchActions.facetsRemoveByTag.type,
    searchActions.facetsUpdate.type,
    searchActions.facetsUpdateById.type,
    searchActions.querySet.type
  ),
  debounceTime(400),
  mergeMap(() => of(
    assetsActions.clear(),
    //
    assetsActions.loadPageIndex({ pageIndex: 0 })
  ))
);
var assetsListenerCreateQueueEpic = (action$) => action$.pipe(
  filter(assetsActions.listenerCreateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const assets = actions == null ? void 0 : actions.map((action) => action.payload.asset);
    return of(assetsActions.listenerCreateQueueComplete({ assets }));
  })
);
var assetsListenerDeleteQueueEpic = (action$) => action$.pipe(
  filter(assetsActions.listenerDeleteQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const assetIds = actions == null ? void 0 : actions.map((action) => action.payload.assetId);
    return of(assetsActions.listenerDeleteQueueComplete({ assetIds }));
  })
);
var assetsListenerUpdateQueueEpic = (action$) => action$.pipe(
  filter(assetsActions.listenerUpdateQueue.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const assets = actions == null ? void 0 : actions.map((action) => action.payload.asset);
    return of(assetsActions.listenerUpdateQueueComplete({ assets }));
  })
);
var assetsSortEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.insertUploads.type,
    assetsActions.listenerUpdateQueueComplete.type,
    assetsActions.updateComplete.type
  ),
  mergeMap(() => of(assetsActions.sort()))
);
var assetsTagsAddEpic = (action$, state$, { client }) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsAddRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assets, tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Add tag references to all picked assets
      mergeMap(() => {
        var _a;
        const transaction = ((_a = selectAssetsPicked(state)) == null ? void 0 : _a.filter(filterAssetWithoutTag(tag))).reduce(
          (tx, pickedAsset) => {
            var _a2;
            return tx.patch((_a2 = pickedAsset == null ? void 0 : pickedAsset.asset) == null ? void 0 : _a2._id, patchOperationTagAppend({ tag }));
          },
          client.transaction()
        );
        return from(transaction.commit());
      }),
      // Dispatch complete action
      mergeMap(() => of(ASSETS_ACTIONS.tagsAddComplete({ assets, tag }))),
      catchError(
        (error) => of(
          ASSETS_ACTIONS.tagsAddError({
            assets,
            error: {
              message: (error == null ? void 0 : error.message) || "Internal error",
              statusCode: (error == null ? void 0 : error.statusCode) || 500
            },
            tag
          })
        )
      )
    );
  })
);
var assetsTagsRemoveEpic = (action$, state$, { client }) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsRemoveRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assets, tag } = action.payload;
    return of(action).pipe(
      // Optionally throttle
      debugThrottle(state.debug.badConnection),
      // Remove tag references from all picked assets
      mergeMap(() => {
        const transaction = selectAssetsPicked(state).reduce(
          (tx, pickedAsset) => {
            var _a;
            return tx.patch((_a = pickedAsset == null ? void 0 : pickedAsset.asset) == null ? void 0 : _a._id, patchOperationTagUnset({ asset: pickedAsset, tag }));
          },
          client.transaction()
        );
        return from(transaction.commit());
      }),
      // Dispatch complete action
      mergeMap(() => of(ASSETS_ACTIONS.tagsRemoveComplete({ assets, tag }))),
      catchError(
        (error) => of(
          ASSETS_ACTIONS.tagsRemoveError({
            assets,
            error: {
              message: (error == null ? void 0 : error.message) || "Internal error",
              statusCode: (error == null ? void 0 : error.statusCode) || 500
            },
            tag
          })
        )
      )
    );
  })
);
var assetsUnpickEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.orderSet.type,
    assetsActions.viewSet.type,
    searchActions.facetsAdd.type,
    searchActions.facetsClear.type,
    searchActions.facetsRemoveById.type,
    searchActions.facetsRemoveByName.type,
    searchActions.facetsRemoveByTag.type,
    searchActions.facetsUpdate.type,
    searchActions.facetsUpdateById.type,
    searchActions.querySet.type
  ),
  mergeMap(() => of(assetsActions.pickClear()))
);
var assetsUpdateEpic = (action$, state$, { client }) => action$.pipe(
  filter(assetsActions.updateRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { asset, closeDialogId, formData } = action.payload;
    return of(action).pipe(
      debugThrottle(state.debug.badConnection),
      mergeMap(
        () => from(
          client.patch(asset._id).setIfMissing({ opt: {} }).setIfMissing({ "opt.media": {} }).set(formData).commit()
        )
      ),
      mergeMap(
        (updatedAsset) => of(
          assetsActions.updateComplete({
            asset: updatedAsset,
            closeDialogId
          })
        )
      ),
      catchError(
        (error) => of(
          assetsActions.updateError({
            asset,
            error: {
              message: (error == null ? void 0 : error.message) || "Internal error",
              statusCode: (error == null ? void 0 : error.statusCode) || 500
            }
          })
        )
      )
    );
  })
);
var selectAssetsByIds = (state) => state.assets.byIds;
var selectAssetsAllIds = (state) => state.assets.allIds;
var selectAssetById = createSelector(
  [
    (state) => state.assets.byIds,
    (_state, assetId) => assetId
  ],
  (byIds, assetId) => byIds[assetId] || void 0
);
var selectAssets = createSelector(
  [selectAssetsByIds, selectAssetsAllIds],
  (byIds, allIds) => allIds.map((id) => byIds[id])
);
var selectAssetsLength = createSelector([selectAssets], (assets) => assets.length);
var selectAssetsPicked = createSelector(
  [selectAssets],
  (assets) => assets.filter((item) => item == null ? void 0 : item.picked)
);
var selectAssetsPickedLength = createSelector(
  [selectAssetsPicked],
  (assetsPicked) => assetsPicked.length
);
var assetsActions = { ...assetsSlice.actions };
var assetsReducer = assetsSlice.reducer;
var customScrollbar = lt`
  ::-webkit-scrollbar {
    width: 14px;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 10px;
    border: 4px solid rgba(0, 0, 0, 0);
    background: var(--card-border-color);
    background-clip: padding-box;

    &:hover {
      background: var(--card-muted-fg-color);
      background-clip: padding-box;
    }
  }
`;
var GlobalStyle = ft`
  .media__custom-scrollbar {
    ${customScrollbar}
  }

  // @sanity/ui overrides

  // Custom scrollbar on Box (used in Dialogs)
  div[data-ui="Box"] {
    ${customScrollbar}
  }

  // Dialog background color
  div[data-ui="Dialog"] {
    background-color: rgba(15, 17, 18, 0.9);
  }

`;
var useTypedSelector = useSelector;
var initialState$4 = {
  items: []
};
var dialogSlice = createSlice({
  name: "dialog",
  initialState: initialState$4,
  extraReducers: (builder) => {
    builder.addCase(DIALOG_ACTIONS.showTagCreate, (state) => {
      state.items.push({
        id: "tagCreate",
        type: "tagCreate"
      });
    }), builder.addCase(DIALOG_ACTIONS.showTagEdit, (state, action) => {
      const { tagId } = action.payload;
      state.items.push({
        id: tagId,
        tagId,
        type: "tagEdit"
      });
    });
  },
  reducers: {
    // Clear all dialogs
    clear(state) {
      state.items = [];
    },
    // Add newly created inline tag to assetEdit dialog
    inlineTagCreate(state, action) {
      const { assetId, tag } = action.payload;
      state.items.forEach((item) => {
        item.type === "assetEdit" && item.assetId === assetId && (item.lastCreatedTag = {
          label: tag.name.current,
          value: tag._id
        });
      });
    },
    // Remove inline tags from assetEdit dialog
    inlineTagRemove(state, action) {
      const { tagIds } = action.payload;
      state.items.forEach((item) => {
        item.type === "assetEdit" && (item.lastRemovedTagIds = tagIds);
      });
    },
    // Remove dialog by id
    remove(state, action) {
      var _a;
      const id = (_a = action.payload) == null ? void 0 : _a.id;
      state.items = state.items.filter((item) => item.id !== id);
    },
    showConfirmAssetsTagAdd(state, action) {
      const { assetsPicked, closeDialogId, tag } = action.payload, suffix = `${assetsPicked.length} ${(0, import_pluralize.default)("asset", assetsPicked.length)}`;
      state.items.push({
        closeDialogId,
        confirmCallbackAction: ASSETS_ACTIONS.tagsAddRequest({
          assets: assetsPicked,
          tag
        }),
        confirmText: `Yes, add tag to ${suffix}`,
        title: `Add tag ${tag.name.current} to ${suffix}?`,
        id: "confirm",
        headerTitle: "Confirm tag addition",
        tone: "primary",
        type: "confirm"
      });
    },
    showConfirmAssetsTagRemove(state, action) {
      const { assetsPicked, closeDialogId, tag } = action.payload, suffix = `${assetsPicked.length} ${(0, import_pluralize.default)("asset", assetsPicked.length)}`;
      state.items.push({
        closeDialogId,
        confirmCallbackAction: ASSETS_ACTIONS.tagsRemoveRequest({ assets: assetsPicked, tag }),
        confirmText: `Yes, remove tag from ${suffix}`,
        headerTitle: "Confirm tag removal",
        id: "confirm",
        title: `Remove tag ${tag.name.current} from ${suffix}?`,
        tone: "critical",
        type: "confirm"
      });
    },
    showConfirmDeleteAssets(state, action) {
      const { assets, closeDialogId } = action.payload, suffix = `${assets.length} ${(0, import_pluralize.default)("asset", assets.length)}`;
      state.items.push({
        closeDialogId,
        confirmCallbackAction: assetsActions.deleteRequest({
          assets: assets.map((assetItem) => assetItem.asset)
        }),
        confirmText: `Yes, delete ${suffix}`,
        description: "This operation cannot be reversed. Are you sure you want to continue?",
        title: `Permanently delete ${suffix}?`,
        id: "confirm",
        headerTitle: "Confirm deletion",
        tone: "critical",
        type: "confirm"
      });
    },
    showConfirmDeleteTag(state, action) {
      const { closeDialogId, tag } = action.payload, suffix = "tag";
      state.items.push({
        closeDialogId,
        confirmCallbackAction: tagsActions.deleteRequest({ tag }),
        confirmText: `Yes, delete ${suffix}`,
        description: "This operation cannot be reversed. Are you sure you want to continue?",
        title: `Permanently delete ${suffix}?`,
        id: "confirm",
        headerTitle: "Confirm deletion",
        tone: "critical",
        type: "confirm"
      });
    },
    showAssetEdit(state, action) {
      const { assetId } = action.payload;
      state.items.push({
        assetId,
        id: assetId,
        type: "assetEdit"
      });
    },
    showSearchFacets(state) {
      state.items.push({
        id: "searchFacets",
        type: "searchFacets"
      });
    },
    showTags(state) {
      state.items.push({
        id: "tags",
        type: "tags"
      });
    }
  }
});
var dialogClearOnAssetUpdateEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.deleteComplete.type,
    assetsActions.updateComplete.type,
    tagsActions.deleteComplete.type,
    tagsActions.updateComplete.type
  ),
  filter(
    (action) => {
      var _a;
      return !!((_a = action == null ? void 0 : action.payload) == null ? void 0 : _a.closeDialogId);
    }
  ),
  mergeMap((action) => {
    var _a;
    const dialogId = (_a = action == null ? void 0 : action.payload) == null ? void 0 : _a.closeDialogId;
    return dialogId ? of(dialogSlice.actions.remove({ id: dialogId })) : EMPTY;
  })
);
var dialogTagCreateEpic = (action$) => action$.pipe(
  filter(tagsActions.createComplete.match),
  mergeMap((action) => {
    const { assetId, tag } = action == null ? void 0 : action.payload;
    return assetId ? of(dialogSlice.actions.inlineTagCreate({ tag, assetId })) : tag._id ? of(dialogSlice.actions.remove({ id: "tagCreate" })) : EMPTY;
  })
);
var dialogTagDeleteEpic = (action$) => action$.pipe(
  filter(tagsActions.listenerDeleteQueueComplete.match),
  mergeMap((action) => {
    const { tagIds } = action == null ? void 0 : action.payload;
    return of(dialogSlice.actions.inlineTagRemove({ tagIds }));
  })
);
var dialogActions = { ...dialogSlice.actions };
var dialogReducer = dialogSlice.reducer;
var ButtonViewGroup = () => {
  const dispatch = useDispatch(), view = useTypedSelector((state) => state.assets.view);
  return (0, import_jsx_runtime2.jsxs)(Inline, { space: 0, style: { whiteSpace: "nowrap" }, children: [
    (0, import_jsx_runtime2.jsx)(
      Button,
      {
        fontSize: 1,
        icon: ThLargeIcon,
        mode: view === "grid" ? "default" : "ghost",
        onClick: () => dispatch(assetsActions.viewSet({ view: "grid" })),
        style: {
          borderBottomRightRadius: 0,
          borderTopRightRadius: 0
        }
      }
    ),
    (0, import_jsx_runtime2.jsx)(
      Button,
      {
        fontSize: 1,
        icon: ThListIcon,
        mode: view === "table" ? "default" : "ghost",
        onClick: () => dispatch(assetsActions.viewSet({ view: "table" })),
        style: {
          borderBottomLeftRadius: 0,
          borderTopLeftRadius: 0
        }
      }
    )
  ] });
};
function usePortalPopoverProps() {
  const portal = usePortal();
  return {
    animate: true,
    constrainSize: true,
    floatingBoundary: portal.element,
    portal: true,
    referenceBoundary: portal.element
  };
}
var OrderSelect = () => {
  const dispatch = useDispatch(), order = useTypedSelector((state) => state.assets.order), popoverProps = usePortalPopoverProps();
  return (0, import_jsx_runtime2.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime2.jsx)(
        Button,
        {
          fontSize: 1,
          icon: SortIcon,
          mode: "bleed",
          padding: 3,
          text: getOrderTitle(order.field, order.direction)
        }
      ),
      id: "order",
      menu: (0, import_jsx_runtime2.jsx)(Menu, { children: ORDER_OPTIONS == null ? void 0 : ORDER_OPTIONS.map((item, index2) => {
        if (item) {
          const selected = order.field === item.field && order.direction === item.direction;
          return (0, import_jsx_runtime2.jsx)(
            MenuItem,
            {
              disabled: selected,
              fontSize: 1,
              iconRight: selected,
              onClick: () => dispatch(
                assetsActions.orderSet({
                  order: { direction: item.direction, field: item.field }
                })
              ),
              padding: 2,
              selected,
              space: 4,
              style: { minWidth: "200px" },
              text: getOrderTitle(item.field, item.direction)
            },
            index2
          );
        }
        return (0, import_jsx_runtime2.jsx)(MenuDivider, {}, index2);
      }) }),
      popover: popoverProps
    }
  );
};
var Progress = (props) => {
  const { loading } = props, { animationDuration, isFinished, progress } = useNProgress({
    animationDuration: 300,
    isAnimating: loading
  });
  return (0, import_jsx_runtime2.jsx)(
    Box,
    {
      style: {
        opacity: isFinished ? 0 : 1,
        transition: `opacity ${animationDuration}ms linear`
      },
      children: (0, import_jsx_runtime2.jsx)(
        Box,
        {
          style: {
            height: "1px",
            background: "rgba(255, 255, 255, 0.5)",
            position: "absolute",
            left: 0,
            top: 0,
            transition: `width ${animationDuration}ms linear`,
            width: `${progress * 100}%`
          }
        }
      )
    }
  );
};
var SCHEME_COLORS = {
  bg: {
    dark: hues.gray[950].hex,
    light: hues.gray[50].hex
  },
  bg2: {
    dark: hues.gray[900].hex,
    light: hues.gray[100].hex
  },
  inputEnabledBorder: {
    dark: studioTheme.color.dark.default.input.default.enabled.border,
    light: studioTheme.color.light.default.input.default.enabled.border
  },
  inputHoveredBorder: {
    dark: studioTheme.color.dark.default.input.default.hovered.border,
    light: studioTheme.color.light.default.input.default.hovered.border
  },
  mutedHoveredBg: {
    dark: studioTheme.color.dark.primary.muted.primary.hovered.bg,
    light: studioTheme.color.light.primary.muted.primary.hovered.bg
  },
  mutedHoveredFg: {
    dark: studioTheme.color.dark.primary.muted.primary.hovered.fg,
    light: studioTheme.color.light.primary.muted.primary.hovered.fg
  },
  mutedSelectedBg: {
    dark: studioTheme.color.dark.primary.muted.primary.selected.bg,
    light: studioTheme.color.light.primary.muted.primary.selected.bg
  },
  spotBlue: {
    dark: studioTheme.color.dark.primary.spot.blue,
    light: studioTheme.color.light.primary.spot.blue
  }
};
function getSchemeColor(scheme, colorKey) {
  var _a;
  return (_a = SCHEME_COLORS[colorKey]) == null ? void 0 : _a[scheme];
}
var Container$1 = dt(Box)(({ $scheme, theme }) => lt`
    background: ${getSchemeColor($scheme, "bg")};
    border-radius: ${rem(theme.sanity.radius[2])};
  `);
var SearchFacet = (props) => {
  const { children, facet } = props, scheme = useColorSchemeValue(), dispatch = useDispatch(), handleClose = () => {
    dispatch(searchActions.facetsRemoveById({ facetId: facet.id }));
  };
  return (0, import_jsx_runtime2.jsx)(Container$1, { padding: [2, 2, 1], $scheme: scheme, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: ["flex-start", "flex-start", "center"], direction: ["column", "column", "row"], children: [
    (0, import_jsx_runtime2.jsx)(Box, { paddingBottom: [3, 3, 0], paddingLeft: 1, paddingRight: 2, paddingTop: [1, 1, 0], children: (0, import_jsx_runtime2.jsx)(
      Label,
      {
        size: 0,
        style: {
          whiteSpace: "nowrap"
        },
        children: facet.title
      }
    ) }),
    (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", children: [
      children,
      (0, import_jsx_runtime2.jsx)(Box, { marginLeft: 1, paddingX: 2, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 0, children: (0, import_jsx_runtime2.jsx)(CloseIcon, { onClick: handleClose }) }) })
    ] })
  ] }) });
};
var TextInputNumber = (props) => {
  const { onValueChange, value, ...remainingProps } = props;
  return (0, import_jsx_runtime2.jsx)(
    TextInput,
    {
      ...remainingProps,
      onChange: (e2) => {
        const val = e2.target.value;
        (val === "" || /^[0-9\b]+$/.test(val)) && onValueChange(parseInt(val, 10) || "");
      },
      value: value ?? ""
    }
  );
};
var SearchFacetNumber = ({ facet }) => {
  const dispatch = useDispatch(), popoverProps = usePortalPopoverProps(), modifiers = facet == null ? void 0 : facet.modifiers, selectedModifier = (facet == null ? void 0 : facet.modifier) ? modifiers == null ? void 0 : modifiers.find((modifier) => modifier.name === (facet == null ? void 0 : facet.modifier)) : modifiers == null ? void 0 : modifiers[0], handleOperatorItemClick = (operatorType) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, operatorType }));
  }, handleModifierClick = (modifier) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, modifier: modifier.name }));
  }, handleValueChange = (value) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, value }));
  }, selectedOperatorType = facet.operatorType ?? "greaterThan";
  return (0, import_jsx_runtime2.jsxs)(SearchFacet, { facet, children: [
    (facet == null ? void 0 : facet.operatorTypes) && (0, import_jsx_runtime2.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ),
        id: "operators",
        menu: (0, import_jsx_runtime2.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime2.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime2.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    (0, import_jsx_runtime2.jsx)(Box, { marginX: 1, style: { maxWidth: "50px" }, children: (0, import_jsx_runtime2.jsx)(
      TextInputNumber,
      {
        fontSize: 1,
        onValueChange: handleValueChange,
        padding: 2,
        radius: 2,
        width: 2,
        value: facet == null ? void 0 : facet.value
      }
    ) }),
    modifiers && (0, import_jsx_runtime2.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: selectedModifier == null ? void 0 : selectedModifier.title
          }
        ),
        id: "modifier",
        menu: (0, import_jsx_runtime2.jsx)(Menu, { children: modifiers.map((modifier) => {
          const selected = modifier.name === facet.modifier;
          return (0, import_jsx_runtime2.jsx)(
            MenuItem,
            {
              disabled: selected,
              fontSize: 1,
              onClick: () => handleModifierClick(modifier),
              padding: 2,
              text: modifier.title
            },
            modifier.name
          );
        }) }),
        popover: popoverProps
      }
    )
  ] });
};
var SearchFacetSelect = ({ facet }) => {
  const dispatch = useDispatch(), popoverProps = usePortalPopoverProps(), options2 = facet == null ? void 0 : facet.options, selectedItem = options2 == null ? void 0 : options2.find((v2) => v2.name === (facet == null ? void 0 : facet.value)), handleListItemClick = (option) => {
    dispatch(searchActions.facetsUpdate({ name: facet.name, value: option.name }));
  }, handleOperatorItemClick = (operatorType) => {
    dispatch(searchActions.facetsUpdate({ name: facet.name, operatorType }));
  }, selectedOperatorType = (facet == null ? void 0 : facet.operatorType) ?? "is";
  return (0, import_jsx_runtime2.jsxs)(SearchFacet, { facet, children: [
    (facet == null ? void 0 : facet.operatorTypes) && (0, import_jsx_runtime2.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime2.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ) }),
        id: "operators",
        menu: (0, import_jsx_runtime2.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime2.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime2.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    (0, import_jsx_runtime2.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime2.jsx)(Button, { fontSize: 1, iconRight: SelectIcon, padding: 2, text: selectedItem == null ? void 0 : selectedItem.title }),
        id: "list",
        menu: (0, import_jsx_runtime2.jsx)(Menu, { children: options2 == null ? void 0 : options2.map((item, index2) => {
          const selected = item.name === (selectedItem == null ? void 0 : selectedItem.name);
          return (0, import_jsx_runtime2.jsx)(
            MenuItem,
            {
              disabled: selected,
              fontSize: 1,
              onClick: () => handleListItemClick(options2[index2]),
              padding: 2,
              text: item.title
            },
            item.name
          );
        }) }),
        popover: popoverProps
      }
    )
  ] });
};
var SearchFacetString = ({ facet }) => {
  const dispatch = useDispatch(), popoverProps = usePortalPopoverProps(), handleOperatorItemClick = (operatorType) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, operatorType }));
  }, handleChange = (e2) => {
    dispatch(searchActions.facetsUpdateById({ id: facet.id, value: e2.target.value }));
  }, selectedOperatorType = facet.operatorType;
  return (0, import_jsx_runtime2.jsxs)(SearchFacet, { facet, children: [
    (facet == null ? void 0 : facet.operatorTypes) && (0, import_jsx_runtime2.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ),
        id: "operators",
        menu: (0, import_jsx_runtime2.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime2.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime2.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    !operators[selectedOperatorType].hideInput && (0, import_jsx_runtime2.jsx)(Box, { marginLeft: 1, style: { maxWidth: "125px" }, children: (0, import_jsx_runtime2.jsx)(
      TextInput,
      {
        fontSize: 1,
        onChange: handleChange,
        padding: 2,
        radius: 2,
        width: 2,
        value: facet == null ? void 0 : facet.value
      }
    ) })
  ] });
};
var {
  fonts: {
    text: { sizes: themeTextSizes }
  },
  radius: themeRadius$1,
  space: themeSpace$1
} = studioTheme;
var reactSelectStyles$1 = (scheme) => ({
  control: (styles, { isDisabled, isFocused }) => {
    let boxShadow = "inset 0 0 0 1px var(--card-border-color)";
    return isFocused && (boxShadow = `inset 0 0 0 1px ${getSchemeColor(scheme, "inputEnabledBorder")},
        0 0 0 1px ${getSchemeColor(scheme, "bg2")},
        0 0 0 3px var(--card-focus-ring-color) !important`), {
      ...styles,
      backgroundColor: "var(--card-bg-color)",
      color: "inherit",
      border: "none",
      borderRadius: themeRadius$1[2],
      boxShadow,
      fontSize: themeTextSizes[1].fontSize,
      minHeight: "25px",
      opacity: isDisabled ? 0.5 : "inherit",
      outline: "none",
      transition: "none",
      "&:hover": {
        boxShadow: `inset 0 0 0 1px ${getSchemeColor(scheme, "inputHoveredBorder")}`
      }
    };
  },
  input: (styles) => ({
    ...styles,
    color: "var(--card-fg-color)",
    fontFamily: studioTheme.fonts.text.family,
    fontSize: themeTextSizes[1].fontSize,
    marginLeft: rem(themeSpace$1[2])
  }),
  menuList: (styles) => ({
    ...styles,
    padding: 0
  }),
  noOptionsMessage: (styles) => ({
    ...styles,
    fontFamily: studioTheme.fonts.text.family,
    fontSize: themeTextSizes[1].fontSize,
    lineHeight: "1em"
  }),
  option: (styles, { isFocused }) => ({
    ...styles,
    backgroundColor: isFocused ? getSchemeColor(scheme, "spotBlue") : "transparent",
    borderRadius: themeRadius$1[2],
    color: isFocused ? getSchemeColor(scheme, "bg") : "inherit",
    fontSize: themeTextSizes[1].fontSize,
    lineHeight: "1em",
    margin: 0,
    padding: rem(themeSpace$1[1]),
    "&:hover": {
      backgroundColor: getSchemeColor(scheme, "spotBlue"),
      color: getSchemeColor(scheme, "bg")
    }
  }),
  placeholder: (styles) => ({
    ...styles,
    fontSize: themeTextSizes[1].fontSize,
    marginLeft: rem(themeSpace$1[2]),
    paddingLeft: 0
  }),
  singleValue: (styles) => ({
    ...styles,
    alignItems: "center",
    display: "inline-flex",
    height: "100%",
    marginLeft: rem(themeSpace$1[2])
  }),
  valueContainer: (styles) => ({
    ...styles,
    margin: 0,
    padding: 0
  })
});
var ClearIndicator3 = (props) => (0, import_jsx_runtime2.jsx)(components.ClearIndicator, { ...props, children: (0, import_jsx_runtime2.jsx)(
  Box,
  {
    paddingRight: 1,
    style: {
      transform: "scale(0.85)"
    },
    children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 0, children: (0, import_jsx_runtime2.jsx)(CloseIcon, {}) })
  }
) });
var Menu$12 = (props) => (0, import_jsx_runtime2.jsx)(components.Menu, { ...props, children: (0, import_jsx_runtime2.jsx)(Card, { radius: 1, shadow: 2, children: props.children }) });
var MenuList$1 = (props) => {
  const { children } = props, MAX_ROWS = 5, OPTION_HEIGHT = 33;
  if (Array.isArray(children)) {
    const height = children.length > MAX_ROWS ? OPTION_HEIGHT * MAX_ROWS : children.length * OPTION_HEIGHT;
    return (0, import_jsx_runtime2.jsx)(
      Kr,
      {
        className: "media__custom-scrollbar",
        itemContent: (index2) => {
          const item = children[index2];
          return (0, import_jsx_runtime2.jsx)(Option$12, { ...item.props });
        },
        style: { height },
        totalCount: children.length
      }
    );
  }
  return (0, import_jsx_runtime2.jsx)(components.MenuList, { ...props, children });
};
var NoOptionsMessage3 = (props) => (0, import_jsx_runtime2.jsx)(components.NoOptionsMessage, { ...props, children: props.children });
var Option$12 = (props) => (0, import_jsx_runtime2.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime2.jsx)(components.Option, { ...props, children: (0, import_jsx_runtime2.jsx)(Box, { paddingY: 1, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, style: { color: "inherit" }, textOverflow: "ellipsis", children: props.children }) }) }) });
var SingleValue3 = (props) => (0, import_jsx_runtime2.jsx)(components.SingleValue, { ...props, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, textOverflow: "ellipsis", children: props.children }) });
var reactSelectComponents$1 = {
  ClearIndicator: ClearIndicator3,
  DropdownIndicator: null,
  IndicatorSeparator: null,
  Menu: Menu$12,
  MenuList: MenuList$1,
  NoOptionsMessage: NoOptionsMessage3,
  Option: Option$12,
  SingleValue: SingleValue3
};
var SearchFacetTags = ({ facet }) => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), tags = useTypedSelector((state) => selectTags(state)), tagsFetching = useTypedSelector((state) => state.tags.fetching), allTagOptions = getTagSelectOptions(tags), popoverProps = usePortalPopoverProps(), handleChange = (option) => {
    dispatch(
      searchActions.facetsUpdateById({
        id: facet.id,
        value: option
      })
    );
  }, handleOperatorItemClick = (operatorType) => {
    dispatch(
      searchActions.facetsUpdateById({
        id: facet.id,
        operatorType
      })
    );
  }, selectedOperatorType = facet.operatorType;
  return (0, import_jsx_runtime2.jsxs)(SearchFacet, { facet, children: [
    (facet == null ? void 0 : facet.operatorTypes) && (0, import_jsx_runtime2.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            fontSize: 1,
            iconRight: SelectIcon,
            padding: 2,
            text: operators[selectedOperatorType].label
          }
        ),
        id: "operators",
        menu: (0, import_jsx_runtime2.jsx)(Menu, { children: facet.operatorTypes.map((operatorType, index2) => operatorType ? (0, import_jsx_runtime2.jsx)(
          MenuItem,
          {
            disabled: operatorType === selectedOperatorType,
            fontSize: 1,
            onClick: () => handleOperatorItemClick(operatorType),
            padding: 2,
            space: 4,
            style: { minWidth: "150px" },
            text: operators[operatorType].label
          },
          operatorType
        ) : (0, import_jsx_runtime2.jsx)(MenuDivider, {}, index2)) }),
        popover: popoverProps
      }
    ),
    !operators[selectedOperatorType].hideInput && (0, import_jsx_runtime2.jsx)(Box, { marginX: 1, style: { width: "160px" }, children: (0, import_jsx_runtime2.jsx)(
      StateManagedSelect$1,
      {
        components: reactSelectComponents$1,
        instanceId: "facet-searchable",
        isClearable: true,
        isDisabled: tagsFetching,
        isSearchable: true,
        name: "tags",
        noOptionsMessage: () => "No tags",
        onChange: (value) => handleChange(value),
        options: allTagOptions,
        placeholder: tagsFetching ? "Loading..." : "Select...",
        styles: reactSelectStyles$1(scheme),
        value: facet == null ? void 0 : facet.value
      }
    ) })
  ] });
};
var StackContainer = dt(Flex)(({ theme }) => lt`
    > * {
      margin-bottom: ${rem(theme.sanity.space[2])};
    }
  `);
var SearchFacets = (props) => {
  const { layout = "inline" } = props, searchFacets = useTypedSelector((state) => state.search.facets), Items2 = searchFacets.map((facet) => {
    const key = facet.id;
    return facet.type === "number" ? (0, import_jsx_runtime2.jsx)(SearchFacetNumber, { facet }, key) : facet.type === "searchable" ? (0, import_jsx_runtime2.jsx)(SearchFacetTags, { facet }, key) : facet.type === "select" ? (0, import_jsx_runtime2.jsx)(SearchFacetSelect, { facet }, key) : facet.type === "string" ? (0, import_jsx_runtime2.jsx)(SearchFacetString, { facet }, key) : null;
  });
  if (layout === "inline")
    return searchFacets.length === 0 ? null : (0, import_jsx_runtime2.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime2.jsx)(Inline, { space: 2, children: Items2 }) });
  if (layout === "stack")
    return (0, import_jsx_runtime2.jsx)(StackContainer, { align: "flex-start", direction: "column", children: Items2 });
  throw Error("Invalid layout");
};
var ToolOptionsContext = (0, import_react17.createContext)(null);
var ToolOptionsProvider = ({ options: options2, children }) => {
  var _a, _b;
  const value = (0, import_react17.useMemo)(() => {
    var _a2, _b2, _c, _d;
    let creditLineExcludeSources;
    return ((_a2 = options2 == null ? void 0 : options2.creditLine) == null ? void 0 : _a2.excludeSources) && (creditLineExcludeSources = Array.isArray((_b2 = options2 == null ? void 0 : options2.creditLine) == null ? void 0 : _b2.excludeSources) ? options2.creditLine.excludeSources : [(_c = options2 == null ? void 0 : options2.creditLine) == null ? void 0 : _c.excludeSources]), {
      dropzone: { maxSize: options2 == null ? void 0 : options2.maximumUploadSize },
      creditLine: {
        enabled: ((_d = options2 == null ? void 0 : options2.creditLine) == null ? void 0 : _d.enabled) || false,
        excludeSources: creditLineExcludeSources
      }
    };
  }, [
    (_a = options2 == null ? void 0 : options2.creditLine) == null ? void 0 : _a.enabled,
    (_b = options2 == null ? void 0 : options2.creditLine) == null ? void 0 : _b.excludeSources,
    options2 == null ? void 0 : options2.maximumUploadSize
  ]);
  return (0, import_jsx_runtime2.jsx)(ToolOptionsContext.Provider, { value, children });
};
var useToolOptions = () => {
  const context = (0, import_react17.useContext)(ToolOptionsContext);
  if (!context)
    throw new Error("useToolOptions must be used within an ToolOptionsProvider");
  return context;
};
var SearchFacetsControl = () => {
  const dispatch = useDispatch(), assetTypes = useTypedSelector((state) => state.assets.assetTypes), searchFacets = useTypedSelector((state) => state.search.facets), selectedDocument = useTypedSelector((state) => state.selected.document), popoverProps = usePortalPopoverProps(), { creditLine } = useToolOptions(), isTool = !selectedDocument, filteredFacets = FACETS.filter((facet) => !(creditLine == null ? void 0 : creditLine.enabled) && (facet == null ? void 0 : facet.type) === "string" && (facet == null ? void 0 : facet.name) === "creditLine" ? false : facet.type === "group" || facet.type === "divider" ? true : isTool ? !(facet == null ? void 0 : facet.selectOnly) : facet.assetTypes.filter(
    (assetType) => assetTypes.includes(assetType)
  ).length > 0).filter((facet, index2, facets) => {
    const previousFacet = facets[index2 - 1];
    return !(facet.type === "divider" && (index2 === 0 || index2 === facets.length - 1) || facet.type === "divider" && (previousFacet == null ? void 0 : previousFacet.type) === "divider");
  }), hasSearchFacets = filteredFacets.length > 0, renderMenuFacets = (facets, level = 0) => (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: facets == null ? void 0 : facets.map((facet, index2) => {
    if (facet.type === "divider")
      return (0, import_jsx_runtime2.jsx)(MenuDivider, {}, index2);
    if (facet.type === "group")
      return (0, import_jsx_runtime2.jsx)(MenuGroup, { text: facet.title, title: facet.title, children: renderMenuFacets(facet.facets, level + 1) }, `group-${level}-${index2}`);
    if (facet) {
      const disabled = !facet.operatorTypes && !!searchFacets.find((v2) => v2.name === facet.name);
      return (0, import_jsx_runtime2.jsx)(
        MenuItem,
        {
          disabled,
          fontSize: 1,
          onClick: () => dispatch(searchActions.facetsAdd({ facet })),
          padding: 2,
          text: facet.title
        },
        facet.name
      );
    }
    return null;
  }) });
  return (0, import_jsx_runtime2.jsxs)(Flex, { children: [
    (0, import_jsx_runtime2.jsx)(
      MenuButton,
      {
        button: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            disabled: !hasSearchFacets,
            fontSize: 1,
            icon: AddIcon,
            mode: "bleed",
            space: 2,
            text: "Add filter",
            tone: "primary"
          }
        ),
        id: "facets",
        menu: (0, import_jsx_runtime2.jsx)(Menu, { children: renderMenuFacets(filteredFacets) }),
        popover: {
          ...popoverProps,
          placement: "right-start"
        }
      }
    ),
    searchFacets.length > 0 && (0, import_jsx_runtime2.jsx)(
      Button,
      {
        fontSize: 1,
        mode: "bleed",
        onClick: () => dispatch(searchActions.facetsClear()),
        text: "Clear"
      }
    )
  ] });
};
var TagIcon = () => (0, import_jsx_runtime2.jsxs)(
  "svg",
  {
    "data-sanity-icon": "media__tag",
    fill: "currentColor",
    height: "1em",
    stroke: "currentColor",
    strokeWidth: "0",
    viewBox: "0 0 512 512",
    width: "1em",
    children: [
      (0, import_jsx_runtime2.jsx)(
        "path",
        {
          d: "M435.25 48h-122.9a14.46 14.46 0 00-10.2 4.2L56.45 297.9a28.85 28.85 0 000 40.7l117 117a28.85 28.85 0 0040.7 0L459.75 210a14.46 14.46 0 004.2-10.2v-123a28.66 28.66 0 00-28.7-28.8z",
          fill: "none",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "32"
        }
      ),
      (0, import_jsx_runtime2.jsx)("path", { d: "M384 160a32 32 0 1132-32 32 32 0 01-32 32z" })
    ]
  }
);
var TextInputSearch = () => {
  const searchQuery = useTypedSelector((state) => state.search.query), dispatch = useDispatch(), handleChange = (e2) => {
    dispatch(searchActions.querySet({ searchQuery: e2.currentTarget.value }));
  }, handleClear = () => {
    dispatch(searchActions.querySet({ searchQuery: "" }));
  };
  return (0, import_jsx_runtime2.jsxs)(Box, { style: { position: "relative" }, children: [
    (0, import_jsx_runtime2.jsx)(
      TextInput,
      {
        fontSize: 1,
        icon: SearchIcon,
        onChange: handleChange,
        placeholder: "Search",
        radius: 2,
        value: searchQuery
      }
    ),
    searchQuery.length > 0 && (0, import_jsx_runtime2.jsx)(
      Flex,
      {
        align: "center",
        justify: "center",
        onClick: handleClear,
        style: {
          cursor: "pointer",
          height: "100%",
          opacity: 0.75,
          position: "absolute",
          right: 0,
          top: 0,
          width: "2em",
          zIndex: 1
          // force stacking context
        },
        children: (0, import_jsx_runtime2.jsx)(CloseIcon, {})
      }
    )
  ] });
};
var Controls = () => {
  const dispatch = useDispatch(), fetching = useTypedSelector((state) => state.assets.fetching), pageIndex = useTypedSelector((state) => state.assets.pageIndex), searchFacets = useTypedSelector((state) => state.search.facets), tagsPanelVisible = useTypedSelector((state) => state.tags.panelVisible), mediaIndex = useMediaIndex(), handleShowSearchFacetDialog = () => {
    dispatch(dialogActions.showSearchFacets());
  }, handleShowTagsDialog = () => {
    dispatch(dialogActions.showTags());
  }, toggleTagsPanelToggle = () => {
    dispatch(tagsActions.panelVisibleSet({ panelVisible: !tagsPanelVisible }));
  };
  return (0, import_jsx_runtime2.jsxs)(
    Box,
    {
      paddingY: 2,
      style: {
        borderBottom: "1px solid var(--card-border-color)",
        zIndex: 2
      },
      children: [
        (0, import_jsx_runtime2.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime2.jsx)(
          Flex,
          {
            align: "flex-start",
            direction: ["column", "column", "column", "column", "row"],
            justify: "space-between",
            children: (0, import_jsx_runtime2.jsxs)(
              Flex,
              {
                flex: 1,
                style: {
                  alignItems: "flex-start",
                  flex: 1,
                  height: "100%",
                  justifyContent: mediaIndex < 2 ? "space-between" : "flex-start",
                  position: "relative",
                  width: "100%"
                },
                children: [
                  (0, import_jsx_runtime2.jsx)(Box, { marginX: 2, style: { minWidth: "200px" }, children: (0, import_jsx_runtime2.jsx)(TextInputSearch, {}) }),
                  (0, import_jsx_runtime2.jsxs)(Box, { display: ["none", "none", "block"], children: [
                    (0, import_jsx_runtime2.jsx)(SearchFacets, {}),
                    (0, import_jsx_runtime2.jsx)(SearchFacetsControl, {})
                  ] }),
                  (0, import_jsx_runtime2.jsx)(Box, { display: ["block", "block", "none"], marginX: 2, children: (0, import_jsx_runtime2.jsxs)(Inline, { space: 2, style: { whiteSpace: "nowrap" }, children: [
                    (0, import_jsx_runtime2.jsx)(
                      Button,
                      {
                        fontSize: 1,
                        mode: "ghost",
                        onClick: handleShowSearchFacetDialog,
                        text: `Filters${searchFacets.length > 0 ? ` (${searchFacets.length})` : ""}`,
                        tone: "primary"
                      }
                    ),
                    (0, import_jsx_runtime2.jsx)(
                      Button,
                      {
                        fontSize: 1,
                        mode: "ghost",
                        onClick: handleShowTagsDialog,
                        text: "Tags",
                        tone: "primary"
                      }
                    )
                  ] }) })
                ]
              }
            )
          }
        ) }),
        (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", justify: ["space-between"], children: [
          (0, import_jsx_runtime2.jsx)(Box, { marginX: 2, children: (0, import_jsx_runtime2.jsx)(ButtonViewGroup, {}) }),
          (0, import_jsx_runtime2.jsxs)(Flex, { marginX: 2, children: [
            (0, import_jsx_runtime2.jsx)(OrderSelect, {}),
            (0, import_jsx_runtime2.jsx)(Box, { display: ["none", "none", "block"], marginLeft: 2, children: (0, import_jsx_runtime2.jsx)(
              Button,
              {
                fontSize: 1,
                icon: (0, import_jsx_runtime2.jsx)(Box, { style: { transform: "scale(0.75)" }, children: (0, import_jsx_runtime2.jsx)(TagIcon, {}) }),
                onClick: toggleTagsPanelToggle,
                mode: tagsPanelVisible ? "default" : "ghost",
                text: tagsPanelVisible ? "Tags" : ""
              }
            ) })
          ] })
        ] }) }),
        (0, import_jsx_runtime2.jsx)(Progress, { loading: fetching }, pageIndex)
      ]
    }
  );
};
var initialState$3 = {
  badConnection: false,
  enabled: false
};
var debugSlice = createSlice({
  name: "debug",
  initialState: initialState$3,
  reducers: {
    setBadConnection(state, action) {
      state.badConnection = action.payload;
    },
    toggleEnabled(state) {
      state.enabled = !state.enabled;
    }
  }
});
var debugActions = { ...debugSlice.actions };
var debugReducer = debugSlice.reducer;
var DebugControls = () => {
  const dispatch = useDispatch(), badConnection = useTypedSelector((state) => state.debug.badConnection), debugEnabled = useTypedSelector((state) => state.debug.enabled), handleChange = (e2) => {
    const checked = e2.target.checked;
    dispatch(debugActions.setBadConnection(checked));
  };
  return useKeyPress("alt+ctrl+shift+/", () => {
    dispatch(debugActions.toggleEnabled());
  }), debugEnabled ? (0, import_jsx_runtime2.jsx)(
    Box,
    {
      padding: 4,
      style: {
        bottom: 0,
        left: 0,
        pointerEvents: "none",
        position: "fixed",
        width: "100%"
      },
      children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", children: [
        (0, import_jsx_runtime2.jsx)(Box, { marginRight: 3, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime2.jsx)(PlugIcon, {}) }) }),
        (0, import_jsx_runtime2.jsx)(
          Tooltip,
          {
            animate: true,
            content: (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: badConnection ? "Bad connection: +3000ms & 50% chance to fail" : "No connection throttling" }) }),
            fallbackPlacements: ["right", "left"],
            placement: "bottom",
            portal: true,
            children: (0, import_jsx_runtime2.jsx)(
              Switch,
              {
                checked: badConnection,
                onChange: handleChange,
                style: {
                  pointerEvents: "auto"
                }
              }
            )
          }
        )
      ] })
    }
  ) : null;
};
var tagOptionSchema = objectType({
  label: stringType().trim().min(1, { message: "Label cannot be empty" }),
  value: stringType().trim().min(1, { message: "Value cannot be empty" })
});
var assetFormSchema = objectType({
  altText: stringType().trim().optional(),
  creditLine: stringType().trim().optional(),
  description: stringType().trim().optional(),
  opt: objectType({
    media: objectType({
      tags: arrayType(tagOptionSchema).nullable()
    })
  }),
  originalFilename: stringType().trim().min(1, { message: "Filename cannot be empty" }),
  title: stringType().trim().optional()
});
var tagFormSchema = objectType({
  name: stringType().min(1, { message: "Name cannot be empty" })
});
function getUniqueDocuments(documents) {
  const draftIds = documents.reduce(
    (acc, doc) => doc._id.startsWith("drafts.") ? acc.concat(doc._id.slice(7)) : acc,
    []
  );
  return documents.filter(
    (doc) => !draftIds.includes(doc._id)
  );
}
var imageDprUrl = (asset, options2) => {
  const dpi = typeof window > "u" || !window.devicePixelRatio ? 1 : Math.round(window.devicePixelRatio), imgH = (options2 == null ? void 0 : options2.height) ? (options2 == null ? void 0 : options2.height) * Math.max(1, dpi) : void 0, imgW = options2.width * Math.max(1, dpi), urlParams = new URLSearchParams();
  return urlParams.append("fit", "max"), urlParams.append("w", imgW.toString()), imgH && urlParams.append("h", imgH.toString()), `${asset.url}?${urlParams.toString()}`;
};
var sanitizeFormData = (formData) => Object.keys(formData).reduce((acc, key) => {
  const val = formData[key];
  return typeof val == "object" && val !== null && val.constructor !== Array ? acc[key] = sanitizeFormData(val) : val === "" || typeof val > "u" || (val == null ? void 0 : val.length) === 0 ? acc[key] = null : typeof val == "string" && val ? acc[key] = formData[key].trim() : acc[key] = formData[key], acc;
}, {});
var isFileAsset = (asset) => asset._type === "sanity.fileAsset";
var isImageAsset = (asset) => asset._type === "sanity.imageAsset";
var getAssetResolution = (asset) => `${asset.metadata.dimensions.width}x${asset.metadata.dimensions.height}px`;
var ButtonAssetCopy = ({ disabled, url }) => {
  const popoverProps = usePortalPopoverProps(), refPopoverTimeout = (0, import_react17.useRef)(null), [popoverVisible, setPopoverVisible] = (0, import_react17.useState)(false), handleClick = () => {
    refPopoverTimeout.current && clearTimeout(refPopoverTimeout.current), setPopoverVisible(true), (0, import_copy_to_clipboard.default)(url), refPopoverTimeout.current = setTimeout(() => {
      setPopoverVisible(false);
    }, 1250);
  };
  return (0, import_react17.useEffect)(() => () => {
    refPopoverTimeout.current && clearTimeout(refPopoverTimeout.current);
  }, []), (0, import_jsx_runtime2.jsx)(
    Popover,
    {
      content: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: "Copied!" }),
      open: popoverVisible,
      padding: 2,
      placement: "top",
      radius: 1,
      ...popoverProps,
      children: (0, import_jsx_runtime2.jsx)(
        Button,
        {
          disabled,
          fontSize: 1,
          icon: ClipboardIcon,
          mode: "ghost",
          onClick: handleClick,
          text: "Copy URL"
        }
      )
    }
  );
};
var Row = ({ label, value }) => (0, import_jsx_runtime2.jsxs)(Flex, { justify: "space-between", children: [
  (0, import_jsx_runtime2.jsx)(
    Text,
    {
      size: 1,
      style: {
        opacity: 0.8,
        width: "40%"
      },
      textOverflow: "ellipsis",
      children: label
    }
  ),
  (0, import_jsx_runtime2.jsx)(
    Text,
    {
      size: 1,
      style: {
        opacity: 0.4,
        textAlign: "right",
        width: "60%"
      },
      textOverflow: "ellipsis",
      children: value
    }
  )
] });
var AssetMetadata = (props) => {
  var _a;
  const { asset, item } = props, exif = (_a = asset == null ? void 0 : asset.metadata) == null ? void 0 : _a.exif, handleDownload = () => {
    window.location.href = `${asset.url}?dl=${asset.originalFilename}`;
  };
  return (0, import_jsx_runtime2.jsxs)(Box, { marginTop: 3, children: [
    (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [
      (0, import_jsx_runtime2.jsx)(Row, { label: "Size", value: filesize(asset == null ? void 0 : asset.size, { base: 10, round: 0 }) }),
      (0, import_jsx_runtime2.jsx)(Row, { label: "MIME type", value: asset == null ? void 0 : asset.mimeType }),
      (0, import_jsx_runtime2.jsx)(Row, { label: "Extension", value: (asset == null ? void 0 : asset.extension).toUpperCase() }),
      isImageAsset(asset) && (0, import_jsx_runtime2.jsx)(Row, { label: "Dimensions", value: getAssetResolution(asset) })
    ] }) }),
    exif && (exif.DateTimeOriginal || exif.FNumber || exif.FocalLength || exif.ExposureTime || exif.ISO) && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      (0, import_jsx_runtime2.jsx)(
        Box,
        {
          marginY: 4,
          style: {
            background: "var(--card-border-color)",
            height: "1px",
            width: "100%"
          }
        }
      ),
      (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [
        exif.ISO && (0, import_jsx_runtime2.jsx)(Row, { label: "ISO", value: exif.ISO }),
        exif.FNumber && (0, import_jsx_runtime2.jsx)(Row, { label: "Aperture", value: `ƒ/${exif.FNumber}` }),
        exif.FocalLength && (0, import_jsx_runtime2.jsx)(Row, { label: "Focal length", value: `${exif.FocalLength}mm` }),
        exif.ExposureTime && (0, import_jsx_runtime2.jsx)(Row, { label: "Exposure time", value: `1/${1 / exif.ExposureTime}` }),
        exif.DateTimeOriginal && (0, import_jsx_runtime2.jsx)(
          Row,
          {
            label: "Original date",
            value: format_default(new Date(exif.DateTimeOriginal), "PPp")
          }
        )
      ] }) })
    ] }),
    (0, import_jsx_runtime2.jsx)(Box, { marginTop: 5, children: (0, import_jsx_runtime2.jsxs)(Inline, { space: 2, children: [
      (0, import_jsx_runtime2.jsx)(
        Button,
        {
          disabled: !item || (item == null ? void 0 : item.updating),
          fontSize: 1,
          icon: DownloadIcon,
          mode: "ghost",
          onClick: handleDownload,
          text: "Download"
        }
      ),
      (0, import_jsx_runtime2.jsx)(ButtonAssetCopy, { disabled: !item || (item == null ? void 0 : item.updating), url: asset.url })
    ] }) })
  ] });
};
var Dialog2 = (props) => (0, import_jsx_runtime2.jsx)(Dialog, { ...props, style: { position: "fixed" } });
var DocumentList = ({ documents, isLoading }) => {
  const schema = useSchema();
  return isLoading ? (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: "Loading..." }) : documents.length === 0 ? (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: "No documents are referencing this asset" }) : (0, import_jsx_runtime2.jsx)(Card, { flex: 1, marginBottom: 2, padding: 2, radius: 2, shadow: 1, children: (0, import_jsx_runtime2.jsx)(Stack, { space: 2, children: documents == null ? void 0 : documents.map((doc) => (0, import_jsx_runtime2.jsx)(ReferringDocument, { doc, schemaType: schema.get(doc._type) }, doc._id)) }) });
};
var ReferringDocument = (props) => {
  const { doc, schemaType } = props, { onClick } = useIntentLink({
    intent: "edit",
    params: { id: doc._id }
  });
  return schemaType ? (0, import_jsx_runtime2.jsx)(Button, { mode: "bleed", onClick, padding: 2, style: { width: "100%" }, children: (0, import_jsx_runtime2.jsx)(Preview$1, { layout: "default", schemaType, value: doc }) }, doc._id) : (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsxs)(Text, { size: 1, children: [
    "A document of the unknown type ",
    (0, import_jsx_runtime2.jsx)("em", { children: doc._type })
  ] }) });
};
var Container2 = dt(Box)(({ theme }) => lt`
    text {
      font-family: ${theme.sanity.fonts.text.family} !important;
      font-size: 8px !important;
      font-weight: 500 !important;
    }
  `);
var FileIcon3 = (props) => {
  const { extension, onClick, width } = props;
  return (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "center", onClick, style: { height: "100%" }, children: (0, import_jsx_runtime2.jsx)(Container2, { style: { width }, children: extension ? (0, import_jsx_runtime2.jsx)(
    FileIcon,
    {
      extension,
      ...defaultStyles2[extension]
    }
  ) : (0, import_jsx_runtime2.jsx)(FileIcon, {}) }) });
};
var FileAssetPreview = (props) => {
  const { asset } = props;
  return asset.mimeType.search("audio") === 0 ? (0, import_jsx_runtime2.jsx)(Flex, { align: "center", justify: "center", style: { height: "100%" }, children: (0, import_jsx_runtime2.jsx)("audio", { controls: true, src: asset.url, style: { width: "100%" } }) }) : asset.mimeType.search("video") === 0 ? (0, import_jsx_runtime2.jsx)(
    "video",
    {
      controls: true,
      src: asset.url,
      style: {
        height: "100%",
        width: "100%"
      }
    }
  ) : (0, import_jsx_runtime2.jsx)(FileIcon3, { extension: asset.extension, width: "50%" });
};
var { radius: themeRadius, space: themeSpace } = studioTheme;
var reactSelectStyles = (scheme) => ({
  control: (styles, { isFocused }) => {
    let boxShadow = "inset 0 0 0 1px var(--card-border-color)";
    return isFocused && (boxShadow = `inset 0 0 0 1px ${getSchemeColor(scheme, "inputEnabledBorder")},
        0 0 0 1px var(--card-bg-color),
        0 0 0 3px var(--card-focus-ring-color) !important`), {
      ...styles,
      backgroundColor: "var(--card-bg-color)",
      color: "inherit",
      border: "none",
      borderRadius: themeRadius[1],
      boxShadow,
      margin: 0,
      minHeight: "35px",
      outline: "none",
      padding: rem(themeSpace[1]),
      transition: "none",
      "&:hover": {
        boxShadow: `inset 0 0 0 1px ${getSchemeColor(scheme, "inputHoveredBorder")}`
      }
    };
  },
  indicatorsContainer: (styles, { isDisabled }) => ({
    ...styles,
    opacity: isDisabled ? 0.25 : 1
  }),
  input: (styles) => ({
    ...styles,
    color: "var(--card-fg-color)",
    fontFamily: studioTheme.fonts.text.family,
    marginLeft: rem(themeSpace[2])
  }),
  menuList: (styles) => ({
    ...styles
  }),
  multiValue: (styles, { isDisabled }) => ({
    ...styles,
    backgroundColor: getSchemeColor(scheme, "mutedHoveredBg"),
    borderRadius: themeRadius[2],
    opacity: isDisabled ? 0.5 : 1
  }),
  multiValueLabel: () => ({
    color: getSchemeColor(scheme, "mutedHoveredFg"),
    fontSize: "inherit",
    padding: 0
  }),
  multiValueRemove: (styles) => ({
    ...styles,
    borderTopLeftRadius: 0,
    borderBottomLeftRadius: 0,
    svg: { color: getSchemeColor(scheme, "mutedHoveredFg") },
    "&:hover": {
      backgroundColor: getSchemeColor(scheme, "mutedSelectedBg")
    }
  }),
  noOptionsMessage: (styles) => ({
    ...styles,
    fontFamily: studioTheme.fonts.text.family,
    lineHeight: "1em"
  }),
  option: (styles, { isFocused }) => ({
    ...styles,
    backgroundColor: isFocused ? getSchemeColor(scheme, "spotBlue") : "transparent",
    borderRadius: themeRadius[2],
    color: isFocused ? getSchemeColor(scheme, "bg") : "inherit",
    padding: `${rem(themeSpace[1])} ${rem(themeSpace[2])}`,
    "&:hover": {
      backgroundColor: getSchemeColor(scheme, "spotBlue"),
      color: getSchemeColor(scheme, "bg")
    }
  }),
  placeholder: (styles) => ({
    ...styles,
    marginLeft: rem(themeSpace[2])
  }),
  valueContainer: (styles) => ({
    ...styles,
    margin: 0,
    padding: 0
  })
});
var DropdownIndicator3 = (props) => (0, import_jsx_runtime2.jsx)(components.DropdownIndicator, { ...props, children: (0, import_jsx_runtime2.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(ChevronDownIcon, {}) }) }) });
var Menu4 = (props) => (0, import_jsx_runtime2.jsx)(components.Menu, { ...props, children: (0, import_jsx_runtime2.jsx)(Card, { radius: 1, shadow: 2, children: props.children }) });
var MenuList3 = (props) => {
  const { children } = props, MAX_ROWS = 5, OPTION_HEIGHT = 37;
  if (Array.isArray(children)) {
    const height = children.length > MAX_ROWS ? OPTION_HEIGHT * MAX_ROWS : children.length * OPTION_HEIGHT;
    return (0, import_jsx_runtime2.jsx)(
      Kr,
      {
        className: "media__custom-scrollbar",
        itemContent: (index2) => {
          const item = children[index2];
          return (0, import_jsx_runtime2.jsx)(Option3, { ...item.props });
        },
        style: { height },
        totalCount: children.length
      }
    );
  }
  return (0, import_jsx_runtime2.jsx)(components.MenuList, { ...props, children });
};
var MultiValueLabel2 = (props) => (0, import_jsx_runtime2.jsx)(Box, { padding: 2, paddingRight: 1, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime2.jsx)(components.MultiValueLabel, { ...props }) }) });
var MultiValueRemove2 = (props) => (0, import_jsx_runtime2.jsx)(components.MultiValueRemove, { ...props, children: (0, import_jsx_runtime2.jsx)(CloseIcon, { color: "#1f2123" }) });
var Option3 = (props) => (0, import_jsx_runtime2.jsx)(Box, { paddingX: 1, paddingY: 1, children: (0, import_jsx_runtime2.jsx)(components.Option, { ...props, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", children: [
  props.data.__isNew__ && (0, import_jsx_runtime2.jsx)(AddIcon, { style: { marginRight: "3px" } }),
  props.children
] }) }) });
var reactSelectComponents = {
  DropdownIndicator: DropdownIndicator3,
  IndicatorSeparator: null,
  Menu: Menu4,
  MenuList: MenuList3,
  MultiValueLabel: MultiValueLabel2,
  MultiValueRemove: MultiValueRemove2,
  Option: Option3
};
var StyledErrorOutlineIcon = dt(ErrorOutlineIcon)(({ theme }) => ({
  color: theme.sanity.color.spot.red
}));
var FormFieldInputLabel = (props) => {
  const { description, error, label, name } = props;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    (0, import_jsx_runtime2.jsx)(Box, { marginY: 3, children: (0, import_jsx_runtime2.jsxs)(Inline, { space: 2, children: [
      (0, import_jsx_runtime2.jsx)(Text, { as: "label", htmlFor: name, size: 1, weight: "semibold", children: label }),
      error && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(
        Tooltip,
        {
          animate: true,
          content: (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsxs)(Text, { muted: true, size: 1, children: [
            (0, import_jsx_runtime2.jsx)(StyledErrorOutlineIcon, { style: { marginRight: "0.1em" } }),
            error
          ] }) }),
          fallbackPlacements: ["top", "left"],
          placement: "right",
          portal: true,
          children: (0, import_jsx_runtime2.jsx)(StyledErrorOutlineIcon, {})
        }
      ) })
    ] }) }),
    description && (0, import_jsx_runtime2.jsx)(Box, { marginY: 3, children: (0, import_jsx_runtime2.jsx)(Text, { htmlFor: name, muted: true, size: 1, children: description }) })
  ] });
};
var FormFieldInputTags = (props) => {
  const {
    control,
    description,
    disabled,
    error,
    label,
    name,
    onCreateTag,
    options: options2,
    placeholder,
    value
  } = props, scheme = useColorSchemeValue(), creating = useTypedSelector((state) => state.tags.creating), tagsFetching = useTypedSelector((state) => state.tags.fetching);
  return (0, import_jsx_runtime2.jsxs)(
    Box,
    {
      style: { zIndex: 2 },
      children: [
        (0, import_jsx_runtime2.jsx)(FormFieldInputLabel, { description, error, label, name }),
        (0, import_jsx_runtime2.jsx)(
          Controller,
          {
            control,
            defaultValue: value,
            name,
            render: ({ field }) => {
              const { onBlur, onChange: onChange2, value: controllerValue } = field;
              return (0, import_jsx_runtime2.jsx)(
                CreatableSelect$1,
                {
                  components: reactSelectComponents,
                  instanceId: "tags",
                  isClearable: false,
                  isDisabled: creating || disabled || tagsFetching,
                  isLoading: creating,
                  isMulti: true,
                  name,
                  noOptionsMessage: () => "No tags",
                  onBlur,
                  onChange: onChange2,
                  onCreateOption: onCreateTag,
                  options: options2,
                  placeholder: tagsFetching ? "Loading..." : placeholder,
                  styles: reactSelectStyles(scheme),
                  value: controllerValue
                }
              );
            }
          }
        )
      ]
    }
  );
};
var FormFieldInputText = (0, import_react17.forwardRef)((props, ref) => {
  const { description, disabled, error, label, name, placeholder, value, ...rest } = props;
  return (0, import_jsx_runtime2.jsxs)(Box, { children: [
    (0, import_jsx_runtime2.jsx)(FormFieldInputLabel, { description, error, label, name }),
    (0, import_jsx_runtime2.jsx)(
      TextInput,
      {
        ...rest,
        autoComplete: "off",
        autoFocus: true,
        defaultValue: value,
        disabled,
        id: name,
        name,
        placeholder,
        ref
      }
    )
  ] });
});
var FormFieldInputTextarea = (0, import_react17.forwardRef)((props, ref) => {
  const { description, disabled, error, label, name, placeholder, rows, value, ...rest } = props;
  return (0, import_jsx_runtime2.jsxs)(Box, { children: [
    (0, import_jsx_runtime2.jsx)(FormFieldInputLabel, { description, error, label, name }),
    (0, import_jsx_runtime2.jsx)(
      TextArea,
      {
        ...rest,
        autoComplete: "off",
        defaultValue: value,
        disabled,
        id: name,
        name,
        placeholder,
        ref,
        rows
      }
    )
  ] });
});
var FormSubmitButton = (props) => {
  const { disabled, isValid: isValid3, lastUpdated, onClick } = props;
  let content;
  return isValid3 ? lastUpdated ? content = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    "Last updated",
    (0, import_jsx_runtime2.jsx)("br", {}),
    " ",
    format_default(new Date(lastUpdated), "PPp")
  ] }) : content = "No unpublished changes" : content = "There are validation errors that need to be fixed before this document can be published", (0, import_jsx_runtime2.jsx)(
    Tooltip,
    {
      animate: true,
      content: (0, import_jsx_runtime2.jsx)(Box, { padding: 3, style: { maxWidth: "185px" }, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: content }) }),
      disabled: "ontouchstart" in window,
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime2.jsx)(Box, { children: (0, import_jsx_runtime2.jsx)(
        Button,
        {
          disabled,
          fontSize: 1,
          onClick,
          text: "Save and close",
          tone: "primary"
        }
      ) })
    }
  );
};
var Image$1 = dt.img`
  --checkerboard-color: ${(props) => props.$scheme ? getSchemeColor(props.$scheme, "bg2") : "inherit"};

  display: block;
  width: 100%;
  height: 100%;
  object-fit: contain;

  ${(props) => props.$showCheckerboard && lt`
      background-image: linear-gradient(45deg, var(--checkerboard-color) 25%, transparent 25%),
        linear-gradient(-45deg, var(--checkerboard-color) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, var(--checkerboard-color) 75%),
        linear-gradient(-45deg, transparent 75%, var(--checkerboard-color) 75%);
      background-size: 20px 20px;
      background-position: 0 0, 0 10px, 10px -10px, -10px 0;
    `}
`;
var DialogAssetEdit = (props) => {
  var _a;
  const {
    children,
    dialog: { assetId, id, lastCreatedTag, lastRemovedTagIds }
  } = props, client = useVersionedClient(), scheme = useColorSchemeValue(), documentStore = useDocumentStore(), dispatch = useDispatch(), assetItem = useTypedSelector((state) => selectAssetById(state, String(assetId))), tags = useTypedSelector(selectTags), assetUpdatedPrev = (0, import_react17.useRef)(void 0), [assetSnapshot, setAssetSnapshot] = (0, import_react17.useState)(assetItem == null ? void 0 : assetItem.asset), [tabSection, setTabSection] = (0, import_react17.useState)("details"), currentAsset = assetItem ? assetItem == null ? void 0 : assetItem.asset : assetSnapshot, allTagOptions = getTagSelectOptions(tags), assetTagOptions = useTypedSelector(selectTagSelectOptions(currentAsset)), { creditLine } = useToolOptions(), generateDefaultValues = (0, import_react17.useCallback)(
    (asset) => ({
      altText: (asset == null ? void 0 : asset.altText) || "",
      creditLine: (asset == null ? void 0 : asset.creditLine) || "",
      description: (asset == null ? void 0 : asset.description) || "",
      originalFilename: (asset == null ? void 0 : asset.originalFilename) || "",
      opt: { media: { tags: assetTagOptions } },
      title: (asset == null ? void 0 : asset.title) || ""
    }),
    [assetTagOptions]
  ), {
    control,
    // Read the formState before render to subscribe the form state through Proxy
    formState: { errors, isDirty: isDirty2, isValid: isValid3 },
    getValues,
    handleSubmit,
    register,
    reset,
    setValue
  } = useForm({
    defaultValues: generateDefaultValues(assetItem == null ? void 0 : assetItem.asset),
    mode: "onChange",
    resolver: t(assetFormSchema)
  }), formUpdating = !assetItem || (assetItem == null ? void 0 : assetItem.updating), handleClose = (0, import_react17.useCallback)(() => {
    dispatch(dialogActions.remove({ id }));
  }, [dispatch, id]), handleDelete = (0, import_react17.useCallback)(() => {
    (assetItem == null ? void 0 : assetItem.asset) && dispatch(
      dialogActions.showConfirmDeleteAssets({
        assets: [assetItem],
        closeDialogId: assetItem == null ? void 0 : assetItem.asset._id
      })
    );
  }, [assetItem, dispatch]), handleAssetUpdate = (0, import_react17.useCallback)((update) => {
    const { result, transition } = update;
    result && transition === "update" && setAssetSnapshot(result);
  }, []), handleCreateTag = (0, import_react17.useCallback)(
    (tagName) => {
      dispatch(
        tagsActions.createRequest({
          assetId: currentAsset == null ? void 0 : currentAsset._id,
          name: tagName
        })
      );
    },
    [currentAsset == null ? void 0 : currentAsset._id, dispatch]
  ), onSubmit = (0, import_react17.useCallback)(
    (formData) => {
      var _a2;
      if (!(assetItem == null ? void 0 : assetItem.asset))
        return;
      const sanitizedFormData = sanitizeFormData(formData);
      dispatch(
        assetsActions.updateRequest({
          asset: assetItem == null ? void 0 : assetItem.asset,
          closeDialogId: assetItem == null ? void 0 : assetItem.asset._id,
          formData: {
            ...sanitizedFormData,
            // Map tags to sanity references
            opt: {
              media: {
                ...sanitizedFormData.opt.media,
                tags: ((_a2 = sanitizedFormData.opt.media.tags) == null ? void 0 : _a2.map((tag) => ({
                  _ref: tag.value,
                  _type: "reference",
                  _weak: true
                }))) || null
              }
            }
          }
        })
      );
    },
    [assetItem == null ? void 0 : assetItem.asset, dispatch]
  );
  return (0, import_react17.useEffect)(() => {
    if (!(assetItem == null ? void 0 : assetItem.asset))
      return;
    const subscriptionAsset = client.listen(groq`*[_id == $id]`, { id: assetItem == null ? void 0 : assetItem.asset._id }).subscribe(handleAssetUpdate);
    return () => {
      subscriptionAsset == null ? void 0 : subscriptionAsset.unsubscribe();
    };
  }, [assetItem == null ? void 0 : assetItem.asset, client, handleAssetUpdate]), (0, import_react17.useEffect)(() => {
    if (lastCreatedTag) {
      const updatedTags = (getValues("opt.media.tags") || []).concat([lastCreatedTag]);
      setValue("opt.media.tags", updatedTags, { shouldDirty: true });
    }
  }, [getValues, lastCreatedTag, setValue]), (0, import_react17.useEffect)(() => {
    if (lastRemovedTagIds) {
      const updatedTags = (getValues("opt.media.tags") || []).filter((tag) => !lastRemovedTagIds.includes(tag.value));
      setValue("opt.media.tags", updatedTags, { shouldDirty: true });
    }
  }, [getValues, lastRemovedTagIds, setValue]), (0, import_react17.useEffect)(() => {
    assetUpdatedPrev.current !== (assetItem == null ? void 0 : assetItem.asset._updatedAt) && reset(generateDefaultValues(assetItem == null ? void 0 : assetItem.asset)), assetUpdatedPrev.current = assetItem == null ? void 0 : assetItem.asset._updatedAt;
  }, [assetItem == null ? void 0 : assetItem.asset, generateDefaultValues, reset]), currentAsset ? (0, import_jsx_runtime2.jsxs)(
    Dialog2,
    {
      animate: true,
      footer: (0, import_jsx_runtime2.jsx)(() => (0, import_jsx_runtime2.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime2.jsxs)(Flex, { justify: "space-between", children: [
        (0, import_jsx_runtime2.jsx)(
          Button,
          {
            disabled: formUpdating,
            fontSize: 1,
            mode: "bleed",
            onClick: handleDelete,
            text: "Delete",
            tone: "critical"
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          FormSubmitButton,
          {
            disabled: formUpdating || !isDirty2 || !isValid3,
            isValid: isValid3,
            lastUpdated: currentAsset == null ? void 0 : currentAsset._updatedAt,
            onClick: handleSubmit(onSubmit)
          }
        )
      ] }) }), {}),
      header: "Asset details",
      id,
      onClose: handleClose,
      width: 3,
      children: [
        (0, import_jsx_runtime2.jsxs)(Flex, { direction: ["column-reverse", "column-reverse", "row-reverse"], children: [
          (0, import_jsx_runtime2.jsx)(Box, { flex: 1, marginTop: [5, 5, 0], padding: 4, children: (0, import_jsx_runtime2.jsx)(WithReferringDocuments, { documentStore, id: currentAsset._id, children: ({ isLoading, referringDocuments }) => {
            var _a2, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
            const uniqueReferringDocuments = getUniqueDocuments(referringDocuments);
            return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
              (0, import_jsx_runtime2.jsxs)(TabList, { space: 2, children: [
                (0, import_jsx_runtime2.jsx)(
                  Tab,
                  {
                    "aria-controls": "details-panel",
                    disabled: formUpdating,
                    id: "details-tab",
                    label: "Details",
                    onClick: () => setTabSection("details"),
                    selected: tabSection === "details",
                    size: 2
                  }
                ),
                (0, import_jsx_runtime2.jsx)(
                  Tab,
                  {
                    "aria-controls": "references-panel",
                    disabled: formUpdating,
                    id: "references-tab",
                    label: `References${!isLoading && Array.isArray(uniqueReferringDocuments) ? ` (${uniqueReferringDocuments.length})` : ""}`,
                    onClick: () => setTabSection("references"),
                    selected: tabSection === "references",
                    size: 2
                  }
                )
              ] }),
              (0, import_jsx_runtime2.jsxs)(Box, { as: "form", marginTop: 4, onSubmit: handleSubmit(onSubmit), children: [
                !assetItem && (0, import_jsx_runtime2.jsx)(Card, { marginBottom: 3, padding: 3, radius: 2, shadow: 1, tone: "critical", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: "This file cannot be found – it may have been deleted." }) }),
                (0, import_jsx_runtime2.jsx)("button", { style: { display: "none" }, tabIndex: -1, type: "submit" }),
                (0, import_jsx_runtime2.jsx)(
                  TabPanel,
                  {
                    "aria-labelledby": "details",
                    hidden: tabSection !== "details",
                    id: "details-panel",
                    children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [
                      (0, import_jsx_runtime2.jsx)(
                        FormFieldInputTags,
                        {
                          control,
                          disabled: formUpdating,
                          error: (_c = (_b = (_a2 = errors == null ? void 0 : errors.opt) == null ? void 0 : _a2.media) == null ? void 0 : _b.tags) == null ? void 0 : _c.message,
                          label: "Tags",
                          name: "opt.media.tags",
                          onCreateTag: handleCreateTag,
                          options: allTagOptions,
                          placeholder: "Select or create...",
                          value: assetTagOptions
                        }
                      ),
                      (0, import_jsx_runtime2.jsx)(
                        FormFieldInputText,
                        {
                          ...register("originalFilename"),
                          disabled: formUpdating,
                          error: (_d = errors == null ? void 0 : errors.originalFilename) == null ? void 0 : _d.message,
                          label: "Filename",
                          name: "originalFilename",
                          value: currentAsset == null ? void 0 : currentAsset.originalFilename
                        }
                      ),
                      (0, import_jsx_runtime2.jsx)(
                        FormFieldInputText,
                        {
                          ...register("title"),
                          disabled: formUpdating,
                          error: (_e2 = errors == null ? void 0 : errors.title) == null ? void 0 : _e2.message,
                          label: "Title",
                          name: "title",
                          value: currentAsset == null ? void 0 : currentAsset.title
                        }
                      ),
                      (0, import_jsx_runtime2.jsx)(
                        FormFieldInputText,
                        {
                          ...register("altText"),
                          disabled: formUpdating,
                          error: (_f = errors == null ? void 0 : errors.altText) == null ? void 0 : _f.message,
                          label: "Alt Text",
                          name: "altText",
                          value: currentAsset == null ? void 0 : currentAsset.altText
                        }
                      ),
                      (0, import_jsx_runtime2.jsx)(
                        FormFieldInputTextarea,
                        {
                          ...register("description"),
                          disabled: formUpdating,
                          error: (_g = errors == null ? void 0 : errors.description) == null ? void 0 : _g.message,
                          label: "Description",
                          name: "description",
                          rows: 5,
                          value: currentAsset == null ? void 0 : currentAsset.description
                        }
                      ),
                      (creditLine == null ? void 0 : creditLine.enabled) && (0, import_jsx_runtime2.jsx)(
                        FormFieldInputText,
                        {
                          ...register("creditLine"),
                          error: (_h = errors == null ? void 0 : errors.creditLine) == null ? void 0 : _h.message,
                          label: "Credit",
                          name: "creditLine",
                          value: currentAsset == null ? void 0 : currentAsset.creditLine,
                          disabled: formUpdating || ((_j = creditLine == null ? void 0 : creditLine.excludeSources) == null ? void 0 : _j.includes((_i = currentAsset == null ? void 0 : currentAsset.source) == null ? void 0 : _i.name))
                        }
                      )
                    ] })
                  }
                ),
                (0, import_jsx_runtime2.jsx)(
                  TabPanel,
                  {
                    "aria-labelledby": "references",
                    hidden: tabSection !== "references",
                    id: "references-panel",
                    children: (0, import_jsx_runtime2.jsx)(Box, { marginTop: 5, children: (assetItem == null ? void 0 : assetItem.asset) && (0, import_jsx_runtime2.jsx)(
                      DocumentList,
                      {
                        documents: uniqueReferringDocuments,
                        isLoading
                      }
                    ) })
                  }
                )
              ] })
            ] });
          } }) }),
          (0, import_jsx_runtime2.jsxs)(Box, { flex: 1, padding: 4, children: [
            (0, import_jsx_runtime2.jsxs)(Box, { style: { aspectRatio: "1" }, children: [
              isFileAsset(currentAsset) && (0, import_jsx_runtime2.jsx)(FileAssetPreview, { asset: currentAsset }),
              isImageAsset(currentAsset) && (0, import_jsx_runtime2.jsx)(
                Image$1,
                {
                  draggable: false,
                  $scheme: scheme,
                  $showCheckerboard: !((_a = currentAsset == null ? void 0 : currentAsset.metadata) == null ? void 0 : _a.isOpaque),
                  src: imageDprUrl(currentAsset, { height: 600, width: 600 })
                }
              )
            ] }),
            currentAsset && (0, import_jsx_runtime2.jsx)(Box, { marginTop: 4, children: (0, import_jsx_runtime2.jsx)(AssetMetadata, { asset: currentAsset, item: assetItem }) })
          ] })
        ] }),
        children
      ]
    }
  ) : null;
};
var DialogConfirm = (props) => {
  const { children, dialog } = props, dispatch = useDispatch(), handleClose = () => {
    dispatch(dialogActions.remove({ id: dialog == null ? void 0 : dialog.id }));
  }, handleConfirm = () => {
    (dialog == null ? void 0 : dialog.closeDialogId) && dispatch(dialogActions.remove({ id: dialog == null ? void 0 : dialog.closeDialogId })), (dialog == null ? void 0 : dialog.confirmCallbackAction) && dispatch(dialog.confirmCallbackAction), handleClose();
  };
  return (0, import_jsx_runtime2.jsxs)(
    Dialog2,
    {
      animate: true,
      footer: (0, import_jsx_runtime2.jsx)(() => (0, import_jsx_runtime2.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime2.jsxs)(Flex, { justify: "space-between", children: [
        (0, import_jsx_runtime2.jsx)(Button, { fontSize: 1, mode: "bleed", onClick: handleClose, text: "Cancel" }),
        (0, import_jsx_runtime2.jsx)(
          Button,
          {
            fontSize: 1,
            onClick: handleConfirm,
            text: dialog == null ? void 0 : dialog.confirmText,
            tone: dialog == null ? void 0 : dialog.tone
          }
        )
      ] }) }), {}),
      header: (0, import_jsx_runtime2.jsx)(() => (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", children: [
        (0, import_jsx_runtime2.jsx)(Box, { paddingX: 1, children: (0, import_jsx_runtime2.jsx)(WarningOutlineIcon, {}) }),
        (0, import_jsx_runtime2.jsx)(Box, { marginLeft: 2, children: dialog == null ? void 0 : dialog.headerTitle })
      ] }), {}),
      id: "confirm",
      onClose: handleClose,
      width: 1,
      children: [
        (0, import_jsx_runtime2.jsx)(Box, { paddingX: 4, paddingY: 4, children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [
          (dialog == null ? void 0 : dialog.title) && (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: dialog.title }),
          (dialog == null ? void 0 : dialog.description) && (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime2.jsx)("em", { children: dialog.description }) })
        ] }) }),
        children
      ]
    }
  );
};
var DialogSearchFacets = (props) => {
  const {
    children,
    dialog: { id }
  } = props, dispatch = useDispatch(), handleClose = (0, import_react17.useCallback)(() => {
    dispatch(dialogActions.clear());
  }, []);
  return (0, import_jsx_runtime2.jsxs)(Dialog2, { animate: true, header: "Filters", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime2.jsxs)(Box, { padding: 3, children: [
      (0, import_jsx_runtime2.jsx)(SearchFacets, { layout: "stack" }),
      (0, import_jsx_runtime2.jsx)(SearchFacetsControl, {})
    ] }),
    children
  ] });
};
var DialogTagCreate = (props) => {
  var _a;
  const {
    children,
    dialog: { id }
  } = props, dispatch = useDispatch(), creating = useTypedSelector((state) => state.tags.creating), creatingError = useTypedSelector((state) => state.tags.creatingError), {
    // Read the formState before render to subscribe the form state through Proxy
    formState: { errors, isDirty: isDirty2, isValid: isValid3 },
    handleSubmit,
    register,
    setError
  } = useForm({
    defaultValues: {
      name: ""
    },
    mode: "onChange",
    resolver: t(tagFormSchema)
  }), formUpdating = creating, handleClose = () => {
    dispatch(dialogActions.clear());
  }, onSubmit = (formData) => {
    const sanitizedFormData = sanitizeFormData(formData);
    dispatch(tagsActions.createRequest({ name: sanitizedFormData.name }));
  };
  return (0, import_react17.useEffect)(() => {
    creatingError && setError("name", {
      message: creatingError == null ? void 0 : creatingError.message
    });
  }, [creatingError, setError]), (0, import_jsx_runtime2.jsxs)(Dialog2, { animate: true, footer: (0, import_jsx_runtime2.jsx)(() => (0, import_jsx_runtime2.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime2.jsx)(Flex, { justify: "flex-end", children: (0, import_jsx_runtime2.jsx)(
    FormSubmitButton,
    {
      disabled: formUpdating || !isDirty2 || !isValid3,
      isValid: isValid3,
      onClick: handleSubmit(onSubmit)
    }
  ) }) }), {}), header: "Create Tag", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime2.jsxs)(Box, { as: "form", padding: 4, onSubmit: handleSubmit(onSubmit), children: [
      (0, import_jsx_runtime2.jsx)("button", { style: { display: "none" }, tabIndex: -1, type: "submit" }),
      (0, import_jsx_runtime2.jsx)(
        FormFieldInputText,
        {
          ...register("name"),
          disabled: formUpdating,
          error: (_a = errors == null ? void 0 : errors.name) == null ? void 0 : _a.message,
          label: "Name",
          name: "name"
        }
      )
    ] }),
    children
  ] });
};
var DialogTagEdit = (props) => {
  var _a;
  const {
    children,
    dialog: { id, tagId }
  } = props, client = useVersionedClient(), dispatch = useDispatch(), tagItem = useTypedSelector((state) => selectTagById(state, String(tagId))), [tagSnapshot, setTagSnapshot] = (0, import_react17.useState)(tagItem == null ? void 0 : tagItem.tag), currentTag = tagItem ? tagItem == null ? void 0 : tagItem.tag : tagSnapshot, generateDefaultValues = (tag) => {
    var _a2;
    return {
      name: ((_a2 = tag == null ? void 0 : tag.name) == null ? void 0 : _a2.current) || ""
    };
  }, {
    // Read the formState before render to subscribe the form state through Proxy
    formState: { errors, isDirty: isDirty2, isValid: isValid3 },
    handleSubmit,
    register,
    reset,
    setError
  } = useForm({
    defaultValues: generateDefaultValues(tagItem == null ? void 0 : tagItem.tag),
    mode: "onChange",
    resolver: t(tagFormSchema)
  }), formUpdating = !tagItem || (tagItem == null ? void 0 : tagItem.updating), handleClose = () => {
    dispatch(dialogActions.remove({ id }));
  }, onSubmit = (formData) => {
    var _a2;
    if (!(tagItem == null ? void 0 : tagItem.tag))
      return;
    const sanitizedFormData = sanitizeFormData(formData);
    dispatch(
      tagsActions.updateRequest({
        closeDialogId: (_a2 = tagItem == null ? void 0 : tagItem.tag) == null ? void 0 : _a2._id,
        formData: {
          name: {
            _type: "slug",
            current: sanitizedFormData.name
          }
        },
        tag: tagItem == null ? void 0 : tagItem.tag
      })
    );
  }, handleDelete = () => {
    var _a2;
    (tagItem == null ? void 0 : tagItem.tag) && dispatch(
      dialogActions.showConfirmDeleteTag({
        closeDialogId: (_a2 = tagItem == null ? void 0 : tagItem.tag) == null ? void 0 : _a2._id,
        tag: tagItem == null ? void 0 : tagItem.tag
      })
    );
  }, handleTagUpdate = (0, import_react17.useCallback)(
    (update) => {
      const { result, transition } = update;
      result && transition === "update" && (setTagSnapshot(result), reset(generateDefaultValues(result)));
    },
    [reset]
  );
  return (0, import_react17.useEffect)(() => {
    var _a2;
    (tagItem == null ? void 0 : tagItem.error) && setError("name", {
      message: (_a2 = tagItem.error) == null ? void 0 : _a2.message
    });
  }, [setError, tagItem.error]), (0, import_react17.useEffect)(() => {
    if (!(tagItem == null ? void 0 : tagItem.tag))
      return;
    const subscriptionAsset = client.listen(groq`*[_id == $id]`, { id: tagItem == null ? void 0 : tagItem.tag._id }).subscribe(handleTagUpdate);
    return () => {
      subscriptionAsset == null ? void 0 : subscriptionAsset.unsubscribe();
    };
  }, [client, handleTagUpdate, tagItem == null ? void 0 : tagItem.tag]), currentTag ? (0, import_jsx_runtime2.jsxs)(Dialog2, { animate: true, footer: (0, import_jsx_runtime2.jsx)(() => {
    var _a2;
    return (0, import_jsx_runtime2.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime2.jsxs)(Flex, { justify: "space-between", children: [
      (0, import_jsx_runtime2.jsx)(
        Button,
        {
          disabled: formUpdating,
          fontSize: 1,
          mode: "bleed",
          onClick: handleDelete,
          text: "Delete",
          tone: "critical"
        }
      ),
      (0, import_jsx_runtime2.jsx)(
        FormSubmitButton,
        {
          disabled: formUpdating || !isDirty2 || !isValid3,
          isValid: isValid3,
          lastUpdated: (_a2 = tagItem == null ? void 0 : tagItem.tag) == null ? void 0 : _a2._updatedAt,
          onClick: handleSubmit(onSubmit)
        }
      )
    ] }) });
  }, {}), header: "Edit Tag", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime2.jsxs)(Box, { as: "form", padding: 4, onSubmit: handleSubmit(onSubmit), children: [
      !tagItem && (0, import_jsx_runtime2.jsx)(Card, { marginBottom: 3, padding: 3, radius: 2, shadow: 1, tone: "critical", children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: "This tag cannot be found – it may have been deleted." }) }),
      (0, import_jsx_runtime2.jsx)("button", { style: { display: "none" }, tabIndex: -1, type: "submit" }),
      (0, import_jsx_runtime2.jsx)(
        FormFieldInputText,
        {
          ...register("name"),
          disabled: formUpdating,
          error: (_a = errors == null ? void 0 : errors.name) == null ? void 0 : _a.message,
          label: "Name",
          name: "name"
        }
      )
    ] }),
    children
  ] }) : null;
};
var TagContainer = dt(Flex)`
  height: ${PANEL_HEIGHT}px;
`;
var ButtonContainer = dt(Flex)`
  @media (pointer: fine) {
    visibility: hidden;
  }

  @media (hover: hover) and (pointer: fine) {
    ${TagContainer}:hover & {
      visibility: visible;
    }
  }
`;
var TagButton = (props) => {
  const { disabled, icon, onClick, tone, tooltip } = props;
  return (0, import_jsx_runtime2.jsx)(
    Tooltip,
    {
      animate: true,
      content: (0, import_jsx_runtime2.jsx)(Container, { padding: 2, width: 0, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: tooltip }) }),
      disabled: "ontouchstart" in window,
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime2.jsx)(
        Button,
        {
          disabled,
          fontSize: 1,
          icon,
          mode: "bleed",
          onClick,
          padding: 2,
          tone
        }
      )
    }
  );
};
var Tag = (props) => {
  var _a, _b;
  const { actions, tag } = props, dispatch = useDispatch(), assetsPicked = useTypedSelector(selectAssetsPicked), isSearchFacetTag = useTypedSelector((state) => {
    var _a2;
    return selectIsSearchFacetTag(state, (_a2 = tag == null ? void 0 : tag.tag) == null ? void 0 : _a2._id);
  }), handleSearchFacetTagRemove = () => {
    dispatch(searchActions.facetsRemoveByTag({ tagId: tag.tag._id }));
  }, handleShowAddTagToAssetsDialog = () => {
    dispatch(dialogActions.showConfirmAssetsTagAdd({ assetsPicked, tag: tag.tag }));
  }, handleShowRemoveTagFromAssetsDialog = () => {
    dispatch(dialogActions.showConfirmAssetsTagRemove({ assetsPicked, tag: tag.tag }));
  }, handleShowTagDeleteDialog = () => {
    dispatch(dialogActions.showConfirmDeleteTag({ tag: tag.tag }));
  }, handleShowTagEditDialog = () => {
    var _a2;
    dispatch(DIALOG_ACTIONS.showTagEdit({ tagId: (_a2 = tag == null ? void 0 : tag.tag) == null ? void 0 : _a2._id }));
  }, handleSearchFacetTagAddOrUpdate = () => {
    var _a2, _b2, _c;
    const searchFacet = {
      ...inputs.tag,
      value: {
        label: (_b2 = (_a2 = tag == null ? void 0 : tag.tag) == null ? void 0 : _a2.name) == null ? void 0 : _b2.current,
        value: (_c = tag == null ? void 0 : tag.tag) == null ? void 0 : _c._id
      }
    };
    dispatch(
      isSearchFacetTag ? searchActions.facetsUpdate({
        name: "tag",
        operatorType: "references",
        value: searchFacet.value
      }) : searchActions.facetsAdd({ facet: searchFacet })
    );
  };
  return (0, import_jsx_runtime2.jsxs)(TagContainer, { align: "center", flex: 1, justify: "space-between", paddingLeft: 3, children: [
    (0, import_jsx_runtime2.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime2.jsx)(
      Text,
      {
        muted: true,
        size: 1,
        style: {
          opacity: (tag == null ? void 0 : tag.updating) ? 0.5 : 1,
          userSelect: "none"
        },
        textOverflow: "ellipsis",
        children: (_b = (_a = tag == null ? void 0 : tag.tag) == null ? void 0 : _a.name) == null ? void 0 : _b.current
      }
    ) }),
    (0, import_jsx_runtime2.jsxs)(ButtonContainer, { align: "center", style: { flexShrink: 0 }, children: [
      (actions == null ? void 0 : actions.includes("search")) && (0, import_jsx_runtime2.jsx)(
        TagButton,
        {
          disabled: tag == null ? void 0 : tag.updating,
          icon: isSearchFacetTag ? (0, import_jsx_runtime2.jsx)(CloseIcon, {}) : (0, import_jsx_runtime2.jsx)(SearchIcon, {}),
          onClick: isSearchFacetTag ? handleSearchFacetTagRemove : handleSearchFacetTagAddOrUpdate,
          tooltip: isSearchFacetTag ? "Remove filter" : "Filter by tag"
        }
      ),
      (actions == null ? void 0 : actions.includes("edit")) && (0, import_jsx_runtime2.jsx)(
        TagButton,
        {
          disabled: tag == null ? void 0 : tag.updating,
          icon: (0, import_jsx_runtime2.jsx)(EditIcon, {}),
          onClick: handleShowTagEditDialog,
          tone: "primary",
          tooltip: "Edit tag"
        }
      ),
      (actions == null ? void 0 : actions.includes("applyAll")) && (0, import_jsx_runtime2.jsx)(
        TagButton,
        {
          disabled: tag == null ? void 0 : tag.updating,
          icon: (0, import_jsx_runtime2.jsx)(ArrowUpIcon, {}),
          onClick: handleShowAddTagToAssetsDialog,
          tone: "primary",
          tooltip: "Add tag to selected assets"
        }
      ),
      (actions == null ? void 0 : actions.includes("removeAll")) && (0, import_jsx_runtime2.jsx)(
        TagButton,
        {
          disabled: tag == null ? void 0 : tag.updating,
          icon: (0, import_jsx_runtime2.jsx)(ArrowDownIcon, {}),
          onClick: handleShowRemoveTagFromAssetsDialog,
          tone: "critical",
          tooltip: "Remove tag from selected assets"
        }
      ),
      (actions == null ? void 0 : actions.includes("delete")) && (0, import_jsx_runtime2.jsx)(
        TagButton,
        {
          disabled: tag == null ? void 0 : tag.updating,
          icon: (0, import_jsx_runtime2.jsx)(TrashIcon, {}),
          onClick: handleShowTagDeleteDialog,
          tone: "critical",
          tooltip: "Delete tag"
        }
      )
    ] })
  ] });
};
var VirtualRow$1 = (0, import_react17.memo)(
  ({
    isScrolling,
    item
  }) => {
    var _a;
    return typeof item == "string" ? (0, import_jsx_runtime2.jsx)(
      Flex,
      {
        align: "center",
        justify: "space-between",
        paddingX: 3,
        style: { height: `${PANEL_HEIGHT}px` },
        children: (0, import_jsx_runtime2.jsx)(Label, { size: 0, children: item })
      },
      item
    ) : (0, import_jsx_runtime2.jsx)(Tag, { actions: isScrolling ? void 0 : item.actions, tag: item }, (_a = item.tag) == null ? void 0 : _a._id);
  }
);
var TagsVirtualized = () => {
  const assetsPicked = useTypedSelector(selectAssetsPicked), tags = useTypedSelector(selectTags), [isScrolling, setIsScrolling] = (0, import_react17.useState)(false), pickedTagIds = assetsPicked == null ? void 0 : assetsPicked.reduce((acc, val) => {
    var _a, _b, _c, _d;
    const assetTagIds = ((_d = (_c = (_b = (_a = val == null ? void 0 : val.asset) == null ? void 0 : _a.opt) == null ? void 0 : _b.media) == null ? void 0 : _c.tags) == null ? void 0 : _d.map((tag) => tag._ref)) || [];
    return acc = acc.concat(assetTagIds), acc;
  }, []), pickedTagIdsUnique = [...new Set(pickedTagIds)], tagIdsSegmented = pickedTagIdsUnique.reduce(
    (acc, tagId) => (assetsPicked.every((assetItem) => {
      var _a, _b, _c;
      return (((_c = (_b = (_a = assetItem.asset.opt) == null ? void 0 : _a.media) == null ? void 0 : _b.tags) == null ? void 0 : _c.findIndex((tag) => tag._ref === tagId)) ?? -1) >= 0;
    }) ? acc.appliedToAll.push(tagId) : acc.appliedToSome.push(tagId), acc),
    {
      appliedToAll: [],
      appliedToSome: []
    }
  ), tagsAppliedToAll = tags.filter((tag) => tagIdsSegmented.appliedToAll.includes(tag.tag._id)).map((tagItem) => ({
    ...tagItem,
    actions: ["delete", "edit", "removeAll", "search"]
  })), tagsAppliedToSome = tags.filter((tag) => tagIdsSegmented.appliedToSome.includes(tag.tag._id)).map((tagItem) => ({
    ...tagItem,
    actions: ["applyAll", "delete", "edit", "removeAll", "search"]
  })), tagsUnused = tags.filter((tag) => !pickedTagIdsUnique.includes(tag.tag._id)).map((tagItem) => ({
    ...tagItem,
    actions: ["applyAll", "delete", "edit", "search"]
  }));
  let items = [];
  return assetsPicked.length === 0 ? items = tags.map((tagItem) => ({
    ...tagItem,
    actions: ["delete", "edit", "search"]
  })) : ((tagsAppliedToAll == null ? void 0 : tagsAppliedToAll.length) > 0 && (items = [
    ...items,
    //
    assetsPicked.length === 1 ? "Used" : "Used by all",
    ...tagsAppliedToAll
  ]), (tagsAppliedToSome == null ? void 0 : tagsAppliedToSome.length) > 0 && (items = [
    ...items,
    //
    "Used by some",
    ...tagsAppliedToSome
  ]), (tagsUnused == null ? void 0 : tagsUnused.length) > 0 && (items = [
    ...items,
    //
    "Unused",
    ...tagsUnused
  ])), (0, import_jsx_runtime2.jsx)(
    Kr,
    {
      className: "media__custom-scrollbar",
      computeItemKey: (index2) => {
        const item = items[index2];
        return typeof item == "string" ? item : item.tag._id;
      },
      isScrolling: setIsScrolling,
      itemContent: (index2) => (0, import_jsx_runtime2.jsx)(VirtualRow$1, { isScrolling, item: items[index2] }),
      style: { flex: 1, overflowX: "hidden" },
      totalCount: items.length
    }
  );
};
var TagViewHeader = ({ allowCreate, light, title }) => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), tagsCreating = useTypedSelector((state) => state.tags.creating), tagsFetching = useTypedSelector((state) => state.tags.fetching), handleTagCreate = () => {
    dispatch(DIALOG_ACTIONS.showTagCreate());
  };
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsxs)(
    Flex,
    {
      align: "center",
      justify: "space-between",
      paddingLeft: 3,
      style: {
        background: light ? getSchemeColor(scheme, "bg") : "inherit",
        borderBottom: "1px solid var(--card-border-color)",
        flexShrink: 0,
        height: `${PANEL_HEIGHT}px`
      },
      children: [
        (0, import_jsx_runtime2.jsxs)(Inline, { space: 2, children: [
          (0, import_jsx_runtime2.jsx)(Label, { size: 0, children: title }),
          tagsFetching && (0, import_jsx_runtime2.jsx)(Label, { size: 0, style: { opacity: 0.3 }, children: "Loading..." })
        ] }),
        allowCreate && (0, import_jsx_runtime2.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime2.jsx)(
          Button,
          {
            disabled: tagsCreating,
            fontSize: 1,
            icon: ComposeIcon,
            mode: "bleed",
            onClick: handleTagCreate,
            style: {
              background: "transparent",
              boxShadow: "none"
            }
          }
        ) })
      ]
    }
  ) });
};
var TagView = () => {
  const numPickedAssets = useTypedSelector(selectAssetsPickedLength), tags = useTypedSelector(selectTags), fetching = useTypedSelector((state) => state.tags.fetching), fetchComplete = useTypedSelector((state) => state.tags.fetchCount) !== -1, hasTags = !fetching && (tags == null ? void 0 : tags.length) > 0, hasPicked = numPickedAssets > 0;
  return (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", flex: 1, height: "fill", children: [
    (0, import_jsx_runtime2.jsx)(
      TagViewHeader,
      {
        allowCreate: true,
        light: hasPicked,
        title: hasPicked ? "Tags (in selection)" : "Tags"
      }
    ),
    fetchComplete && !hasTags && (0, import_jsx_runtime2.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime2.jsx)("em", { children: "No tags" }) }) }),
    hasTags && (0, import_jsx_runtime2.jsx)(TagsVirtualized, {})
  ] });
};
var DialogTags = (props) => {
  const {
    children,
    dialog: { id }
  } = props, dispatch = useDispatch(), handleClose = (0, import_react17.useCallback)(() => {
    dispatch(dialogActions.clear());
  }, []);
  return (0, import_jsx_runtime2.jsxs)(Dialog2, { animate: true, header: "All Tags", id, onClose: handleClose, width: 1, children: [
    (0, import_jsx_runtime2.jsx)(
      Box,
      {
        style: {
          height: "100%",
          minHeight: "420px"
          // explicit height required as <TagView> is virtualized
        },
        children: (0, import_jsx_runtime2.jsx)(TagView, {})
      }
    ),
    children
  ] });
};
var Dialogs = () => {
  const currentDialogs = useTypedSelector((state) => state.dialog.items), renderDialogs = (dialogs, index2) => {
    if (dialogs.length === 0 || index2 >= dialogs.length)
      return null;
    const dialog = dialogs[index2], childDialogs = renderDialogs(dialogs, index2 + 1);
    return dialog.type === "assetEdit" ? (0, import_jsx_runtime2.jsx)(DialogAssetEdit, { dialog, children: childDialogs }, index2) : dialog.type === "confirm" ? (0, import_jsx_runtime2.jsx)(DialogConfirm, { dialog, children: childDialogs }, index2) : dialog.type === "searchFacets" ? (0, import_jsx_runtime2.jsx)(DialogSearchFacets, { dialog, children: childDialogs }, index2) : dialog.type === "tagCreate" ? (0, import_jsx_runtime2.jsx)(DialogTagCreate, { dialog, children: childDialogs }, index2) : dialog.type === "tagEdit" ? (0, import_jsx_runtime2.jsx)(DialogTagEdit, { dialog, children: childDialogs }, index2) : dialog.type === "tags" ? (0, import_jsx_runtime2.jsx)(DialogTags, { dialog, children: childDialogs }, index2) : null;
  };
  return renderDialogs(currentDialogs, 0);
};
var DropzoneDispatchContext = (0, import_react17.createContext)(void 0);
var DropzoneDispatchProvider = (props) => {
  const { children, open } = props, contextValue = { open };
  return (0, import_jsx_runtime2.jsx)(DropzoneDispatchContext.Provider, { value: contextValue, children });
};
var useDropzoneActions = () => {
  const context = (0, import_react17.useContext)(DropzoneDispatchContext);
  if (context === void 0)
    throw new Error("useDropzoneActions must be used within an DropzoneDispatchProvider");
  return context;
};
var Header = (props) => {
  const { onClose } = props, { open } = useDropzoneActions(), { onSelect } = useAssetSourceActions(), assetTypes = useTypedSelector((state) => state.assets.assetTypes), selectedDocument = useTypedSelector((state) => state.selected.document);
  return (0, import_jsx_runtime2.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", justify: "space-between", children: [
    (0, import_jsx_runtime2.jsx)(Box, { flex: 1, marginX: 3, children: (0, import_jsx_runtime2.jsxs)(Inline, { style: { whiteSpace: "nowrap" }, children: [
      (0, import_jsx_runtime2.jsx)(Text, { textOverflow: "ellipsis", weight: "semibold", children: (0, import_jsx_runtime2.jsx)("span", { children: onSelect ? `Insert ${assetTypes.join(" or ")}` : "Browse Assets" }) }),
      selectedDocument && (0, import_jsx_runtime2.jsx)(Box, { display: ["none", "none", "block"], children: (0, import_jsx_runtime2.jsxs)(Text, { children: [
        (0, import_jsx_runtime2.jsx)("span", { style: { margin: "0 0.5em" }, children: (0, import_jsx_runtime2.jsx)(Icon, { symbol: "arrow-right" }) }),
        (0, import_jsx_runtime2.jsx)("span", { style: { textTransform: "capitalize" }, children: selectedDocument._type })
      ] }) })
    ] }) }),
    (0, import_jsx_runtime2.jsxs)(Flex, { marginX: 2, children: [
      (0, import_jsx_runtime2.jsx)(
        Button,
        {
          fontSize: 1,
          icon: UploadIcon,
          mode: "bleed",
          onClick: open,
          text: `Upload ${assetTypes.length === 1 ? (0, import_pluralize.default)(assetTypes[0]) : "assets"}`,
          tone: "primary"
        }
      ),
      onClose && (0, import_jsx_runtime2.jsx)(Box, { style: { flexShrink: 0 }, children: (0, import_jsx_runtime2.jsx)(
        Button,
        {
          disabled: !onClose,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          radius: 2
        }
      ) })
    ] })
  ] }) });
};
var useBreakpointIndex = () => {
  var _a, _b;
  const mediaQueryLists = (_b = (_a = studioTheme) == null ? void 0 : _a.container) == null ? void 0 : _b.map(
    (width) => window.matchMedia(`(max-width: ${width}px)`)
  ), getBreakpointIndex = () => mediaQueryLists.findIndex((mql) => mql.matches), [value, setValue] = (0, import_react17.useState)(getBreakpointIndex());
  return (0, import_react17.useEffect)(() => {
    const handleBreakpoint = () => {
      setValue(getBreakpointIndex);
    };
    return mediaQueryLists.forEach((mql) => {
      try {
        mql.addEventListener("change", handleBreakpoint);
      } catch {
        try {
          mql.addListener(handleBreakpoint);
        } catch {
        }
      }
    }), () => {
      try {
        mediaQueryLists.forEach((mql) => mql.removeEventListener("change", handleBreakpoint));
      } catch {
        try {
          mediaQueryLists.forEach((mql) => mql.removeListener(handleBreakpoint));
        } catch {
        }
      }
    };
  }, []), value;
};
var selectCombinedItems = createSelector(
  [
    (state) => state.assets.allIds,
    (state) => state.uploads.allIds
  ],
  (assetIds, uploadIds) => {
    const assetItems = assetIds.map((id) => ({ id, type: "asset" }));
    return [...uploadIds.map((id) => ({ id, type: "upload" })), ...assetItems];
  }
);
var CardWrapper$1 = dt(Flex)`
  box-sizing: border-box;
  height: 100%;
  overflow: hidden;
  position: relative;
  width: 100%;
`;
var CardContainer = dt(Flex)(
  ({ $picked, theme, $updating }) => lt`
      border: 1px solid transparent;
      height: 100%;
      pointer-events: ${$updating ? "none" : "auto"};
      position: relative;
      transition: all 300ms;
      user-select: none;
      width: 100%;

      border: ${$picked ? `1px solid ${theme.sanity.color.spot.orange} !important` : "1px solid inherit"};

      ${!$updating && lt`
        @media (hover: hover) and (pointer: fine) {
          &:hover {
            border: 1px solid var(--card-border-color);
          }
        }
      `}
    `
);
var ContextActionContainer$2 = dt(Flex)(
  ({ $scheme }) => lt`
      cursor: pointer;
      height: ${PANEL_HEIGHT}px;
      transition: all 300ms;
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg")};
        }
      }
    `
);
var StyledWarningOutlineIcon = dt(WarningFilledIcon)(({ theme }) => ({
  color: theme.sanity.color.spot.red
}));
var CardAsset = (props) => {
  var _a, _b;
  const { id, selected } = props, scheme = useColorSchemeValue(), shiftPressed = useKeyPress("shift"), dispatch = useDispatch(), lastPicked = useTypedSelector((state) => state.assets.lastPicked), item = useTypedSelector((state) => selectAssetById(state, id)), asset = item == null ? void 0 : item.asset, error = item == null ? void 0 : item.error, isOpaque = (_b = (_a = item == null ? void 0 : item.asset) == null ? void 0 : _a.metadata) == null ? void 0 : _b.isOpaque, picked = item == null ? void 0 : item.picked, updating = item == null ? void 0 : item.updating, { onSelect } = useAssetSourceActions();
  if (!asset)
    return null;
  const handleAssetClick = (e2) => {
    e2.stopPropagation(), onSelect ? onSelect([
      {
        kind: "assetDocumentId",
        value: asset._id
      }
    ]) : shiftPressed.current ? dispatch(picked ? assetsActions.pick({ assetId: asset._id, picked: !picked }) : assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(dialogActions.showAssetEdit({ assetId: asset._id }));
  }, handleContextActionClick = (e2) => {
    e2.stopPropagation(), onSelect ? dispatch(dialogActions.showAssetEdit({ assetId: asset._id })) : shiftPressed.current && !picked ? dispatch(assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(assetsActions.pick({ assetId: asset._id, picked: !picked }));
  }, opacityContainer = updating ? 0.5 : 1, opacityPreview = selected || updating ? 0.25 : 1;
  return (0, import_jsx_runtime2.jsx)(CardWrapper$1, { padding: 1, children: (0, import_jsx_runtime2.jsxs)(CardContainer, { direction: "column", $picked: picked, $updating: item.updating, children: [
    (0, import_jsx_runtime2.jsxs)(
      Box,
      {
        flex: 1,
        style: {
          cursor: selected ? "default" : "pointer",
          position: "relative"
        },
        children: [
          (0, import_jsx_runtime2.jsxs)("div", { onClick: handleAssetClick, style: { height: "100%", opacity: opacityPreview }, children: [
            isFileAsset(asset) && (0, import_jsx_runtime2.jsx)(FileIcon3, { extension: asset.extension, width: "80px" }),
            isImageAsset(asset) && (0, import_jsx_runtime2.jsx)(
              Image$1,
              {
                draggable: false,
                $scheme: scheme,
                $showCheckerboard: !isOpaque,
                src: imageDprUrl(asset, { height: 250, width: 250 }),
                style: {
                  draggable: false,
                  transition: "opacity 1000ms"
                }
              }
            )
          ] }),
          selected && !updating && (0, import_jsx_runtime2.jsx)(
            Flex,
            {
              align: "center",
              justify: "center",
              style: {
                height: "100%",
                left: 0,
                opacity: opacityContainer,
                position: "absolute",
                top: 0,
                width: "100%"
              },
              children: (0, import_jsx_runtime2.jsx)(Text, { size: 2, children: (0, import_jsx_runtime2.jsx)(CheckmarkCircleIcon, {}) })
            }
          ),
          updating && (0, import_jsx_runtime2.jsx)(
            Flex,
            {
              align: "center",
              justify: "center",
              style: {
                height: "100%",
                left: 0,
                position: "absolute",
                top: 0,
                width: "100%"
              },
              children: (0, import_jsx_runtime2.jsx)(Spinner, {})
            }
          )
        ]
      }
    ),
    (0, import_jsx_runtime2.jsxs)(
      ContextActionContainer$2,
      {
        align: "center",
        onClick: handleContextActionClick,
        paddingX: 1,
        $scheme: scheme,
        style: { opacity: opacityContainer },
        children: [
          onSelect ? (0, import_jsx_runtime2.jsx)(
            EditIcon,
            {
              style: {
                flexShrink: 0,
                opacity: 0.5
              }
            }
          ) : (0, import_jsx_runtime2.jsx)(
            Checkbox,
            {
              checked: picked,
              readOnly: true,
              style: {
                flexShrink: 0,
                pointerEvents: "none",
                transform: "scale(0.8)"
              }
            }
          ),
          (0, import_jsx_runtime2.jsx)(Box, { marginLeft: 2, children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 0, textOverflow: "ellipsis", children: asset.originalFilename }) })
        ]
      }
    ),
    error && (0, import_jsx_runtime2.jsx)(
      Box,
      {
        padding: 3,
        style: {
          position: "absolute",
          right: 0,
          top: 0
        },
        children: (0, import_jsx_runtime2.jsx)(
          Tooltip,
          {
            animate: true,
            content: (0, import_jsx_runtime2.jsx)(Container, { padding: 2, width: 0, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: error }) }),
            placement: "left",
            portal: true,
            children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(StyledWarningOutlineIcon, { color: "critical" }) })
          }
        )
      }
    )
  ] }) });
};
var CardAsset$1 = (0, import_react17.memo)(CardAsset);
var PREVIEW_WIDTH = 180;
var createBlob = (img) => new Promise((resolve) => {
  var _a;
  const imageAspect = img.width / img.height, canvas = document.createElement("canvas");
  canvas.width = PREVIEW_WIDTH, canvas.height = Math.max(PREVIEW_WIDTH / imageAspect, 1);
  try {
    (_a = canvas.getContext("2d")) == null ? void 0 : _a.drawImage(img, 0, 0, PREVIEW_WIDTH, PREVIEW_WIDTH / imageAspect), canvas.toBlob(resolve, "image/jpeg");
  } catch (err) {
    console.warn("Unable to generate preview image:", err);
  }
});
var createImageEl = (file) => new Promise((resolve) => {
  const blobUrlLarge = window.URL.createObjectURL(file), img = new Image();
  img.onload = () => {
    window.URL.revokeObjectURL(blobUrlLarge), resolve(img);
  }, img.src = blobUrlLarge;
});
var generatePreviewBlobUrl = async (file) => {
  const imageEl = await createImageEl(file), blob = await createBlob(imageEl);
  if (!blob)
    throw Error("Unable to generate file Blob");
  return window.URL.createObjectURL(blob);
};
var generatePreviewBlobUrl$ = (file) => of(null).pipe(mergeMap(() => from(generatePreviewBlobUrl(file))));
var DEFAULT_CONCURRENCY = 4;
function remove(array, item) {
  const index2 = array.indexOf(item);
  return index2 > -1 && array.splice(index2, 1), array;
}
var createThrottler = (concurrency = DEFAULT_CONCURRENCY) => {
  const currentSubscriptions = [], pendingObservables = [], ready$ = new Subject();
  function request(observable) {
    return new Observable((observer) => {
      if (currentSubscriptions.length >= concurrency)
        return scheduleAndWait$(observable).pipe(mergeMap(request)).subscribe(observer);
      const subscription = observable.subscribe(observer);
      return currentSubscriptions.push(subscription), () => {
        for (remove(currentSubscriptions, subscription), remove(pendingObservables, observable), subscription.unsubscribe(); pendingObservables.length > 0 && currentSubscriptions.length < concurrency; )
          ready$.next(pendingObservables.shift());
      };
    });
  }
  function scheduleAndWait$(observable) {
    return pendingObservables.push(observable), ready$.asObservable().pipe(first((obs) => obs === observable));
  }
  return request;
};
var withMaxConcurrency = (func, concurrency = DEFAULT_CONCURRENCY) => {
  const throttler = createThrottler(concurrency);
  return (...args) => from(throttler(func(...args)));
};
var fetchExisting$ = (client, type, hash2) => client.observable.fetch("*[_type == $documentType && sha1hash == $hash][0]", {
  documentType: type,
  hash: hash2
});
var readFile$ = (file) => new Observable((subscriber) => {
  const reader = new FileReader();
  return reader.onload = () => {
    subscriber.next(reader.result), subscriber.complete();
  }, reader.onerror = (err) => {
    subscriber.error(err);
  }, reader.readAsArrayBuffer(file), () => {
    reader.abort();
  };
});
var hexFromBuffer = (buffer) => Array.prototype.map.call(new Uint8Array(buffer), (x3) => `00${x3.toString(16)}`.slice(-2)).join("");
var hashFile$ = (file) => !window.crypto || !window.crypto.subtle || !window.FileReader ? throwError({
  message: "Unable to generate hash: uploads are only allowed in secure contexts",
  statusCode: 500
}) : readFile$(file).pipe(
  mergeMap((arrayBuffer) => window.crypto.subtle.digest("SHA-1", arrayBuffer)),
  map(hexFromBuffer)
);
var uploadSanityAsset$ = (client, assetType, file, hash2) => of(null).pipe(
  // NOTE: the sanity api will still dedupe unique files, but this saves us from uploading the asset file entirely
  mergeMap(() => fetchExisting$(client, `sanity.${assetType}Asset`, hash2)),
  // Cancel if the asset already exists
  mergeMap((existingAsset) => existingAsset ? throwError({
    message: "Asset already exists",
    statusCode: 409
  }) : of(null)),
  mergeMap(() => client.observable.assets.upload(assetType, file, {
    extract: ["blurhash", "exif", "location", "lqip", "palette"],
    preserveFilename: true
  }).pipe(
    map(
      (event) => event.type === "response" ? {
        // rewrite to a 'complete' event
        asset: event.body.document,
        id: event.body.document._id,
        type: "complete"
      } : event
    )
  ))
);
var uploadAsset$ = withMaxConcurrency(uploadSanityAsset$);
var initialState$2 = {
  allIds: [],
  byIds: {}
};
var uploadsSlice = createSlice({
  name: "uploads",
  initialState: initialState$2,
  extraReducers: (builder) => {
    builder.addCase(UPLOADS_ACTIONS.uploadComplete, (state, action) => {
      const { asset } = action.payload;
      state.byIds[asset.sha1hash] && (state.byIds[asset.sha1hash].status = "complete");
    });
  },
  reducers: {
    checkRequest(_state, _action) {
    },
    checkComplete(state, action) {
      const { results } = action.payload;
      Object.keys(results).forEach((hash2) => {
        const deleteIndex = state.allIds.indexOf(hash2);
        if (deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), state.byIds[hash2]) {
          const blobUrl = state.byIds[hash2].objectUrl;
          blobUrl && window.URL.revokeObjectURL(blobUrl), delete state.byIds[hash2];
        }
      });
    },
    previewReady(state, action) {
      const { blobUrl, hash: hash2 } = action.payload;
      state.byIds[hash2] && (state.byIds[hash2].objectUrl = blobUrl);
    },
    uploadCancel(state, action) {
      const { hash: hash2 } = action.payload, deleteIndex = state.allIds.indexOf(hash2);
      deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), state.byIds[hash2] && delete state.byIds[hash2];
    },
    uploadError(state, action) {
      const { hash: hash2 } = action.payload, deleteIndex = state.allIds.indexOf(hash2);
      deleteIndex >= 0 && state.allIds.splice(deleteIndex, 1), delete state.byIds[hash2];
    },
    uploadRequest(_state, _action) {
    },
    uploadProgress(state, action) {
      const { event, uploadHash } = action.payload;
      state.byIds[uploadHash].percent = event.percent, state.byIds[uploadHash].status = "uploading";
    },
    uploadStart(state, action) {
      const { uploadItem } = action.payload;
      state.allIds.includes(uploadItem.hash) || state.allIds.push(uploadItem.hash), state.byIds[uploadItem.hash] = uploadItem;
    }
  }
});
var uploadsAssetStartEpic = (action$, _state$, { client }) => action$.pipe(
  filter(uploadsActions.uploadStart.match),
  mergeMap((action) => {
    const { file, uploadItem } = action.payload;
    return merge(
      // Generate low res preview
      of(null).pipe(
        mergeMap(() => generatePreviewBlobUrl$(file)),
        mergeMap((url) => of(
          uploadsActions.previewReady({
            blobUrl: url,
            hash: uploadItem.hash
          })
        ))
      ),
      // Upload asset and receive progress / complete events
      of(null).pipe(
        // delay(500000), // debug uploads
        mergeMap(() => uploadAsset$(client, uploadItem.assetType, file, uploadItem.hash)),
        takeUntil(
          action$.pipe(
            filter(uploadsActions.uploadCancel.match),
            filter((v2) => v2.payload.hash === uploadItem.hash)
          )
        ),
        mergeMap((event) => (event == null ? void 0 : event.type) === "complete" ? of(
          UPLOADS_ACTIONS.uploadComplete({
            asset: event.asset
          })
        ) : (event == null ? void 0 : event.type) === "progress" && (event == null ? void 0 : event.stage) === "upload" ? of(
          uploadsActions.uploadProgress({
            event,
            uploadHash: uploadItem.hash
          })
        ) : empty()),
        catchError(
          (error) => of(
            uploadsActions.uploadError({
              error: {
                message: (error == null ? void 0 : error.message) || "Internal error",
                statusCode: (error == null ? void 0 : error.statusCode) || 500
              },
              hash: uploadItem.hash
            })
          )
        )
      )
    );
  })
);
var uploadsAssetUploadEpic = (action$, state$) => action$.pipe(
  filter(uploadsActions.uploadRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { file, forceAsAssetType } = action.payload;
    return of(action).pipe(
      // Generate SHA1 hash from local file
      // This will throw in insecure contexts (non-localhost / https)
      mergeMap(() => hashFile$(file)),
      // Ignore if the file exists and is currently being uploaded
      filter((hash2) => !state.uploads.byIds[hash2]),
      // Dispatch start action and begin upload process
      mergeMap((hash2) => {
        const uploadItem = {
          _type: "upload",
          assetType: forceAsAssetType || (file.type.indexOf("image") >= 0 ? "image" : "file"),
          hash: hash2,
          name: file.name,
          size: file.size,
          status: "queued"
        };
        return of(uploadsActions.uploadStart({ file, uploadItem }));
      })
    );
  })
);
var uploadsCompleteQueueEpic = (action$) => action$.pipe(
  filter(UPLOADS_ACTIONS.uploadComplete.match),
  mergeMap((action) => of(
    uploadsActions.checkRequest({
      assets: [action.payload.asset]
    })
  ))
);
var uploadsCheckRequestEpic = (action$, state$, { client }) => action$.pipe(
  filter(uploadsActions.checkRequest.match),
  withLatestFrom(state$),
  mergeMap(([action, state]) => {
    const { assets } = action.payload, documentIds = assets.map((asset) => asset._id), constructedFilter = constructFilter({
      assetTypes: state.assets.assetTypes,
      searchFacets: state.search.facets,
      searchQuery: state.search.query
    }), query = groq`
        *[${constructedFilter} && _id in $documentIds].sha1hash
      `;
    return of(action).pipe(
      delay(1e3),
      // give Sanity some time to register the recently uploaded asset
      mergeMap(() => client.observable.fetch(query, { documentIds })),
      mergeMap((resultHashes) => {
        const checkedResults = assets.reduce((acc, asset) => (acc[asset.sha1hash] = resultHashes.includes(asset.sha1hash) ? asset._id : null, acc), {});
        return of(
          uploadsActions.checkComplete({ results: checkedResults }),
          //
          assetsActions.insertUploads({ results: checkedResults })
        );
      })
    );
  })
);
var selectUploadsByIds = (state) => state.uploads.byIds;
var selectUploadsAllIds = (state) => state.uploads.allIds;
var selectUploadById = createSelector(
  [
    (state) => state.uploads.byIds,
    (_state, uploadId) => uploadId
  ],
  (byIds, uploadId) => byIds[uploadId]
);
createSelector(
  [selectUploadsByIds, selectUploadsAllIds],
  (byIds, allIds) => allIds.map((id) => byIds[id])
);
var uploadsActions = { ...uploadsSlice.actions };
var uploadsReducer = uploadsSlice.reducer;
var CardWrapper = dt(Flex)`
  box-sizing: border-box;
  height: 100%;
  overflow: hidden;
  position: relative;
  width: 100%;
`;
var CardUpload = (props) => {
  const { id } = props, scheme = useColorSchemeValue(), dispatch = useDispatch(), item = useTypedSelector((state) => selectUploadById(state, id));
  if (!item)
    return null;
  const fileSize = filesize(item.size, { base: 10, round: 0 }), percentLoaded = Math.round(item.percent || 0), isComplete = item.status === "complete", isUploading = item.status === "uploading", isQueued = item.status === "queued";
  let status;
  isComplete && (status = "Verifying"), isUploading && (status = `${percentLoaded}%`), isQueued && (status = "Queued");
  const handleCancelUpload = () => {
    dispatch(uploadsActions.uploadCancel({ hash: item.hash }));
  };
  return (0, import_jsx_runtime2.jsx)(CardWrapper, { padding: 1, children: (0, import_jsx_runtime2.jsxs)(
    Flex,
    {
      direction: "column",
      flex: 1,
      style: {
        background: getSchemeColor(scheme, "bg"),
        border: "1px solid transparent",
        height: "100%",
        position: "relative"
      },
      children: [
        (0, import_jsx_runtime2.jsx)(
          "div",
          {
            style: {
              background: "var(--card-fg-color)",
              bottom: 0,
              height: "1px",
              left: 0,
              position: "absolute",
              width: "100%",
              transform: `scaleX(${percentLoaded * 0.01})`,
              transformOrigin: "bottom left",
              transition: "all 1000ms ease-out"
            }
          }
        ),
        (0, import_jsx_runtime2.jsxs)(Box, { flex: 1, style: { position: "relative" }, children: [
          item.assetType === "image" && (item == null ? void 0 : item.objectUrl) && (0, import_jsx_runtime2.jsx)(
            Image$1,
            {
              draggable: false,
              $scheme: scheme,
              src: item.objectUrl,
              style: {
                opacity: 0.4
              }
            }
          ),
          item.assetType === "file" && (0, import_jsx_runtime2.jsx)("div", { style: { height: "100%", opacity: 0.1 }, children: (0, import_jsx_runtime2.jsx)(FileIcon3, { width: "80px" }) }),
          !isComplete && percentLoaded !== 100 && (0, import_jsx_runtime2.jsx)(
            Flex,
            {
              align: "center",
              direction: "column",
              justify: "center",
              style: {
                height: "100%",
                left: 0,
                position: "absolute",
                top: 0,
                width: "100%"
              },
              children: (0, import_jsx_runtime2.jsx)(
                Button,
                {
                  fontSize: 4,
                  icon: CloseIcon,
                  mode: "bleed",
                  onClick: handleCancelUpload,
                  padding: 2,
                  style: { background: "none", boxShadow: "none" },
                  tone: "critical"
                }
              )
            }
          )
        ] }),
        (0, import_jsx_runtime2.jsxs)(
          Flex,
          {
            align: "center",
            justify: "space-between",
            paddingX: 2,
            style: { height: `${PANEL_HEIGHT}px` },
            children: [
              (0, import_jsx_runtime2.jsx)(Box, { flex: 1, marginRight: 1, children: (0, import_jsx_runtime2.jsxs)(Text, { size: 0, textOverflow: "ellipsis", children: [
                item.name,
                " (",
                fileSize,
                ")"
              ] }) }),
              (0, import_jsx_runtime2.jsx)(Text, { size: 0, style: { flexShrink: 0 }, weight: "semibold", children: status })
            ]
          }
        )
      ]
    }
  ) });
};
var CARD_HEIGHT = 220;
var CARD_WIDTH = 240;
var VirtualCell = (0, import_react17.memo)(
  ({ item, selected }) => (item == null ? void 0 : item.type) === "asset" ? (0, import_jsx_runtime2.jsx)(CardAsset$1, { id: item.id, selected }) : (item == null ? void 0 : item.type) === "upload" ? (0, import_jsx_runtime2.jsx)(CardUpload, { id: item.id }) : null
);
var StyledItemContainer = dt.div`
  height: ${CARD_HEIGHT}px;
  width: ${CARD_WIDTH}px;
`;
function ItemContainer(props) {
  const { context, ...rest } = props;
  return (0, import_jsx_runtime2.jsx)(StyledItemContainer, { ...rest });
}
var StyledListContainer = dt.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, ${CARD_WIDTH}px);
  grid-template-rows: repeat(auto-fill, ${CARD_HEIGHT}px);
  justify-content: center;
  margin: 0 auto;
`;
function ListContainer(props) {
  const { context, ...rest } = props;
  return (0, import_jsx_runtime2.jsx)(StyledListContainer, { ...rest });
}
var AssetGridVirtualized = (props) => {
  const { items, onLoadMore } = props, selectedAssets = useTypedSelector((state) => state.selected.assets), selectedIds = selectedAssets && selectedAssets.map((asset) => asset._id) || [], totalCount = items == null ? void 0 : items.length;
  return totalCount === 0 ? null : (0, import_jsx_runtime2.jsx)(
    Yr,
    {
      className: "media__custom-scrollbar",
      computeItemKey: (index2) => {
        var _a;
        return (_a = items[index2]) == null ? void 0 : _a.id;
      },
      components: {
        Item: ItemContainer,
        List: ListContainer
      },
      endReached: onLoadMore,
      itemContent: (index2) => {
        const item = items[index2], selected = selectedIds.includes(item == null ? void 0 : item.id);
        return (0, import_jsx_runtime2.jsx)(VirtualCell, { item, selected });
      },
      overscan: 48,
      style: { overflowX: "hidden", overflowY: "scroll" },
      totalCount
    }
  );
};
var TableHeaderItem = (props) => {
  const { field, title } = props, dispatch = useDispatch(), order = useTypedSelector((state) => state.assets.order), isActive = order.field === field;
  return (0, import_jsx_runtime2.jsx)(Label, { muted: !field, size: 0, children: (0, import_jsx_runtime2.jsxs)(
    Box,
    {
      onClick: field ? () => {
        if (!(!field || !title))
          if (isActive) {
            const direction = order.direction === "asc" ? "desc" : "asc";
            dispatch(assetsActions.orderSet({ order: { field, direction } }));
          } else
            dispatch(assetsActions.orderSet({ order: { field, direction: "asc" } }));
      } : void 0,
      style: {
        cursor: field ? "pointer" : "default",
        display: "inline",
        whiteSpace: "nowrap"
      },
      children: [
        (0, import_jsx_runtime2.jsx)(
          "span",
          {
            style: {
              marginRight: "0.4em"
            },
            children: title
          }
        ),
        isActive && (order == null ? void 0 : order.direction) === "asc" && (0, import_jsx_runtime2.jsx)(ChevronUpIcon, {}),
        isActive && (order == null ? void 0 : order.direction) === "desc" && (0, import_jsx_runtime2.jsx)(ChevronDownIcon, {})
      ]
    }
  ) });
};
var ContextActionContainer$1 = dt(Flex)(
  ({ $scheme }) => lt`
      cursor: pointer;
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg")};
        }
      }
    `
);
var TableHeader = () => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), fetching = useTypedSelector((state) => state.assets.fetching), itemsLength = useTypedSelector(selectAssetsLength), numPickedAssets = useTypedSelector(selectAssetsPickedLength), mediaIndex = useMediaIndex(), { onSelect } = useAssetSourceActions(), allSelected = numPickedAssets === itemsLength, handleContextActionClick = (e2) => {
    e2.stopPropagation(), dispatch(allSelected ? assetsActions.pickClear() : assetsActions.pickAll());
  };
  return (0, import_jsx_runtime2.jsxs)(
    Grid,
    {
      style: {
        alignItems: "center",
        background: "var(--card-bg-color)",
        borderBottom: "1px solid var(--card-border-color)",
        gridColumnGap: mediaIndex < 3 ? 0 : "16px",
        gridTemplateColumns: GRID_TEMPLATE_COLUMNS.LARGE,
        height: mediaIndex < 3 ? 0 : `${PANEL_HEIGHT}px`,
        letterSpacing: "0.025em",
        position: "sticky",
        textTransform: "uppercase",
        top: 0,
        visibility: mediaIndex < 3 ? "hidden" : "visible",
        width: "100%",
        zIndex: 1
        // force stacking context
      },
      children: [
        onSelect ? (0, import_jsx_runtime2.jsx)(TableHeaderItem, {}) : (0, import_jsx_runtime2.jsx)(
          ContextActionContainer$1,
          {
            align: "center",
            justify: "center",
            onClick: handleContextActionClick,
            $scheme: scheme,
            style: {
              height: "100%",
              position: "relative"
            },
            children: (0, import_jsx_runtime2.jsx)(
              Checkbox,
              {
                checked: !fetching && allSelected,
                readOnly: true,
                style: {
                  pointerEvents: "none",
                  // TODO: consider alternative for usability
                  transform: "scale(0.8)"
                }
              }
            )
          }
        ),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, {}),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, { field: "originalFilename", title: "Filename" }),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, { title: "Resolution" }),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, { field: "mimeType", title: "MIME type" }),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, { field: "size", title: "Size" }),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, { field: "_updatedAt", title: "Last updated" }),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, { title: "References" }),
        (0, import_jsx_runtime2.jsx)(TableHeaderItem, {})
      ]
    }
  );
};
var REFERENCE_COUNT_VISIBILITY_DELAY = 750;
var ContainerGrid = dt(Grid)(({ $scheme, $selected, $updating }) => lt`
    align-items: center;
    cursor: ${$selected ? "default" : "pointer"};
    height: 100%;
    pointer-events: ${$updating ? "none" : "auto"};
    user-select: none;
    white-space: nowrap;

    ${!$updating && lt`
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg")};
        }
      }
    `}
  `);
var ContextActionContainer = dt(Flex)(
  ({ $scheme }) => lt`
      cursor: pointer;
      @media (hover: hover) and (pointer: fine) {
        &:hover {
          background: ${getSchemeColor($scheme, "bg2")};
        }
      }
    `
);
var StyledWarningIcon = dt(WarningFilledIcon)(({ theme }) => ({
  color: theme.sanity.color.spot.red
}));
var TableRowAsset = (props) => {
  var _a, _b;
  const { id, selected } = props, scheme = useColorSchemeValue(), shiftPressed = useKeyPress("shift"), [referenceCountVisible, setReferenceCountVisible] = (0, import_react17.useState)(false), refCountVisibleTimeout = (0, import_react17.useRef)(null), dispatch = useDispatch(), lastPicked = useTypedSelector((state) => state.assets.lastPicked), item = useTypedSelector((state) => selectAssetById(state, id)), mediaIndex = useMediaIndex(), asset = item == null ? void 0 : item.asset, error = item == null ? void 0 : item.error, isOpaque = (_b = (_a = item == null ? void 0 : item.asset) == null ? void 0 : _a.metadata) == null ? void 0 : _b.isOpaque, picked = item == null ? void 0 : item.picked, updating = item == null ? void 0 : item.updating, { onSelect } = useAssetSourceActions(), handleContextActionClick = (0, import_react17.useCallback)(
    (e2) => {
      e2.stopPropagation(), asset && (onSelect ? dispatch(dialogActions.showAssetEdit({ assetId: asset._id })) : shiftPressed.current && !picked ? dispatch(assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(assetsActions.pick({ assetId: asset._id, picked: !picked })));
    },
    [asset, dispatch, lastPicked, onSelect, picked, shiftPressed]
  ), handleClick = (0, import_react17.useCallback)(
    (e2) => {
      e2.stopPropagation(), asset && (onSelect ? onSelect([{ kind: "assetDocumentId", value: asset._id }]) : shiftPressed.current ? dispatch(picked ? assetsActions.pick({ assetId: asset._id, picked: !picked }) : assetsActions.pickRange({ startId: lastPicked || asset._id, endId: asset._id })) : dispatch(dialogActions.showAssetEdit({ assetId: asset._id })));
    },
    [asset, dispatch, lastPicked, onSelect, picked, shiftPressed]
  ), opacityCell = updating ? 0.5 : 1, opacityPreview = selected || updating ? 0.1 : 1;
  return (0, import_react17.useEffect)(() => (refCountVisibleTimeout.current = setTimeout(
    () => setReferenceCountVisible(true),
    REFERENCE_COUNT_VISIBILITY_DELAY
  ), () => {
    refCountVisibleTimeout.current && clearTimeout(refCountVisibleTimeout.current);
  }), []), asset ? (0, import_jsx_runtime2.jsxs)(
    ContainerGrid,
    {
      onClick: selected ? void 0 : handleClick,
      $scheme: scheme,
      $selected: selected,
      style: {
        gridColumnGap: mediaIndex < 3 ? 0 : "16px",
        gridRowGap: 0,
        gridTemplateColumns: mediaIndex < 3 ? GRID_TEMPLATE_COLUMNS.SMALL : GRID_TEMPLATE_COLUMNS.LARGE,
        gridTemplateRows: mediaIndex < 3 ? "auto" : "1fr"
      },
      $updating: item.updating,
      children: [
        (0, import_jsx_runtime2.jsx)(
          ContextActionContainer,
          {
            onClick: handleContextActionClick,
            $scheme: scheme,
            style: {
              alignItems: "center",
              gridColumn: 1,
              gridRowStart: 1,
              gridRowEnd: "span 5",
              height: "100%",
              justifyContent: "center",
              opacity: opacityCell,
              position: "relative"
            },
            children: onSelect ? (0, import_jsx_runtime2.jsx)(
              EditIcon,
              {
                style: {
                  flexShrink: 0,
                  opacity: 0.5
                }
              }
            ) : (0, import_jsx_runtime2.jsx)(
              Checkbox,
              {
                checked: picked,
                readOnly: true,
                style: {
                  pointerEvents: "none",
                  // TODO: consider alternative for usability
                  transform: "scale(0.8)"
                }
              }
            )
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            style: {
              gridColumn: 2,
              gridRowStart: 1,
              gridRowEnd: "span 5",
              height: "90px",
              width: "100px"
            },
            children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", justify: "center", style: { height: "100%", position: "relative" }, children: [
              (0, import_jsx_runtime2.jsxs)(Box, { style: { height: "100%", opacity: opacityPreview, position: "relative" }, children: [
                isFileAsset(asset) && (0, import_jsx_runtime2.jsx)(FileIcon3, { extension: asset.extension, width: "40px" }),
                isImageAsset(asset) && (0, import_jsx_runtime2.jsx)(
                  Image$1,
                  {
                    draggable: false,
                    $scheme: scheme,
                    $showCheckerboard: !isOpaque,
                    src: imageDprUrl(asset, { height: 100, width: 100 })
                  }
                )
              ] }),
              updating && (0, import_jsx_runtime2.jsx)(
                Flex,
                {
                  align: "center",
                  justify: "center",
                  style: {
                    height: "100%",
                    left: 0,
                    position: "absolute",
                    top: 0,
                    width: "100%"
                  },
                  children: (0, import_jsx_runtime2.jsx)(Spinner, {})
                }
              ),
              selected && !updating && (0, import_jsx_runtime2.jsx)(
                Flex,
                {
                  align: "center",
                  justify: "center",
                  style: {
                    height: "100%",
                    left: 0,
                    position: "absolute",
                    top: 0,
                    width: "100%"
                  },
                  children: (0, import_jsx_runtime2.jsx)(Text, { size: 2, children: (0, import_jsx_runtime2.jsx)(CheckmarkCircleIcon, {}) })
                }
              )
            ] })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            marginLeft: mediaIndex < 3 ? 3 : 0,
            style: {
              gridColumn: 3,
              gridRow: mediaIndex < 3 ? 2 : "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: asset.originalFilename })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            marginLeft: mediaIndex < 3 ? 3 : 0,
            style: {
              gridColumn: mediaIndex < 3 ? 3 : 4,
              gridRow: mediaIndex < 3 ? 3 : "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: isImageAsset(asset) && getAssetResolution(asset) })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            style: {
              display: mediaIndex < 3 ? "none" : "block",
              gridColumn: 5,
              gridRow: "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: asset.mimeType })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            style: {
              display: mediaIndex < 3 ? "none" : "block",
              gridColumn: 6,
              gridRow: "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: filesize(asset.size, { base: 10, round: 0 }) })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            marginLeft: mediaIndex < 3 ? 3 : 0,
            style: {
              gridColumn: mediaIndex < 3 ? 3 : 7,
              gridRow: mediaIndex < 3 ? 4 : "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: formatRelative_default(new Date(asset._updatedAt), /* @__PURE__ */ new Date()) })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            style: {
              display: mediaIndex < 3 ? "none" : "block",
              gridColumn: 8,
              gridRow: "auto",
              opacity: opacityCell
            },
            children: (0, import_jsx_runtime2.jsx)(Text, { muted: true, size: 1, style: { lineHeight: "2em" }, textOverflow: "ellipsis", children: referenceCountVisible ? (0, import_jsx_runtime2.jsx)(WithReferringDocuments, { id, children: ({ isLoading, referringDocuments }) => {
              const uniqueDocuments = getUniqueDocuments(referringDocuments);
              return isLoading ? (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: "-" }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: Array.isArray(uniqueDocuments) ? uniqueDocuments.length : 0 });
            } }) : (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: "-" }) })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Flex,
          {
            align: "center",
            justify: "center",
            style: {
              gridColumn: mediaIndex < 3 ? 4 : 9,
              gridRowStart: "1",
              gridRowEnd: mediaIndex < 3 ? "span 5" : "auto",
              opacity: opacityCell
            },
            children: error && (0, import_jsx_runtime2.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime2.jsx)(
              Tooltip,
              {
                animate: true,
                content: (0, import_jsx_runtime2.jsx)(Container, { padding: 2, width: 0, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: error }) }),
                placement: "left",
                portal: true,
                children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, children: (0, import_jsx_runtime2.jsx)(StyledWarningIcon, { color: "critical" }) })
              }
            ) })
          }
        )
      ]
    }
  ) : null;
};
var TableRowAsset$1 = (0, import_react17.memo)(TableRowAsset);
var TableRowUpload = (props) => {
  const { id } = props, scheme = useColorSchemeValue(), dispatch = useDispatch(), item = useTypedSelector((state) => selectUploadById(state, id)), mediaIndex = useMediaIndex();
  if (!item)
    return null;
  const fileSize = filesize(item.size, { base: 10, round: 0 }), percentLoaded = Math.round(item.percent || 0), isComplete = item.status === "complete", isUploading = item.status === "uploading", isQueued = item.status === "queued";
  let status;
  isComplete && (status = "Verifying"), isUploading && (status = `${percentLoaded}%`), isQueued && (status = "Queued");
  const handleCancelUpload = () => {
    dispatch(uploadsActions.uploadCancel({ hash: item.hash }));
  };
  return (0, import_jsx_runtime2.jsxs)(
    Grid,
    {
      style: {
        alignItems: "center",
        background: getSchemeColor(scheme, "bg"),
        gridColumnGap: mediaIndex < 3 ? 0 : "16px",
        gridRowGap: 0,
        gridTemplateColumns: mediaIndex < 3 ? GRID_TEMPLATE_COLUMNS.SMALL : GRID_TEMPLATE_COLUMNS.LARGE,
        gridTemplateRows: mediaIndex < 3 ? "auto" : "1fr",
        height: "100%",
        position: "relative"
      },
      children: [
        (0, import_jsx_runtime2.jsx)(
          "div",
          {
            style: {
              background: "var(--card-fg-color)",
              bottom: 0,
              height: "1px",
              left: 0,
              position: "absolute",
              width: "100%",
              transform: `scaleX(${percentLoaded * 0.01})`,
              transformOrigin: "bottom left",
              transition: "all 1000ms ease-out"
            }
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            style: {
              gridColumn: 2,
              gridRowStart: mediaIndex < 3 ? 1 : "auto",
              gridRowEnd: mediaIndex < 3 ? "span 4" : "auto",
              height: "90px",
              width: "100px"
            },
            children: (0, import_jsx_runtime2.jsxs)(Box, { style: { height: "100%", position: "relative" }, children: [
              item.assetType === "image" && (item == null ? void 0 : item.objectUrl) && (0, import_jsx_runtime2.jsx)(
                Image$1,
                {
                  draggable: false,
                  $scheme: scheme,
                  src: item.objectUrl,
                  style: { opacity: 0.25 }
                }
              ),
              item.assetType === "file" && (0, import_jsx_runtime2.jsx)("div", { style: { height: "100%", opacity: 0.1 }, children: (0, import_jsx_runtime2.jsx)(FileIcon3, { width: "40px" }) }),
              !isComplete && percentLoaded !== 100 && (0, import_jsx_runtime2.jsx)(
                Flex,
                {
                  align: "center",
                  justify: "center",
                  style: {
                    position: "absolute",
                    height: "100%",
                    left: 0,
                    top: 0,
                    width: "100%"
                  },
                  children: (0, import_jsx_runtime2.jsx)(
                    Button,
                    {
                      fontSize: 3,
                      icon: CloseIcon,
                      mode: "bleed",
                      onClick: handleCancelUpload,
                      padding: 2,
                      style: { background: "none", boxShadow: "none" },
                      tone: "critical"
                    }
                  )
                }
              )
            ] })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Box,
          {
            style: {
              gridColumn: mediaIndex < 3 ? 3 : "3/8",
              gridRow: mediaIndex < 3 ? "2/4" : "auto",
              marginLeft: mediaIndex < 3 ? 3 : 0
            },
            children: (0, import_jsx_runtime2.jsxs)(Stack, { space: 3, children: [
              (0, import_jsx_runtime2.jsxs)(Text, { muted: true, size: 1, textOverflow: "ellipsis", children: [
                item.name,
                " (",
                fileSize,
                ")"
              ] }),
              (0, import_jsx_runtime2.jsx)(Text, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: status })
            ] })
          }
        )
      ]
    }
  );
};
var VirtualRow = (0, import_react17.memo)(
  ({ item, selected }) => (item == null ? void 0 : item.type) === "asset" ? (0, import_jsx_runtime2.jsx)(Box, { style: { height: "100px" }, children: (0, import_jsx_runtime2.jsx)(TableRowAsset$1, { id: item.id, selected }) }) : (item == null ? void 0 : item.type) === "upload" ? (0, import_jsx_runtime2.jsx)(Box, { style: { height: "100px" }, children: (0, import_jsx_runtime2.jsx)(TableRowUpload, { id: item.id }) }) : null
);
var AssetTableVirtualized = (props) => {
  const { items, onLoadMore } = props, selectedAssets = useTypedSelector((state) => state.selected.assets), selectedIds = selectedAssets && selectedAssets.map((asset) => asset._id) || [], totalCount = items == null ? void 0 : items.length;
  return totalCount === 0 ? null : (0, import_jsx_runtime2.jsx)(
    jr,
    {
      className: "media__custom-scrollbar",
      computeItemKey: (index2) => {
        var _a;
        return ((_a = items[index2]) == null ? void 0 : _a.id) || index2;
      },
      endReached: onLoadMore,
      groupCounts: Array(1).fill(totalCount),
      groupContent: () => (0, import_jsx_runtime2.jsx)(TableHeader, {}),
      itemContent: (index2) => {
        const item = items[index2], selected = selectedIds.includes(item == null ? void 0 : item.id);
        return (0, import_jsx_runtime2.jsx)(VirtualRow, { item, selected });
      },
      style: { overflowX: "hidden" }
    }
  );
};
var Items = () => {
  const dispatch = useDispatch(), fetchCount = useTypedSelector((state) => state.assets.fetchCount), fetching = useTypedSelector((state) => state.assets.fetching), tagsPanelVisible = useTypedSelector((state) => state.tags.panelVisible), view = useTypedSelector((state) => state.assets.view), combinedItems = useTypedSelector(selectCombinedItems), breakpointIndex = useBreakpointIndex(), hasFetchedOnce = fetchCount >= 0, hasItems = combinedItems.length > 0, handleLoadMoreItems = () => {
    fetching || dispatch(assetsActions.loadNextPage());
  };
  return (0, import_react17.useEffect)(() => {
    breakpointIndex <= 1 && tagsPanelVisible && dispatch(tagsActions.panelVisibleSet({ panelVisible: false }));
  }, [breakpointIndex]), (0, import_jsx_runtime2.jsx)(Box, { flex: 1, style: { width: "100%" }, children: !hasItems && hasFetchedOnce && !fetching ? (0, import_jsx_runtime2.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime2.jsx)(Text, { size: 1, weight: "semibold", children: "No results for the current query" }) }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
    view === "grid" && (0, import_jsx_runtime2.jsx)(AssetGridVirtualized, { items: combinedItems, onLoadMore: handleLoadMoreItems }),
    view === "table" && (0, import_jsx_runtime2.jsx)(AssetTableVirtualized, { items: combinedItems, onLoadMore: handleLoadMoreItems })
  ] }) });
};
var Notifications = () => {
  const items = useTypedSelector((state) => state.notifications.items), toast = useToast();
  return (0, import_react17.useEffect)(() => {
    if (items.length > 0) {
      const lastItem = items[items.length - 1];
      toast.push({
        closable: true,
        status: lastItem.status,
        title: lastItem.title
      });
    }
  }, [items.length]), null;
};
var PickedBar = () => {
  const scheme = useColorSchemeValue(), dispatch = useDispatch(), assetsPicked = useTypedSelector(selectAssetsPicked), handlePickClear = () => {
    dispatch(assetsActions.pickClear());
  }, handleDeletePicked = () => {
    dispatch(dialogActions.showConfirmDeleteAssets({ assets: assetsPicked }));
  };
  return assetsPicked.length === 0 ? null : (0, import_jsx_runtime2.jsx)(
    Flex,
    {
      align: "center",
      justify: "flex-start",
      style: {
        background: getSchemeColor(scheme, "bg"),
        borderBottom: "1px solid var(--card-border-color)",
        height: `${PANEL_HEIGHT}px`,
        position: "relative",
        width: "100%"
      },
      children: (0, import_jsx_runtime2.jsxs)(Flex, { align: "center", paddingX: 3, children: [
        (0, import_jsx_runtime2.jsx)(Box, { paddingRight: 2, children: (0, import_jsx_runtime2.jsxs)(Label, { size: 0, style: { color: "inherit" }, children: [
          assetsPicked.length,
          " ",
          (0, import_pluralize.default)("asset", assetsPicked.length),
          " selected"
        ] }) }),
        (0, import_jsx_runtime2.jsx)(
          Button,
          {
            mode: "bleed",
            onClick: handlePickClear,
            padding: 2,
            style: { background: "none", boxShadow: "none" },
            tone: "default",
            children: (0, import_jsx_runtime2.jsx)(Label, { size: 0, children: "Deselect" })
          }
        ),
        (0, import_jsx_runtime2.jsx)(
          Button,
          {
            mode: "bleed",
            onClick: handleDeletePicked,
            padding: 2,
            style: { background: "none", boxShadow: "none" },
            tone: "critical",
            children: (0, import_jsx_runtime2.jsx)(Label, { size: 0, children: "Delete" })
          }
        )
      ] })
    }
  );
};
var initialState$1 = {
  assets: [],
  document: void 0,
  documentAssetIds: []
};
var selectedSlice = createSlice({
  name: "selected",
  initialState: initialState$1,
  reducers: {}
});
var selectedReducer = selectedSlice.reducer;
var initialState3 = {
  items: []
};
var notificationsSlice = createSlice({
  name: "notifications",
  initialState: initialState3,
  reducers: {
    add(state, action) {
      const { asset, status, title } = action.payload;
      state.items.push({
        asset,
        status,
        title
      });
    }
  }
});
var notificationsAssetsDeleteCompleteEpic = (action$) => action$.pipe(
  filter(assetsActions.deleteComplete.match),
  mergeMap((action) => {
    const { assetIds } = action.payload, deletedCount = assetIds.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `${deletedCount} ${(0, import_pluralize.default)("asset", deletedCount)} deleted`
      })
    );
  })
);
var notificationsAssetsDeleteErrorEpic = (action$) => action$.pipe(
  filter(assetsActions.deleteError.match),
  mergeMap((action) => {
    const { assetIds } = action.payload, count = assetIds.length;
    return of(
      notificationsSlice.actions.add({
        status: "error",
        title: `Unable to delete ${count} ${(0, import_pluralize.default)(
          "asset",
          count
        )}. Please review any asset errors and try again.`
      })
    );
  })
);
var notificationsAssetsTagsAddCompleteEpic = (action$) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsAddComplete.match),
  mergeMap((action) => {
    var _a, _b;
    const count = (_b = (_a = action == null ? void 0 : action.payload) == null ? void 0 : _a.assets) == null ? void 0 : _b.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `Tag added to ${count} ${(0, import_pluralize.default)("asset", count)}`
      })
    );
  })
);
var notificationsAssetsTagsRemoveCompleteEpic = (action$) => action$.pipe(
  filter(ASSETS_ACTIONS.tagsRemoveComplete.match),
  mergeMap((action) => {
    var _a, _b;
    const count = (_b = (_a = action == null ? void 0 : action.payload) == null ? void 0 : _a.assets) == null ? void 0 : _b.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `Tag removed from ${count} ${(0, import_pluralize.default)("asset", count)}`
      })
    );
  })
);
var notificationsAssetsUpdateCompleteEpic = (action$) => action$.pipe(
  filter(assetsActions.updateComplete.match),
  bufferTime(2e3),
  filter((actions) => actions.length > 0),
  mergeMap((actions) => {
    const updatedCount = actions.length;
    return of(
      notificationsSlice.actions.add({
        status: "info",
        title: `${updatedCount} ${(0, import_pluralize.default)("asset", updatedCount)} updated`
      })
    );
  })
);
var notificationsGenericErrorEpic = (action$) => action$.pipe(
  ofType(
    assetsActions.fetchError.type,
    assetsActions.updateError.type,
    tagsActions.createError.type,
    tagsActions.deleteError.type,
    tagsActions.fetchError.type,
    tagsActions.updateError.type,
    uploadsActions.uploadError.type
  ),
  mergeMap((action) => {
    var _a;
    const error = (_a = action.payload) == null ? void 0 : _a.error;
    return of(
      notificationsSlice.actions.add({
        status: "error",
        title: `An error occured: ${error.message}`
      })
    );
  })
);
var notificationsTagCreateCompleteEpic = (action$) => action$.pipe(
  filter(tagsActions.createComplete.match),
  mergeMap(() => of(notificationsSlice.actions.add({ status: "info", title: "Tag created" })))
);
var notificationsTagDeleteCompleteEpic = (action$) => action$.pipe(
  filter(tagsActions.deleteComplete.match),
  mergeMap(() => of(notificationsSlice.actions.add({ status: "info", title: "Tag deleted" })))
);
var notificationsTagUpdateCompleteEpic = (action$) => action$.pipe(
  filter(tagsActions.updateComplete.match),
  mergeMap(() => of(notificationsSlice.actions.add({ status: "info", title: "Tag updated" })))
);
var notificationsActions = { ...notificationsSlice.actions };
var notificationsReducer = notificationsSlice.reducer;
var rootEpic = combineEpics(
  assetsDeleteEpic,
  assetsFetchEpic,
  assetsFetchAfterDeleteAllEpic,
  assetsFetchNextPageEpic,
  assetsFetchPageIndexEpic,
  assetsListenerCreateQueueEpic,
  assetsListenerDeleteQueueEpic,
  assetsListenerUpdateQueueEpic,
  assetsOrderSetEpic,
  assetsSearchEpic,
  assetsSortEpic,
  assetsTagsAddEpic,
  assetsTagsRemoveEpic,
  assetsUnpickEpic,
  assetsUpdateEpic,
  dialogClearOnAssetUpdateEpic,
  dialogTagCreateEpic,
  dialogTagDeleteEpic,
  notificationsAssetsDeleteErrorEpic,
  notificationsAssetsDeleteCompleteEpic,
  notificationsAssetsTagsAddCompleteEpic,
  notificationsAssetsTagsRemoveCompleteEpic,
  notificationsAssetsUpdateCompleteEpic,
  notificationsGenericErrorEpic,
  notificationsTagCreateCompleteEpic,
  notificationsTagDeleteCompleteEpic,
  notificationsTagUpdateCompleteEpic,
  searchFacetTagUpdateEpic,
  tagsCreateEpic,
  tagsDeleteEpic,
  tagsFetchEpic,
  tagsListenerCreateQueueEpic,
  tagsListenerDeleteQueueEpic,
  tagsListenerUpdateQueueEpic,
  tagsSortEpic,
  tagsUpdateEpic,
  uploadsAssetStartEpic,
  uploadsAssetUploadEpic,
  uploadsCheckRequestEpic,
  uploadsCompleteQueueEpic
);
var reducers = {
  assets: assetsReducer,
  debug: debugReducer,
  dialog: dialogReducer,
  notifications: notificationsReducer,
  search: searchReducer,
  selected: selectedReducer,
  tags: tagsReducer,
  uploads: uploadsReducer
};
var rootReducer = combineReducers(reducers);
var isPlainObject3 = (value) => value !== null && typeof value == "object" && !Array.isArray(value);
var getAssetIds = (node2, acc = []) => {
  var _a, _b;
  return Array.isArray(node2) && node2.forEach((v2) => {
    getAssetIds(v2, acc);
  }), isPlainObject3(node2) && (((_a = node2 == null ? void 0 : node2.asset) == null ? void 0 : _a._type) === "reference" && ((_b = node2 == null ? void 0 : node2.asset) == null ? void 0 : _b._ref) && acc.push(node2.asset._ref), Object.values(node2).forEach((val) => {
    getAssetIds(val, acc);
  })), acc;
};
var getDocumentAssetIds = (document2) => {
  const assetIds = getAssetIds(document2);
  return [...new Set(assetIds.sort())];
};
var ReduxProvider = class extends import_react17.Component {
  constructor(props) {
    super(props);
    __publicField(this, "store");
    const epicMiddleware = createEpicMiddleware({
      dependencies: {
        client: props.client
        // inject sanity client as a dependency to all epics
      }
    });
    this.store = configureStore({
      reducer: rootReducer,
      middleware: (getDefaultMiddleware) => getDefaultMiddleware({
        /*
        serializableCheck: {
          ignoredActions: [
            assetsActions.deleteError.type,
            uploadsActions.uploadRequest.type,
            uploadsActions.uploadStart.type,
          ]
        },
        */
        // TODO: remove once we're no longer storing non-serializable data in the store
        serializableCheck: false,
        thunk: false
      }).prepend(epicMiddleware),
      devTools: true,
      preloadedState: {
        assets: {
          ...initialState$5,
          assetTypes: (props == null ? void 0 : props.assetType) ? [props.assetType] : ["file", "image"]
        },
        debug: {
          badConnection: false,
          enabled: false
        },
        dialog: { items: [] },
        notifications: { items: [] },
        search: { facets: [], query: "" },
        selected: {
          assets: props.selectedAssets || [],
          document: props.document,
          documentAssetIds: props.document ? getDocumentAssetIds(props.document) : []
        },
        tags: {
          allIds: [],
          byIds: {},
          creating: false,
          fetchCount: -1,
          fetching: false,
          panelVisible: true
        },
        uploads: {
          allIds: [],
          byIds: {}
        }
      }
    }), epicMiddleware.run(rootEpic);
  }
  render() {
    return (0, import_jsx_runtime2.jsx)(Provider_default, { store: this.store, children: this.props.children });
  }
};
var TagsPanel = () => useTypedSelector((state) => state.tags.panelVisible) ? (0, import_jsx_runtime2.jsx)(
  Box,
  {
    style: {
      position: "relative",
      width: TAGS_PANEL_WIDTH
    },
    children: (0, import_jsx_runtime2.jsx)(
      Box,
      {
        className: "media__custom-scrollbar",
        style: {
          borderLeft: "1px solid var(--card-border-color)",
          height: "100%",
          overflowX: "hidden",
          overflowY: "auto",
          position: "absolute",
          right: 0,
          top: 0,
          width: "100%"
        },
        children: (0, import_jsx_runtime2.jsx)(TagView, {})
      }
    )
  }
) : null;
var UploadContainer = dt.div`
  color: white;
  height: 100%;
  min-height: 100%;
  right: 0;
  top: 0;
  width: 100%;

  &:focus {
    outline: none;
  }
`;
var DragActiveContainer = dt.div`
  align-items: center;
  background: rgba(0, 0, 0, 0.75);
  display: flex;
  height: 100%;
  justify-content: center;
  position: absolute;
  right: 0;
  top: 0;
  width: 100%;
  z-index: 3;
`;
async function filterFiles(fileList) {
  const files = Array.from(fileList), filteredFiles = [];
  for (const file of files)
    try {
      await file.slice(0, 1).arrayBuffer(), filteredFiles.push(file);
    } catch {
    }
  return filteredFiles;
}
var UploadDropzone = (props) => {
  const { children } = props, {
    dropzone: { maxSize }
  } = useToolOptions(), { onSelect } = useAssetSourceActions(), dispatch = useDispatch(), assetTypes = useTypedSelector((state) => state.assets.assetTypes), isImageAssetType = assetTypes.length === 1 && assetTypes[0] === "image", handleDrop = async (acceptedFiles) => {
    acceptedFiles.forEach(
      (file) => dispatch(
        uploadsActions.uploadRequest({
          file,
          forceAsAssetType: assetTypes.length === 1 ? assetTypes[0] : void 0
        })
      )
    );
  }, handleDropRejected = (rejections) => {
    rejections.flatMap(({ errors }) => errors.map(({ code }) => code)).includes("file-too-large") && dispatch(
      notificationsActions.add({
        status: "error",
        title: "One or more files exceed the maximum upload size."
      })
    );
  }, handleFileGetter = async (event) => {
    var _a;
    let fileList;
    if (event.type === "drop" && "dataTransfer" in event && (fileList = (_a = event == null ? void 0 : event.dataTransfer) == null ? void 0 : _a.files), event.type === "change") {
      const target = event == null ? void 0 : event.target;
      (target == null ? void 0 : target.files) && (fileList = target.files);
    }
    if (!fileList)
      return [];
    const files = await filterFiles(fileList);
    return (fileList == null ? void 0 : fileList.length) !== files.length && dispatch(
      notificationsActions.add({
        status: "error",
        title: "Unable to upload some items (folders and packages aren't supported)"
      })
    ), files;
  }, { getRootProps, getInputProps, isDragActive, open } = useDropzone({
    accept: isImageAssetType ? "image/*" : "",
    getFilesFromEvent: handleFileGetter,
    noClick: true,
    // HACK: Disable drag and drop functionality when in a selecting context
    // (This is currently due to Sanity's native image input taking precedence with drag and drop)
    noDrag: !!onSelect,
    onDrop: handleDrop,
    maxSize,
    onDropRejected: handleDropRejected
  });
  return (0, import_jsx_runtime2.jsx)(DropzoneDispatchProvider, { open, children: (0, import_jsx_runtime2.jsxs)(UploadContainer, { ...getRootProps(), children: [
    (0, import_jsx_runtime2.jsx)("input", { ...getInputProps() }),
    isDragActive && (0, import_jsx_runtime2.jsx)(DragActiveContainer, { children: (0, import_jsx_runtime2.jsx)(Flex, { direction: "column", justify: "center", style: { color: white.hex }, children: (0, import_jsx_runtime2.jsx)(Text, { size: 3, style: { color: "inherit" }, children: "Drop files to upload" }) }) }),
    children
  ] }) });
};
var BrowserContent = ({ onClose }) => {
  const client = useVersionedClient(), [portalElement, setPortalElement] = (0, import_react17.useState)(null), dispatch = useDispatch();
  return (0, import_react17.useEffect)(() => {
    const handleAssetUpdate = (update) => {
      const { documentId, result, transition } = update;
      transition === "appear" && dispatch(assetsActions.listenerCreateQueue({ asset: result })), transition === "disappear" && dispatch(assetsActions.listenerDeleteQueue({ assetId: documentId })), transition === "update" && dispatch(assetsActions.listenerUpdateQueue({ asset: result }));
    }, handleTagUpdate = (update) => {
      const { documentId, result, transition } = update;
      transition === "appear" && dispatch(tagsActions.listenerCreateQueue({ tag: result })), transition === "disappear" && dispatch(tagsActions.listenerDeleteQueue({ tagId: documentId })), transition === "update" && dispatch(tagsActions.listenerUpdateQueue({ tag: result }));
    };
    dispatch(assetsActions.loadPageIndex({ pageIndex: 0 })), dispatch(tagsActions.fetchRequest());
    const subscriptionAsset = client.listen(
      groq`*[_type in ["sanity.fileAsset", "sanity.imageAsset"] && !(_id in path("drafts.**"))]`
    ).subscribe(handleAssetUpdate), subscriptionTag = client.listen(groq`*[_type == "${TAG_DOCUMENT_NAME}" && !(_id in path("drafts.**"))]`).subscribe(handleTagUpdate);
    return () => {
      subscriptionAsset == null ? void 0 : subscriptionAsset.unsubscribe(), subscriptionTag == null ? void 0 : subscriptionTag.unsubscribe();
    };
  }, [client, dispatch]), (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, children: (0, import_jsx_runtime2.jsxs)(UploadDropzone, { children: [
    (0, import_jsx_runtime2.jsx)(Dialogs, {}),
    (0, import_jsx_runtime2.jsx)(Notifications, {}),
    (0, import_jsx_runtime2.jsx)(Card, { display: "flex", height: "fill", ref: setPortalElement, children: (0, import_jsx_runtime2.jsxs)(Flex, { direction: "column", flex: 1, children: [
      (0, import_jsx_runtime2.jsx)(Header, { onClose }),
      (0, import_jsx_runtime2.jsx)(Controls, {}),
      (0, import_jsx_runtime2.jsxs)(Flex, { flex: 1, children: [
        (0, import_jsx_runtime2.jsxs)(Flex, { align: "flex-end", direction: "column", flex: 1, style: { position: "relative" }, children: [
          (0, import_jsx_runtime2.jsx)(PickedBar, {}),
          (0, import_jsx_runtime2.jsx)(Items, {})
        ] }),
        (0, import_jsx_runtime2.jsx)(TagsPanel, {})
      ] }),
      (0, import_jsx_runtime2.jsx)(DebugControls, {})
    ] }) })
  ] }) });
};
var Browser = (props) => {
  const client = useVersionedClient();
  return (0, import_jsx_runtime2.jsx)(
    ReduxProvider,
    {
      assetType: props == null ? void 0 : props.assetType,
      client,
      document: props == null ? void 0 : props.document,
      selectedAssets: props == null ? void 0 : props.selectedAssets,
      children: (0, import_jsx_runtime2.jsxs)(AssetBrowserDispatchProvider, { onSelect: props == null ? void 0 : props.onSelect, children: [
        (0, import_jsx_runtime2.jsx)(GlobalStyle, {}),
        (0, import_jsx_runtime2.jsx)(BrowserContent, { onClose: props == null ? void 0 : props.onClose })
      ] })
    }
  );
};
var FormBuilderTool = (props) => {
  const { onClose } = props, portalElement = useRootPortalElement(), currentDocument = useFormValue([]);
  useKeyPress("escape", onClose);
  const handleStopPropagation = (event) => {
    event.nativeEvent.stopImmediatePropagation(), event.stopPropagation();
  }, { zIndex } = useLayer();
  return (0, import_jsx_runtime2.jsx)(PortalProvider, { element: portalElement, children: (0, import_jsx_runtime2.jsx)(Portal, { children: (0, import_jsx_runtime2.jsx)(
    Box,
    {
      onDragEnter: handleStopPropagation,
      onDragLeave: handleStopPropagation,
      onDragOver: handleStopPropagation,
      onDrop: handleStopPropagation,
      onMouseUp: handleStopPropagation,
      style: {
        bottom: 0,
        height: "auto",
        left: 0,
        position: "fixed",
        top: 0,
        width: "100%",
        zIndex
      },
      children: (0, import_jsx_runtime2.jsx)(Browser, { document: currentDocument, ...props })
    }
  ) }) });
};
var useRootPortalElement = () => {
  const [container] = (0, import_react17.useState)(() => document.createElement("div"));
  return (0, import_react17.useEffect)(() => (container.classList.add("media-portal"), document.body.appendChild(container), () => {
    document.body.removeChild(container);
  }), [container]), container;
};
var Tool = () => (0, import_jsx_runtime2.jsx)(Flex, { direction: "column", height: "fill", flex: 1, children: (0, import_jsx_runtime2.jsx)(Browser, {}) });
var mediaTag = {
  title: "Media Tag",
  icon: TagIcon,
  name: TAG_DOCUMENT_NAME,
  type: "document",
  fields: [
    {
      title: "Name",
      name: "name",
      type: "slug"
    }
  ],
  preview: {
    select: {
      name: "name"
    },
    prepare(selection) {
      const { name } = selection;
      return {
        media: TagIcon,
        title: name == null ? void 0 : name.current
      };
    }
  }
};
var plugin = {
  icon: ImageIcon,
  name: "media",
  title: "Media"
};
var mediaAssetSource = {
  ...plugin,
  component: FormBuilderTool
};
var tool = {
  ...plugin,
  component: Tool,
  // @ts-expect-error TS doesn't know about this internal field see https://github.com/sanity-io/sanity/pull/7980
  __internalApplicationType: "sanity/media"
};
var media = definePlugin((options2) => ({
  name: "media",
  studio: {
    components: {
      layout: (props) => (0, import_jsx_runtime2.jsx)(ToolOptionsProvider, { options: options2, children: props.renderDefault(props) })
    }
  },
  form: {
    file: {
      assetSources: (prev2) => [...prev2, mediaAssetSource]
    },
    image: {
      assetSources: (prev2) => [...prev2, mediaAssetSource]
    }
  },
  schema: {
    types: [mediaTag]
  },
  tools: (prev2) => [...prev2, tool]
}));
export {
  media,
  mediaAssetSource
};
/*! Bundled license information:

filesize/lib/filesize.esm.js:
  (**
   * filesize
   *
   * @copyright 2022 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 9.0.11
   *)
*/
//# sourceMappingURL=sanity-plugin-media.js.map
