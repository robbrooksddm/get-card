import { jsx as z, jsxs as Kt, Fragment as io } from "react/jsx-runtime";
import H, { createElement as $t } from "react";
import lo from "react-dom";
const we = 0, zt = 1, qt = 2, En = 4;
function ln(t) {
  return () => t;
}
function co(t) {
  t();
}
function ne(t, e) {
  return (n) => t(e(n));
}
function cn(t, e) {
  return () => t(e);
}
function kn(t, e) {
  return (n) => t(e, n);
}
function Me(t) {
  return t !== void 0;
}
function uo(...t) {
  return () => {
    t.map(co);
  };
}
function Yt() {
}
function ye(t, e) {
  return e(t), t;
}
function ao(t, e) {
  return e(t);
}
function X(...t) {
  return t;
}
function K(t, e) {
  return t(zt, e);
}
function W(t, e) {
  t(we, e);
}
function We(t) {
  t(qt);
}
function lt(t) {
  return t(En);
}
function F(t, e) {
  return K(t, kn(e, we));
}
function Rt(t, e) {
  const n = t(zt, (o) => {
    n(), e(o);
  });
  return n;
}
function un(t) {
  let e, n;
  return (o) => (r) => {
    e = r, n && clearTimeout(n), n = setTimeout(() => {
      o(e);
    }, t);
  };
}
function Bn(t, e) {
  return t === e;
}
function Y(t = Bn) {
  let e;
  return (n) => (o) => {
    t(e, o) || (e = o, n(o));
  };
}
function P(t) {
  return (e) => (n) => {
    t(n) && e(n);
  };
}
function E(t) {
  return (e) => ne(e, t);
}
function vt(t) {
  return (e) => () => {
    e(t);
  };
}
function x(t, ...e) {
  const n = fo(...e);
  return (o, r) => {
    switch (o) {
      case qt:
        We(t);
        return;
      case zt:
        return K(t, n(r));
    }
  };
}
function bt(t, e) {
  return (n) => (o) => {
    n(e = t(e, o));
  };
}
function jt(t) {
  return (e) => (n) => {
    t > 0 ? t-- : e(n);
  };
}
function Lt(t) {
  let e = null, n;
  return (o) => (r) => {
    e = r, !n && (n = setTimeout(() => {
      n = void 0, o(e);
    }, t));
  };
}
function G(...t) {
  const e = new Array(t.length);
  let n = 0, o = null;
  const r = Math.pow(2, t.length) - 1;
  return t.forEach((s, i) => {
    const l = Math.pow(2, i);
    K(s, (c) => {
      const u = n;
      n = n | l, e[i] = c, u !== r && n === r && o && (o(), o = null);
    });
  }), (s) => (i) => {
    const l = () => {
      s([i].concat(e));
    };
    n === r ? l() : o = l;
  };
}
function fo(...t) {
  return (e) => t.reduceRight(ao, e);
}
function mo(t) {
  let e, n;
  const o = () => e == null ? void 0 : e();
  return function(r, s) {
    switch (r) {
      case zt:
        return s ? n === s ? void 0 : (o(), n = s, e = K(t, s), e) : (o(), Yt);
      case qt:
        o(), n = null;
        return;
    }
  };
}
function y(t) {
  let e = t;
  const n = $();
  return (o, r) => {
    switch (o) {
      case we:
        e = r;
        break;
      case zt: {
        r(e);
        break;
      }
      case En:
        return e;
    }
    return n(o, r);
  };
}
function ct(t, e) {
  return ye(y(e), (n) => F(t, n));
}
function $() {
  const t = [];
  return (e, n) => {
    switch (e) {
      case we:
        t.slice().forEach((o) => {
          o(n);
        });
        return;
      case qt:
        t.splice(0, t.length);
        return;
      case zt:
        return t.push(n), () => {
          const o = t.indexOf(n);
          o > -1 && t.splice(o, 1);
        };
    }
  };
}
function pt(t) {
  return ye($(), (e) => F(t, e));
}
function U(t, e = [], { singleton: n } = { singleton: !0 }) {
  return {
    constructor: t,
    dependencies: e,
    id: po(),
    singleton: n
  };
}
const po = () => Symbol();
function ho(t) {
  const e = /* @__PURE__ */ new Map(), n = ({ constructor: o, dependencies: r, id: s, singleton: i }) => {
    if (i && e.has(s))
      return e.get(s);
    const l = o(r.map((c) => n(c)));
    return i && e.set(s, l), l;
  };
  return n(t);
}
function rt(...t) {
  const e = $(), n = new Array(t.length);
  let o = 0;
  const r = Math.pow(2, t.length) - 1;
  return t.forEach((s, i) => {
    const l = Math.pow(2, i);
    K(s, (c) => {
      n[i] = c, o = o | l, o === r && W(e, n);
    });
  }), function(s, i) {
    switch (s) {
      case qt: {
        We(e);
        return;
      }
      case zt:
        return o === r && i(n), K(e, i);
    }
  };
}
function A(t, e = Bn) {
  return x(t, Y(e));
}
function an(...t) {
  return function(e, n) {
    switch (e) {
      case qt:
        return;
      case zt:
        return uo(...t.map((o) => K(o, n)));
    }
  };
}
var ht = /* @__PURE__ */ ((t) => (t[t.DEBUG = 0] = "DEBUG", t[t.INFO = 1] = "INFO", t[t.WARN = 2] = "WARN", t[t.ERROR = 3] = "ERROR", t))(ht || {});
const go = {
  0: "debug",
  3: "error",
  1: "log",
  2: "warn"
}, Io = () => typeof globalThis > "u" ? window : globalThis, Vt = U(
  () => {
    const t = y(
      3
      /* ERROR */
    );
    return {
      log: y((n, o, r = 1) => {
        var i;
        const s = (i = Io().VIRTUOSO_LOG_LEVEL) != null ? i : lt(t);
        r >= s && console[go[r]](
          "%creact-virtuoso: %c%s %o",
          "color: #0253b3; font-weight: bold",
          "color: initial",
          n,
          o
        );
      }),
      logLevel: t
    };
  },
  [],
  { singleton: !0 }
);
function Ht(t, e, n) {
  return _e(t, e, n).callbackRef;
}
function _e(t, e, n) {
  const o = H.useRef(null);
  let r = (s) => {
  };
  if (typeof ResizeObserver < "u") {
    const s = H.useMemo(() => new ResizeObserver((i) => {
      const l = () => {
        const c = i[0].target;
        c.offsetParent !== null && t(c);
      };
      n ? l() : requestAnimationFrame(l);
    }), [t]);
    r = (i) => {
      i && e ? (s.observe(i), o.current = i) : (o.current && s.unobserve(o.current), o.current = null);
    };
  }
  return { callbackRef: r, ref: o };
}
function On(t, e, n, o, r, s, i, l, c) {
  const u = H.useCallback(
    (f) => {
      const S = So(f.children, e, l ? "offsetWidth" : "offsetHeight", r);
      let p = f.parentElement;
      for (; !p.dataset.virtuosoScroller; )
        p = p.parentElement;
      const m = p.lastElementChild.dataset.viewportType === "window";
      let w;
      m && (w = p.ownerDocument.defaultView);
      const I = i ? l ? i.scrollLeft : i.scrollTop : m ? l ? w.scrollX || w.document.documentElement.scrollLeft : w.scrollY || w.document.documentElement.scrollTop : l ? p.scrollLeft : p.scrollTop, C = i ? l ? i.scrollWidth : i.scrollHeight : m ? l ? w.document.documentElement.scrollWidth : w.document.documentElement.scrollHeight : l ? p.scrollWidth : p.scrollHeight, g = i ? l ? i.offsetWidth : i.offsetHeight : m ? l ? w.innerWidth : w.innerHeight : l ? p.offsetWidth : p.offsetHeight;
      o({
        scrollHeight: C,
        scrollTop: Math.max(I, 0),
        viewportHeight: g
      }), s == null || s(
        l ? dn("column-gap", getComputedStyle(f).columnGap, r) : dn("row-gap", getComputedStyle(f).rowGap, r)
      ), S !== null && t(S);
    },
    [t, e, r, s, i, o]
  );
  return _e(u, n, c);
}
function So(t, e, n, o) {
  const r = t.length;
  if (r === 0)
    return null;
  const s = [];
  for (let i = 0; i < r; i++) {
    const l = t.item(i);
    if (l.dataset.index === void 0)
      continue;
    const c = parseInt(l.dataset.index), u = parseFloat(l.dataset.knownSize), f = e(l, n);
    if (f === 0 && o("Zero-sized element, this should not happen", { child: l }, ht.ERROR), f === u)
      continue;
    const S = s[s.length - 1];
    s.length === 0 || S.size !== f || S.endIndex !== c - 1 ? s.push({ endIndex: c, size: f, startIndex: c }) : s[s.length - 1].endIndex++;
  }
  return s;
}
function dn(t, e, n) {
  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, ht.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
}
function Ge(t, e, n) {
  const o = H.useRef(null), r = H.useCallback(
    (c) => {
      if (!(c != null && c.offsetParent))
        return;
      const u = c.getBoundingClientRect(), f = u.width;
      let S, p;
      if (e) {
        const m = e.getBoundingClientRect(), w = u.top - m.top;
        p = m.height - Math.max(0, w), S = w + e.scrollTop;
      } else {
        const m = i.current.ownerDocument.defaultView;
        p = m.innerHeight - Math.max(0, u.top), S = u.top + m.scrollY;
      }
      o.current = {
        offsetTop: S,
        visibleHeight: p,
        visibleWidth: f
      }, t(o.current);
    },
    [t, e]
  ), { callbackRef: s, ref: i } = _e(r, !0, n), l = H.useCallback(() => {
    r(i.current);
  }, [r, i]);
  return H.useEffect(() => {
    var c;
    if (e) {
      e.addEventListener("scroll", l);
      const u = new ResizeObserver(() => {
        requestAnimationFrame(l);
      });
      return u.observe(e), () => {
        e.removeEventListener("scroll", l), u.unobserve(e);
      };
    } else {
      const u = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;
      return u == null || u.addEventListener("scroll", l), u == null || u.addEventListener("resize", l), () => {
        u == null || u.removeEventListener("scroll", l), u == null || u.removeEventListener("resize", l);
      };
    }
  }, [l, e]), s;
}
const at = U(
  () => {
    const t = $(), e = $(), n = y(0), o = $(), r = y(0), s = $(), i = $(), l = y(0), c = y(0), u = y(0), f = y(0), S = $(), p = $(), m = y(!1), w = y(!1), I = y(!1);
    return F(
      x(
        t,
        E(({ scrollTop: C }) => C)
      ),
      e
    ), F(
      x(
        t,
        E(({ scrollHeight: C }) => C)
      ),
      i
    ), F(e, r), {
      deviation: n,
      fixedFooterHeight: u,
      fixedHeaderHeight: c,
      footerHeight: f,
      headerHeight: l,
      horizontalDirection: w,
      scrollBy: p,
      // input
      scrollContainerState: t,
      scrollHeight: i,
      scrollingInProgress: m,
      // signals
      scrollTo: S,
      scrollTop: e,
      skipAnimationFrameInResizeObserver: I,
      smoothScrollTargetReached: o,
      // state
      statefulScrollTop: r,
      viewportHeight: s
    };
  },
  [],
  { singleton: !0 }
), oe = { lvl: 0 };
function Fn(t, e) {
  const n = t.length;
  if (n === 0)
    return [];
  let { index: o, value: r } = e(t[0]);
  const s = [];
  for (let i = 1; i < n; i++) {
    const { index: l, value: c } = e(t[i]);
    s.push({ end: l - 1, start: o, value: r }), o = l, r = c;
  }
  return s.push({ end: 1 / 0, start: o, value: r }), s;
}
function j(t) {
  return t === oe;
}
function re(t, e) {
  if (!j(t))
    return e === t.k ? t.v : e < t.k ? re(t.l, e) : re(t.r, e);
}
function Ct(t, e, n = "k") {
  if (j(t))
    return [-1 / 0, void 0];
  if (Number(t[n]) === e)
    return [t.k, t.v];
  if (Number(t[n]) < e) {
    const o = Ct(t.r, e, n);
    return o[0] === -1 / 0 ? [t.k, t.v] : o;
  }
  return Ct(t.l, e, n);
}
function mt(t, e, n) {
  return j(t) ? Vn(e, n, 1) : e === t.k ? ot(t, { k: e, v: n }) : e < t.k ? fn(ot(t, { l: mt(t.l, e, n) })) : fn(ot(t, { r: mt(t.r, e, n) }));
}
function Ut() {
  return oe;
}
function ve(t, e, n) {
  if (j(t))
    return [];
  const o = Ct(t, e)[0];
  return xo(ze(t, o, n));
}
function Le(t, e) {
  if (j(t)) return oe;
  const { k: n, l: o, r } = t;
  if (e === n) {
    if (j(o))
      return r;
    if (j(r))
      return o;
    {
      const [s, i] = zn(o);
      return ge(ot(t, { k: s, l: Ln(o), v: i }));
    }
  } else return e < n ? ge(ot(t, { l: Le(o, e) })) : ge(ot(t, { r: Le(r, e) }));
}
function _t(t) {
  return j(t) ? [] : [..._t(t.l), { k: t.k, v: t.v }, ..._t(t.r)];
}
function ze(t, e, n) {
  if (j(t))
    return [];
  const { k: o, l: r, r: s, v: i } = t;
  let l = [];
  return o > e && (l = l.concat(ze(r, e, n))), o >= e && o <= n && l.push({ k: o, v: i }), o <= n && (l = l.concat(ze(s, e, n))), l;
}
function ge(t) {
  const { l: e, lvl: n, r: o } = t;
  if (o.lvl >= n - 1 && e.lvl >= n - 1)
    return t;
  if (n > o.lvl + 1) {
    if (Ee(e))
      return Pn(ot(t, { lvl: n - 1 }));
    if (!j(e) && !j(e.r))
      return ot(e.r, {
        l: ot(e, { r: e.r.l }),
        lvl: n,
        r: ot(t, {
          l: e.r.r,
          lvl: n - 1
        })
      });
    throw new Error("Unexpected empty nodes");
  } else {
    if (Ee(t))
      return Ve(ot(t, { lvl: n - 1 }));
    if (!j(o) && !j(o.l)) {
      const r = o.l, s = Ee(r) ? o.lvl - 1 : o.lvl;
      return ot(r, {
        l: ot(t, {
          lvl: n - 1,
          r: r.l
        }),
        lvl: r.lvl + 1,
        r: Ve(ot(o, { l: r.r, lvl: s }))
      });
    } else
      throw new Error("Unexpected empty nodes");
  }
}
function ot(t, e) {
  return Vn(
    e.k !== void 0 ? e.k : t.k,
    e.v !== void 0 ? e.v : t.v,
    e.lvl !== void 0 ? e.lvl : t.lvl,
    e.l !== void 0 ? e.l : t.l,
    e.r !== void 0 ? e.r : t.r
  );
}
function Ln(t) {
  return j(t.r) ? t.l : ge(ot(t, { r: Ln(t.r) }));
}
function Ee(t) {
  return j(t) || t.lvl > t.r.lvl;
}
function zn(t) {
  return j(t.r) ? [t.k, t.v] : zn(t.r);
}
function Vn(t, e, n, o = oe, r = oe) {
  return { k: t, l: o, lvl: n, r, v: e };
}
function fn(t) {
  return Ve(Pn(t));
}
function Pn(t) {
  const { l: e } = t;
  return !j(e) && e.lvl === t.lvl ? ot(e, { r: ot(t, { l: e.r }) }) : t;
}
function Ve(t) {
  const { lvl: e, r: n } = t;
  return !j(n) && !j(n.r) && n.lvl === e && n.r.lvl === e ? ot(n, { l: ot(t, { r: n.l }), lvl: e + 1 }) : t;
}
function xo(t) {
  return Fn(t, ({ k: e, v: n }) => ({ index: e, value: n }));
}
function An(t, e) {
  return !!(t && t.startIndex === e.startIndex && t.endIndex === e.endIndex);
}
function se(t, e) {
  return !!(t && t[0] === e[0] && t[1] === e[1]);
}
const Ne = U(
  () => ({ recalcInProgress: y(!1) }),
  [],
  { singleton: !0 }
);
function Mn(t, e, n) {
  return t[Se(t, e, n)];
}
function Se(t, e, n, o = 0) {
  let r = t.length - 1;
  for (; o <= r; ) {
    const s = Math.floor((o + r) / 2), i = t[s], l = n(i, e);
    if (l === 0)
      return s;
    if (l === -1) {
      if (r - o < 2)
        return s - 1;
      r = s - 1;
    } else {
      if (r === o)
        return s;
      o = s + 1;
    }
  }
  throw new Error(`Failed binary finding record in array - ${t.join(",")}, searched for ${e}`);
}
function To(t, e, n, o) {
  const r = Se(t, e, o), s = Se(t, n, o, r);
  return t.slice(r, s + 1);
}
function wt(t, e) {
  return Math.round(t.getBoundingClientRect()[e]);
}
function be(t) {
  return !j(t.groupOffsetTree);
}
function De({ index: t }, e) {
  return e === t ? 0 : e < t ? -1 : 1;
}
function Co() {
  return {
    groupIndices: [],
    groupOffsetTree: Ut(),
    lastIndex: 0,
    lastOffset: 0,
    lastSize: 0,
    offsetTree: [],
    sizeTree: Ut()
  };
}
function wo(t, e) {
  let n = j(t) ? 0 : 1 / 0;
  for (const o of e) {
    const { endIndex: r, size: s, startIndex: i } = o;
    if (n = Math.min(n, i), j(t)) {
      t = mt(t, 0, s);
      continue;
    }
    const l = ve(t, i - 1, r + 1);
    if (l.some(ko(o)))
      continue;
    let c = !1, u = !1;
    for (const { end: f, start: S, value: p } of l)
      c ? (r >= S || s === p) && (t = Le(t, S)) : (u = p !== s, c = !0), f > r && r >= S && p !== s && (t = mt(t, r + 1, p));
    u && (t = mt(t, i, s));
  }
  return [t, n];
}
function yo(t) {
  return typeof t.groupIndex < "u";
}
function vo({ offset: t }, e) {
  return e === t ? 0 : e < t ? -1 : 1;
}
function ie(t, e, n) {
  if (e.length === 0)
    return 0;
  const { index: o, offset: r, size: s } = Mn(e, t, De), i = t - o, l = s * i + (i - 1) * n + r;
  return l > 0 ? l + n : l;
}
function Wn(t, e) {
  if (!be(e))
    return t;
  let n = 0;
  for (; e.groupIndices[n] <= t + n; )
    n++;
  return t + n;
}
function _n(t, e, n) {
  if (yo(t))
    return e.groupIndices[t.groupIndex] + 1;
  {
    const o = t.index === "LAST" ? n : t.index;
    let r = Wn(o, e);
    return r = Math.max(0, r, Math.min(n, r)), r;
  }
}
function bo(t, e, n, o = 0) {
  return o > 0 && (e = Math.max(e, Mn(t, o, De).offset)), Fn(To(t, e, n, vo), Eo);
}
function Ro(t, [e, n, o, r]) {
  e.length > 0 && o("received item sizes", e, ht.DEBUG);
  const s = t.sizeTree;
  let i = s, l = 0;
  if (n.length > 0 && j(s) && e.length === 2) {
    const p = e[0].size, m = e[1].size;
    i = n.reduce((w, I) => mt(mt(w, I, p), I + 1, m), i);
  } else
    [i, l] = wo(i, e);
  if (i === s)
    return t;
  const { lastIndex: c, lastOffset: u, lastSize: f, offsetTree: S } = Pe(t.offsetTree, l, i, r);
  return {
    groupIndices: n,
    groupOffsetTree: n.reduce((p, m) => mt(p, m, ie(m, S, r)), Ut()),
    lastIndex: c,
    lastOffset: u,
    lastSize: f,
    offsetTree: S,
    sizeTree: i
  };
}
function Ho(t) {
  return _t(t).map(({ k: e, v: n }, o, r) => {
    const s = r[o + 1];
    return { endIndex: s ? s.k - 1 : 1 / 0, size: n, startIndex: e };
  });
}
function mn(t, e) {
  let n = 0, o = 0;
  for (; n < t; )
    n += e[o + 1] - e[o] - 1, o++;
  return o - (n === t ? 0 : 1);
}
function Pe(t, e, n, o) {
  let r = t, s = 0, i = 0, l = 0, c = 0;
  if (e !== 0) {
    c = Se(r, e - 1, De), l = r[c].offset;
    const f = Ct(n, e - 1);
    s = f[0], i = f[1], r.length && r[c].size === Ct(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);
  } else
    r = [];
  for (const { start: u, value: f } of ve(n, e, 1 / 0)) {
    const S = u - s, p = S * i + l + S * o;
    r.push({
      index: u,
      offset: p,
      size: f
    }), s = u, l = p, i = f;
  }
  return {
    lastIndex: s,
    lastOffset: l,
    lastSize: i,
    offsetTree: r
  };
}
function Eo(t) {
  return { index: t.index, value: t };
}
function ko(t) {
  const { endIndex: e, size: n, startIndex: o } = t;
  return (r) => r.start === o && (r.end === e || r.end === 1 / 0) && r.value === n;
}
const Bo = {
  offsetHeight: "height",
  offsetWidth: "width"
}, Et = U(
  ([{ log: t }, { recalcInProgress: e }]) => {
    const n = $(), o = $(), r = ct(o, 0), s = $(), i = $(), l = y(0), c = y([]), u = y(void 0), f = y(void 0), S = y((h, d) => wt(h, Bo[d])), p = y(void 0), m = y(0), w = Co(), I = ct(
      x(n, G(c, t, m), bt(Ro, w), Y()),
      w
    ), C = ct(
      x(
        c,
        Y(),
        bt((h, d) => ({ current: d, prev: h.current }), {
          current: [],
          prev: []
        }),
        E(({ prev: h }) => h)
      ),
      []
    );
    F(
      x(
        c,
        P((h) => h.length > 0),
        G(I, m),
        E(([h, d, R]) => {
          const B = h.reduce((O, L, V) => mt(O, L, ie(L, d.offsetTree, R) || V), Ut());
          return {
            ...d,
            groupIndices: h,
            groupOffsetTree: B
          };
        })
      ),
      I
    ), F(
      x(
        o,
        G(I),
        P(([h, { lastIndex: d }]) => h < d),
        E(([h, { lastIndex: d, lastSize: R }]) => [
          {
            endIndex: d,
            size: R,
            startIndex: h
          }
        ])
      ),
      n
    ), F(u, f);
    const g = ct(
      x(
        u,
        E((h) => h === void 0)
      ),
      !0
    );
    F(
      x(
        f,
        P((h) => h !== void 0 && j(lt(I).sizeTree)),
        E((h) => [{ endIndex: 0, size: h, startIndex: 0 }])
      ),
      n
    );
    const a = pt(
      x(
        n,
        G(I),
        bt(
          ({ sizes: h }, [d, R]) => ({
            changed: R !== h,
            sizes: R
          }),
          { changed: !1, sizes: w }
        ),
        E((h) => h.changed)
      )
    );
    K(
      x(
        l,
        bt(
          (h, d) => ({ diff: h.prev - d, prev: d }),
          { diff: 0, prev: 0 }
        ),
        E((h) => h.diff)
      ),
      (h) => {
        const { groupIndices: d } = lt(I);
        if (h > 0)
          W(e, !0), W(s, h + mn(h, d));
        else if (h < 0) {
          const R = lt(C);
          R.length > 0 && (h -= mn(-h, R)), W(i, h);
        }
      }
    ), K(x(l, G(t)), ([h, d]) => {
      h < 0 && d(
        "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
        { firstItemIndex: l },
        ht.ERROR
      );
    });
    const T = pt(s);
    F(
      x(
        s,
        G(I),
        E(([h, d]) => {
          const R = d.groupIndices.length > 0, B = [], O = d.lastSize;
          if (R) {
            const L = re(d.sizeTree, 0);
            let V = 0, D = 0;
            for (; V < h; ) {
              const k = d.groupIndices[D], q = d.groupIndices.length === D + 1 ? 1 / 0 : d.groupIndices[D + 1] - k - 1;
              B.push({
                endIndex: k,
                size: L,
                startIndex: k
              }), B.push({
                endIndex: k + 1 + q - 1,
                size: O,
                startIndex: k + 1
              }), D++, V += q + 1;
            }
            const J = _t(d.sizeTree);
            return V !== h && J.shift(), J.reduce(
              (k, { k: q, v: st }) => {
                let dt = k.ranges;
                return k.prevSize !== 0 && (dt = [
                  ...k.ranges,
                  {
                    endIndex: q + h - 1,
                    size: k.prevSize,
                    startIndex: k.prevIndex
                  }
                ]), {
                  prevIndex: q + h,
                  prevSize: st,
                  ranges: dt
                };
              },
              {
                prevIndex: h,
                prevSize: 0,
                ranges: B
              }
            ).ranges;
          }
          return _t(d.sizeTree).reduce(
            (L, { k: V, v: D }) => ({
              prevIndex: V + h,
              prevSize: D,
              ranges: [...L.ranges, { endIndex: V + h - 1, size: L.prevSize, startIndex: L.prevIndex }]
            }),
            {
              prevIndex: 0,
              prevSize: O,
              ranges: []
            }
          ).ranges;
        })
      ),
      n
    );
    const b = pt(
      x(
        i,
        G(I, m),
        E(([h, { offsetTree: d }, R]) => {
          const B = -h;
          return ie(B, d, R);
        })
      )
    );
    return F(
      x(
        i,
        G(I, m),
        E(([h, d, R]) => {
          if (d.groupIndices.length > 0) {
            if (j(d.sizeTree))
              return d;
            let O = Ut();
            const L = lt(C);
            let V = 0, D = 0, J = 0;
            for (; V < -h; ) {
              J = L[D];
              const k = L[D + 1] - J - 1;
              D++, V += k + 1;
            }
            if (O = _t(d.sizeTree).reduce((k, { k: q, v: st }) => mt(k, Math.max(0, q + h), st), O), V !== -h) {
              const k = re(d.sizeTree, J);
              O = mt(O, 0, k);
              const q = Ct(d.sizeTree, -h + 1)[1];
              O = mt(O, 1, q);
            }
            return {
              ...d,
              sizeTree: O,
              ...Pe(d.offsetTree, 0, O, R)
            };
          } else {
            const O = _t(d.sizeTree).reduce((L, { k: V, v: D }) => mt(L, Math.max(0, V + h), D), Ut());
            return {
              ...d,
              sizeTree: O,
              ...Pe(d.offsetTree, 0, O, R)
            };
          }
        })
      ),
      I
    ), {
      beforeUnshiftWith: T,
      // input
      data: p,
      defaultItemSize: f,
      firstItemIndex: l,
      fixedItemSize: u,
      gap: m,
      groupIndices: c,
      itemSize: S,
      listRefresh: a,
      shiftWith: i,
      shiftWithOffset: b,
      sizeRanges: n,
      // output
      sizes: I,
      statefulTotalCount: r,
      totalCount: o,
      trackItemSizes: g,
      unshiftWith: s
    };
  },
  X(Vt, Ne),
  { singleton: !0 }
);
function Oo(t) {
  return t.reduce(
    (e, n) => (e.groupIndices.push(e.totalCount), e.totalCount += n + 1, e),
    {
      groupIndices: [],
      totalCount: 0
    }
  );
}
const Gn = U(
  ([{ groupIndices: t, sizes: e, totalCount: n }, { headerHeight: o, scrollTop: r }]) => {
    const s = $(), i = $(), l = pt(x(s, E(Oo)));
    return F(
      x(
        l,
        E((c) => c.totalCount)
      ),
      n
    ), F(
      x(
        l,
        E((c) => c.groupIndices)
      ),
      t
    ), F(
      x(
        rt(r, e, o),
        P(([c, u]) => be(u)),
        E(([c, u, f]) => Ct(u.groupOffsetTree, Math.max(c - f, 0), "v")[0]),
        Y(),
        E((c) => [c])
      ),
      i
    ), { groupCounts: s, topItemsIndexes: i };
  },
  X(Et, at)
), Pt = U(
  ([{ log: t }]) => {
    const e = y(!1), n = pt(
      x(
        e,
        P((o) => o),
        Y()
      )
    );
    return K(e, (o) => {
      o && lt(t)("props updated", {}, ht.DEBUG);
    }), { didMount: n, propsReady: e };
  },
  X(Vt),
  { singleton: !0 }
), Fo = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
function Nn(t) {
  const e = typeof t == "number" ? { index: t } : t;
  return e.align || (e.align = "start"), (!e.behavior || !Fo) && (e.behavior = "auto"), e.offset || (e.offset = 0), e;
}
const ce = U(
  ([
    { gap: t, listRefresh: e, sizes: n, totalCount: o },
    {
      fixedFooterHeight: r,
      fixedHeaderHeight: s,
      footerHeight: i,
      headerHeight: l,
      scrollingInProgress: c,
      scrollTo: u,
      smoothScrollTargetReached: f,
      viewportHeight: S
    },
    { log: p }
  ]) => {
    const m = $(), w = $(), I = y(0);
    let C = null, g = null, a = null;
    function T() {
      C && (C(), C = null), a && (a(), a = null), g && (clearTimeout(g), g = null), W(c, !1);
    }
    return F(
      x(
        m,
        G(n, S, o, I, l, i, p),
        G(t, s, r),
        E(
          ([
            [b, h, d, R, B, O, L, V],
            D,
            J,
            nt
          ]) => {
            const k = Nn(b), { align: q, behavior: st, offset: dt } = k, St = R - 1, ft = _n(k, h, St);
            let ut = ie(ft, h.offsetTree, D) + O;
            q === "end" ? (ut += J + Ct(h.sizeTree, ft)[1] - d + nt, ft === St && (ut += L)) : q === "center" ? ut += (J + Ct(h.sizeTree, ft)[1] - d + nt) / 2 : ut -= B, dt && (ut += dt);
            const At = (xt) => {
              T(), xt ? (V("retrying to scroll to", { location: b }, ht.DEBUG), W(m, b)) : (W(w, !0), V("list did not change, scroll successful", {}, ht.DEBUG));
            };
            if (T(), st === "smooth") {
              let xt = !1;
              a = K(e, (Xt) => {
                xt = xt || Xt;
              }), C = Rt(f, () => {
                At(xt);
              });
            } else
              C = Rt(x(e, Lo(150)), At);
            return g = setTimeout(() => {
              T();
            }, 1200), W(c, !0), V("scrolling from index to", { behavior: st, index: ft, top: ut }, ht.DEBUG), { behavior: st, top: ut };
          }
        )
      ),
      u
    ), {
      scrollTargetReached: w,
      scrollToIndex: m,
      topListHeight: I
    };
  },
  X(Et, at, Vt),
  { singleton: !0 }
);
function Lo(t) {
  return (e) => {
    const n = setTimeout(() => {
      e(!1);
    }, t);
    return (o) => {
      o && (e(!0), clearTimeout(n));
    };
  };
}
function $e(t, e) {
  t == 0 ? e() : requestAnimationFrame(() => {
    $e(t - 1, e);
  });
}
function Ue(t, e) {
  const n = e - 1;
  return typeof t == "number" ? t : t.index === "LAST" ? n : t.index;
}
const ue = U(
  ([{ defaultItemSize: t, listRefresh: e, sizes: n }, { scrollTop: o }, { scrollTargetReached: r, scrollToIndex: s }, { didMount: i }]) => {
    const l = y(!0), c = y(0), u = y(!0);
    return F(
      x(
        i,
        G(c),
        P(([f, S]) => !!S),
        vt(!1)
      ),
      l
    ), F(
      x(
        i,
        G(c),
        P(([f, S]) => !!S),
        vt(!1)
      ),
      u
    ), K(
      x(
        rt(e, i),
        G(l, n, t, u),
        P(([[, f], S, { sizeTree: p }, m, w]) => f && (!j(p) || Me(m)) && !S && !w),
        G(c)
      ),
      ([, f]) => {
        Rt(r, () => {
          W(u, !0);
        }), $e(4, () => {
          Rt(o, () => {
            W(l, !0);
          }), W(s, f);
        });
      }
    ), {
      initialItemFinalLocationReached: u,
      initialTopMostItemIndex: c,
      scrolledToInitialItem: l
    };
  },
  X(Et, at, ce, Pt),
  { singleton: !0 }
);
function Dn(t, e) {
  return Math.abs(t - e) < 1.01;
}
const le = "up", te = "down", zo = "none", Vo = {
  atBottom: !1,
  notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
  state: {
    offsetBottom: 0,
    scrollHeight: 0,
    scrollTop: 0,
    viewportHeight: 0
  }
}, Po = 0, ae = U(([{ footerHeight: t, headerHeight: e, scrollBy: n, scrollContainerState: o, scrollTop: r, viewportHeight: s }]) => {
  const i = y(!1), l = y(!0), c = $(), u = $(), f = y(4), S = y(Po), p = ct(
    x(
      an(x(A(r), jt(1), vt(!0)), x(A(r), jt(1), vt(!1), un(100))),
      Y()
    ),
    !1
  ), m = ct(
    x(an(x(n, vt(!0)), x(n, vt(!1), un(200))), Y()),
    !1
  );
  F(
    x(
      rt(A(r), A(S)),
      E(([a, T]) => a <= T),
      Y()
    ),
    l
  ), F(x(l, Lt(50)), u);
  const w = pt(
    x(
      rt(o, A(s), A(e), A(t), A(f)),
      bt((a, [{ scrollHeight: T, scrollTop: b }, h, d, R, B]) => {
        const O = b + h - T > -B, L = {
          scrollHeight: T,
          scrollTop: b,
          viewportHeight: h
        };
        if (O) {
          let D, J;
          return b > a.state.scrollTop ? (D = "SCROLLED_DOWN", J = a.state.scrollTop - b) : (D = "SIZE_DECREASED", J = a.state.scrollTop - b || a.scrollTopDelta), {
            atBottom: !0,
            atBottomBecause: D,
            scrollTopDelta: J,
            state: L
          };
        }
        let V;
        return L.scrollHeight > a.state.scrollHeight ? V = "SIZE_INCREASED" : h < a.state.viewportHeight ? V = "VIEWPORT_HEIGHT_DECREASING" : b < a.state.scrollTop ? V = "SCROLLING_UPWARDS" : V = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
          atBottom: !1,
          notAtBottomBecause: V,
          state: L
        };
      }, Vo),
      Y((a, T) => a && a.atBottom === T.atBottom)
    )
  ), I = ct(
    x(
      o,
      bt(
        (a, { scrollHeight: T, scrollTop: b, viewportHeight: h }) => {
          if (Dn(a.scrollHeight, T))
            return {
              changed: !1,
              jump: 0,
              scrollHeight: T,
              scrollTop: b
            };
          {
            const d = T - (b + h) < 1;
            return a.scrollTop !== b && d ? {
              changed: !0,
              jump: a.scrollTop - b,
              scrollHeight: T,
              scrollTop: b
            } : {
              changed: !0,
              jump: 0,
              scrollHeight: T,
              scrollTop: b
            };
          }
        },
        { changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 }
      ),
      P((a) => a.changed),
      E((a) => a.jump)
    ),
    0
  );
  F(
    x(
      w,
      E((a) => a.atBottom)
    ),
    i
  ), F(x(i, Lt(50)), c);
  const C = y(te);
  F(
    x(
      o,
      E(({ scrollTop: a }) => a),
      Y(),
      bt(
        (a, T) => lt(m) ? { direction: a.direction, prevScrollTop: T } : { direction: T < a.prevScrollTop ? le : te, prevScrollTop: T },
        { direction: te, prevScrollTop: 0 }
      ),
      E((a) => a.direction)
    ),
    C
  ), F(x(o, Lt(50), vt(zo)), C);
  const g = y(0);
  return F(
    x(
      p,
      P((a) => !a),
      vt(0)
    ),
    g
  ), F(
    x(
      r,
      Lt(100),
      G(p),
      P(([a, T]) => !!T),
      bt(([a, T], [b]) => [T, b], [0, 0]),
      E(([a, T]) => T - a)
    ),
    g
  ), {
    atBottomState: w,
    atBottomStateChange: c,
    atBottomThreshold: f,
    atTopStateChange: u,
    atTopThreshold: S,
    isAtBottom: i,
    isAtTop: l,
    isScrolling: p,
    lastJumpDueToItemResize: I,
    scrollDirection: C,
    scrollVelocity: g
  };
}, X(at)), xe = "top", Te = "bottom", pn = "none";
function hn(t, e, n) {
  return typeof t == "number" ? n === le && e === xe || n === te && e === Te ? t : 0 : n === le ? e === xe ? t.main : t.reverse : e === Te ? t.main : t.reverse;
}
function gn(t, e) {
  var n;
  return typeof t == "number" ? t : (n = t[e]) != null ? n : 0;
}
const Ke = U(
  ([{ deviation: t, fixedHeaderHeight: e, headerHeight: n, scrollTop: o, viewportHeight: r }]) => {
    const s = $(), i = y(0), l = y(0), c = y(0), u = ct(
      x(
        rt(
          A(o),
          A(r),
          A(n),
          A(s, se),
          A(c),
          A(i),
          A(e),
          A(t),
          A(l)
        ),
        E(
          ([
            f,
            S,
            p,
            [m, w],
            I,
            C,
            g,
            a,
            T
          ]) => {
            const b = f - a, h = C + g, d = Math.max(p - b, 0);
            let R = pn;
            const B = gn(T, xe), O = gn(T, Te);
            return m -= a, m += p + g, w += p + g, w -= a, m > f + h - B && (R = le), w < f - d + S + O && (R = te), R !== pn ? [
              Math.max(b - p - hn(I, xe, R) - B, 0),
              b - d - g + S + hn(I, Te, R) + O
            ] : null;
          }
        ),
        P((f) => f != null),
        Y(se)
      ),
      [0, 0]
    );
    return {
      increaseViewportBy: l,
      // input
      listBoundary: s,
      overscan: c,
      topListHeight: i,
      // output
      visibleRange: u
    };
  },
  X(at),
  { singleton: !0 }
);
function Ao(t, e, n) {
  if (be(e)) {
    const o = Wn(t, e);
    return [
      { index: Ct(e.groupOffsetTree, o)[0], offset: 0, size: 0 },
      { data: n == null ? void 0 : n[0], index: o, offset: 0, size: 0 }
    ];
  }
  return [{ data: n == null ? void 0 : n[0], index: t, offset: 0, size: 0 }];
}
const ke = {
  bottom: 0,
  firstItemIndex: 0,
  items: [],
  offsetBottom: 0,
  offsetTop: 0,
  top: 0,
  topItems: [],
  topListHeight: 0,
  totalCount: 0
};
function Ie(t, e, n, o, r, s) {
  const { lastIndex: i, lastOffset: l, lastSize: c } = r;
  let u = 0, f = 0;
  if (t.length > 0) {
    u = t[0].offset;
    const I = t[t.length - 1];
    f = I.offset + I.size;
  }
  const S = n - i, p = l + S * c + (S - 1) * o, m = u, w = p - f;
  return {
    bottom: f,
    firstItemIndex: s,
    items: In(t, r, s),
    offsetBottom: w,
    offsetTop: u,
    top: m,
    topItems: In(e, r, s),
    topListHeight: e.reduce((I, C) => C.size + I, 0),
    totalCount: n
  };
}
function $n(t, e, n, o, r, s) {
  let i = 0;
  if (n.groupIndices.length > 0)
    for (const f of n.groupIndices) {
      if (f - i >= t)
        break;
      i++;
    }
  const l = t + i, c = Ue(e, l), u = Array.from({ length: l }).map((f, S) => ({
    data: s[S + c],
    index: S + c,
    offset: 0,
    size: 0
  }));
  return Ie(u, [], l, r, n, o);
}
function In(t, e, n) {
  if (t.length === 0)
    return [];
  if (!be(e))
    return t.map((u) => ({ ...u, index: u.index + n, originalIndex: u.index }));
  const o = t[0].index, r = t[t.length - 1].index, s = [], i = ve(e.groupOffsetTree, o, r);
  let l, c = 0;
  for (const u of t) {
    (!l || l.end < u.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));
    let f;
    u.index === l.start ? f = {
      index: c,
      type: "group"
    } : f = {
      groupIndex: c,
      index: u.index - (c + 1) + n
    }, s.push({
      ...f,
      data: u.data,
      offset: u.offset,
      originalIndex: u.index,
      size: u.size
    });
  }
  return s;
}
const Gt = U(
  ([
    { data: t, firstItemIndex: e, gap: n, sizes: o, totalCount: r },
    s,
    { listBoundary: i, topListHeight: l, visibleRange: c },
    { initialTopMostItemIndex: u, scrolledToInitialItem: f },
    { topListHeight: S },
    p,
    { didMount: m },
    { recalcInProgress: w }
  ]) => {
    const I = y([]), C = y(0), g = $();
    F(s.topItemsIndexes, I);
    const a = ct(
      x(
        rt(
          m,
          w,
          A(c, se),
          A(r),
          A(o),
          A(u),
          f,
          A(I),
          A(e),
          A(n),
          t
        ),
        P(([d, R, , B, , , , , , , O]) => {
          const L = O && O.length !== B;
          return d && !R && !L;
        }),
        E(
          ([
            ,
            ,
            [d, R],
            B,
            O,
            L,
            V,
            D,
            J,
            nt,
            k
          ]) => {
            const q = O, { offsetTree: st, sizeTree: dt } = q, St = lt(C);
            if (B === 0)
              return { ...ke, totalCount: B };
            if (d === 0 && R === 0)
              return St === 0 ? { ...ke, totalCount: B } : $n(St, L, O, J, nt, k || []);
            if (j(dt))
              return St > 0 ? null : Ie(
                Ao(Ue(L, B), q, k),
                [],
                B,
                nt,
                q,
                J
              );
            const ft = [];
            if (D.length > 0) {
              const Mt = D[0], yt = D[D.length - 1];
              let kt = 0;
              for (const v of ve(dt, Mt, yt)) {
                const N = v.value, Q = Math.max(v.start, Mt), it = Math.min(v.end, yt);
                for (let tt = Q; tt <= it; tt++)
                  ft.push({ data: k == null ? void 0 : k[tt], index: tt, offset: kt, size: N }), kt += N;
              }
            }
            if (!V)
              return Ie([], ft, B, nt, q, J);
            const ut = D.length > 0 ? D[D.length - 1] + 1 : 0, At = bo(st, d, R, ut);
            if (At.length === 0)
              return null;
            const xt = B - 1, Xt = ye([], (Mt) => {
              for (const yt of At) {
                const kt = yt.value;
                let v = kt.offset, N = yt.start;
                const Q = kt.size;
                if (kt.offset < d) {
                  N += Math.floor((d - kt.offset + nt) / (Q + nt));
                  const tt = N - yt.start;
                  v += tt * Q + tt * nt;
                }
                N < ut && (v += (ut - N) * Q, N = ut);
                const it = Math.min(yt.end, xt);
                for (let tt = N; tt <= it && !(v >= R); tt++)
                  Mt.push({ data: k == null ? void 0 : k[tt], index: tt, offset: v, size: Q }), v += Q + nt;
              }
            });
            return Ie(Xt, ft, B, nt, q, J);
          }
        ),
        //@ts-expect-error filter needs to be fixed
        P((d) => d !== null),
        Y()
      ),
      ke
    );
    F(
      x(
        t,
        P(Me),
        E((d) => d == null ? void 0 : d.length)
      ),
      r
    ), F(
      x(
        a,
        E((d) => d.topListHeight)
      ),
      S
    ), F(S, l), F(
      x(
        a,
        E((d) => [d.top, d.bottom])
      ),
      i
    ), F(
      x(
        a,
        E((d) => d.items)
      ),
      g
    );
    const T = pt(
      x(
        a,
        P(({ items: d }) => d.length > 0),
        G(r, t),
        P(([{ items: d }, R]) => d[d.length - 1].originalIndex === R - 1),
        E(([, d, R]) => [d - 1, R]),
        Y(se),
        E(([d]) => d)
      )
    ), b = pt(
      x(
        a,
        Lt(200),
        P(({ items: d, topItems: R }) => d.length > 0 && d[0].originalIndex === R.length),
        E(({ items: d }) => d[0].index),
        Y()
      )
    ), h = pt(
      x(
        a,
        P(({ items: d }) => d.length > 0),
        E(({ items: d }) => {
          let R = 0, B = d.length - 1;
          for (; d[R].type === "group" && R < B; )
            R++;
          for (; d[B].type === "group" && B > R; )
            B--;
          return {
            endIndex: d[B].index,
            startIndex: d[R].index
          };
        }),
        Y(An)
      )
    );
    return { endReached: T, initialItemCount: C, itemsRendered: g, listState: a, rangeChanged: h, startReached: b, topItemsIndexes: I, ...p };
  },
  X(
    Et,
    Gn,
    Ke,
    ue,
    ce,
    ae,
    Pt,
    Ne
  ),
  { singleton: !0 }
), Un = U(
  ([{ fixedFooterHeight: t, fixedHeaderHeight: e, footerHeight: n, headerHeight: o }, { listState: r }]) => {
    const s = $(), i = ct(
      x(
        rt(n, t, o, e, r),
        E(([l, c, u, f, S]) => l + c + u + f + S.offsetBottom + S.bottom)
      ),
      0
    );
    return F(A(i), s), { totalListHeight: i, totalListHeightChanged: s };
  },
  X(at, Gt),
  { singleton: !0 }
), Mo = U(
  ([{ viewportHeight: t }, { totalListHeight: e }]) => {
    const n = y(!1), o = ct(
      x(
        rt(n, t, e),
        P(([r]) => r),
        E(([, r, s]) => Math.max(0, r - s)),
        Lt(0),
        Y()
      ),
      0
    );
    return { alignToBottom: n, paddingTopAddition: o };
  },
  X(at, Un),
  { singleton: !0 }
);
function Sn(t) {
  return t ? t === "smooth" ? "smooth" : "auto" : !1;
}
const Wo = (t, e) => typeof t == "function" ? Sn(t(e)) : e && Sn(t), _o = U(
  ([
    { listRefresh: t, totalCount: e },
    { atBottomState: n, isAtBottom: o },
    { scrollToIndex: r },
    { scrolledToInitialItem: s },
    { didMount: i, propsReady: l },
    { log: c },
    { scrollingInProgress: u }
  ]) => {
    const f = y(!1), S = $();
    let p = null;
    function m(I) {
      W(r, {
        align: "end",
        behavior: I,
        index: "LAST"
      });
    }
    K(
      x(
        rt(x(A(e), jt(1)), i),
        G(A(f), o, s, u),
        E(([[I, C], g, a, T, b]) => {
          let h = C && T, d = "auto";
          return h && (d = Wo(g, a || b), h = h && !!d), { followOutputBehavior: d, shouldFollow: h, totalCount: I };
        }),
        P(({ shouldFollow: I }) => I)
      ),
      ({ followOutputBehavior: I, totalCount: C }) => {
        p && (p(), p = null), p = Rt(t, () => {
          lt(c)("following output to ", { totalCount: C }, ht.DEBUG), m(I), p = null;
        });
      }
    );
    function w(I) {
      const C = Rt(n, (g) => {
        I && !g.atBottom && g.notAtBottomBecause === "SIZE_INCREASED" && !p && (lt(c)("scrolling to bottom due to increased size", {}, ht.DEBUG), m("auto"));
      });
      setTimeout(C, 100);
    }
    return K(
      x(
        rt(A(f), e, l),
        P(([I, , C]) => I && C),
        bt(
          ({ value: I }, [, C]) => ({ refreshed: I === C, value: C }),
          { refreshed: !1, value: 0 }
        ),
        P(({ refreshed: I }) => I),
        G(f, e)
      ),
      ([, I]) => {
        lt(s) && w(I !== !1);
      }
    ), K(S, () => {
      w(lt(f) !== !1);
    }), K(rt(A(f), n), ([I, C]) => {
      I && !C.atBottom && C.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && m("auto");
    }), { autoscrollToBottom: S, followOutput: f };
  },
  X(Et, ae, ce, ue, Pt, Vt, at)
), Go = U(
  ([{ data: t, firstItemIndex: e, gap: n, sizes: o }, { initialTopMostItemIndex: r }, { initialItemCount: s, listState: i }, { didMount: l }]) => (F(
    x(
      l,
      G(s),
      P(([, c]) => c !== 0),
      G(r, o, e, n, t),
      E(([[, c], u, f, S, p, m = []]) => $n(c, u, f, S, p, m))
    ),
    i
  ), {}),
  X(Et, ue, Gt, Pt),
  { singleton: !0 }
), No = U(
  ([{ didMount: t }, { scrollTo: e }, { listState: n }]) => {
    const o = y(0);
    return K(
      x(
        t,
        G(o),
        P(([, r]) => r !== 0),
        E(([, r]) => ({ top: r }))
      ),
      (r) => {
        Rt(
          x(
            n,
            jt(1),
            P((s) => s.items.length > 1)
          ),
          () => {
            requestAnimationFrame(() => {
              W(e, r);
            });
          }
        );
      }
    ), {
      initialScrollTop: o
    };
  },
  X(Pt, at, Gt),
  { singleton: !0 }
), Do = ({
  itemBottom: t,
  itemTop: e,
  locationParams: { align: n, behavior: o, ...r },
  viewportBottom: s,
  viewportTop: i
}) => e < i ? { ...r, align: n != null ? n : "start", behavior: o } : t > s ? { ...r, align: n != null ? n : "end", behavior: o } : null, $o = U(
  ([
    { gap: t, sizes: e, totalCount: n },
    { fixedFooterHeight: o, fixedHeaderHeight: r, headerHeight: s, scrollingInProgress: i, scrollTop: l, viewportHeight: c },
    { scrollToIndex: u }
  ]) => {
    const f = $();
    return F(
      x(
        f,
        G(e, c, n, s, r, o, l),
        G(t),
        E(([[S, p, m, w, I, C, g, a], T]) => {
          const { align: b, behavior: h, calculateViewLocation: d = Do, done: R, ...B } = S, O = _n(S, p, w - 1), L = ie(O, p.offsetTree, T) + I + C, V = L + Ct(p.sizeTree, O)[1], D = a + C, J = a + m - g, nt = d({
            itemBottom: V,
            itemTop: L,
            locationParams: { align: b, behavior: h, ...B },
            viewportBottom: J,
            viewportTop: D
          });
          return nt ? R && Rt(
            x(
              i,
              P((k) => !k),
              // skips the initial publish of false, and the cleanup call.
              // but if scrollingInProgress is true, we skip the initial publish.
              jt(lt(i) ? 1 : 2)
            ),
            R
          ) : R && R(), nt;
        }),
        P((S) => S !== null)
      ),
      u
    ), {
      scrollIntoView: f
    };
  },
  X(Et, at, ce, Gt, Vt),
  { singleton: !0 }
), Kn = U(
  ([{ scrollVelocity: t }]) => {
    const e = y(!1), n = $(), o = y(!1);
    return F(
      x(
        t,
        G(o, e, n),
        P(([r, s]) => !!s),
        E(([r, s, i, l]) => {
          const { enter: c, exit: u } = s;
          if (i) {
            if (u(r, l))
              return !1;
          } else if (c(r, l))
            return !0;
          return i;
        }),
        Y()
      ),
      e
    ), K(
      x(rt(e, t, n), G(o)),
      ([[r, s, i], l]) => {
        r && l && l.change && l.change(s, i);
      }
    ), { isSeeking: e, scrollSeekConfiguration: o, scrollSeekRangeChanged: n, scrollVelocity: t };
  },
  X(ae),
  { singleton: !0 }
), je = U(([{ scrollContainerState: t, scrollTo: e }]) => {
  const n = $(), o = $(), r = $(), s = y(!1), i = y(void 0);
  return F(
    x(
      rt(n, o),
      E(([{ scrollHeight: l, scrollTop: c, viewportHeight: u }, { offsetTop: f }]) => ({
        scrollHeight: l,
        scrollTop: Math.max(0, c - f),
        viewportHeight: u
      }))
    ),
    t
  ), F(
    x(
      e,
      G(o),
      E(([l, { offsetTop: c }]) => ({
        ...l,
        top: l.top + c
      }))
    ),
    r
  ), {
    customScrollParent: i,
    // config
    useWindowScroll: s,
    // input
    windowScrollContainerState: n,
    // signals
    windowScrollTo: r,
    windowViewportRect: o
  };
}, X(at)), Uo = U(
  ([
    { sizeRanges: t, sizes: e },
    { headerHeight: n, scrollTop: o },
    { initialTopMostItemIndex: r },
    { didMount: s },
    { useWindowScroll: i, windowScrollContainerState: l, windowViewportRect: c }
  ]) => {
    const u = $(), f = y(void 0), S = y(null), p = y(null);
    return F(l, S), F(c, p), K(
      x(
        u,
        G(e, o, i, S, p, n)
      ),
      ([m, w, I, C, g, a, T]) => {
        const b = Ho(w.sizeTree);
        C && g !== null && a !== null && (I = g.scrollTop - a.offsetTop), I -= T, m({ ranges: b, scrollTop: I });
      }
    ), F(x(f, P(Me), E(Ko)), r), F(
      x(
        s,
        G(f),
        P(([, m]) => m !== void 0),
        Y(),
        E(([, m]) => m.ranges)
      ),
      t
    ), {
      getState: u,
      restoreStateFrom: f
    };
  },
  X(Et, at, ue, Pt, je)
);
function Ko(t) {
  return { align: "start", index: 0, offset: t.scrollTop };
}
const jo = U(([{ topItemsIndexes: t }]) => {
  const e = y(0);
  return F(
    x(
      e,
      P((n) => n >= 0),
      E((n) => Array.from({ length: n }).map((o, r) => r))
    ),
    t
  ), { topItemCount: e };
}, X(Gt));
function jn(t) {
  let e = !1, n;
  return () => (e || (e = !0, n = t()), n);
}
const qo = jn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Yo = U(
  ([
    { deviation: t, scrollBy: e, scrollingInProgress: n, scrollTop: o },
    { isAtBottom: r, isScrolling: s, lastJumpDueToItemResize: i, scrollDirection: l },
    { listState: c },
    { beforeUnshiftWith: u, gap: f, shiftWithOffset: S, sizes: p },
    { log: m },
    { recalcInProgress: w }
  ]) => {
    const I = pt(
      x(
        c,
        G(i),
        bt(
          ([, g, a, T], [{ bottom: b, items: h, offsetBottom: d, totalCount: R }, B]) => {
            const O = b + d;
            let L = 0;
            return a === R && g.length > 0 && h.length > 0 && (h[0].originalIndex === 0 && g[0].originalIndex === 0 || (L = O - T, L !== 0 && (L += B))), [L, h, R, O];
          },
          [0, [], 0, 0]
        ),
        P(([g]) => g !== 0),
        G(o, l, n, r, m, w),
        P(([, g, a, T, , , b]) => !b && !T && g !== 0 && a === le),
        E(([[g], , , , , a]) => (a("Upward scrolling compensation", { amount: g }, ht.DEBUG), g))
      )
    );
    function C(g) {
      g > 0 ? (W(e, { behavior: "auto", top: -g }), W(t, 0)) : (W(t, 0), W(e, { behavior: "auto", top: -g }));
    }
    return K(x(I, G(t, s)), ([g, a, T]) => {
      T && qo() ? W(t, a - g) : C(-g);
    }), K(
      x(
        rt(ct(s, !1), t, w),
        P(([g, a, T]) => !g && !T && a !== 0),
        E(([g, a]) => a),
        Lt(1)
      ),
      C
    ), F(
      x(
        S,
        E((g) => ({ top: -g }))
      ),
      e
    ), K(
      x(
        u,
        G(p, f),
        E(([g, { groupIndices: a, lastSize: T, sizeTree: b }, h]) => {
          function d(R) {
            return R * (T + h);
          }
          if (a.length === 0)
            return d(g);
          {
            let R = 0;
            const B = re(b, 0);
            let O = 0, L = 0;
            for (; O < g; ) {
              O++, R += B;
              let V = a.length === L + 1 ? 1 / 0 : a[L + 1] - a[L] - 1;
              O + V > g && (R -= B, V = g - O + 1), O += V, R += d(V), L++;
            }
            return R;
          }
        })
      ),
      (g) => {
        W(t, g), requestAnimationFrame(() => {
          W(e, { top: g }), requestAnimationFrame(() => {
            W(t, 0), W(w, !1);
          });
        });
      }
    ), { deviation: t };
  },
  X(at, ae, Gt, Et, Vt, Ne)
), Zo = U(
  ([
    t,
    e,
    n,
    o,
    r,
    s,
    i,
    l,
    c,
    u
  ]) => ({
    ...t,
    ...e,
    ...n,
    ...o,
    ...r,
    ...s,
    ...i,
    ...l,
    ...c,
    ...u
  }),
  X(
    Ke,
    Go,
    Pt,
    Kn,
    Un,
    No,
    Mo,
    je,
    $o,
    Vt
  )
), qn = U(
  ([
    {
      data: t,
      defaultItemSize: e,
      firstItemIndex: n,
      fixedItemSize: o,
      gap: r,
      groupIndices: s,
      itemSize: i,
      sizeRanges: l,
      sizes: c,
      statefulTotalCount: u,
      totalCount: f,
      trackItemSizes: S
    },
    { initialItemFinalLocationReached: p, initialTopMostItemIndex: m, scrolledToInitialItem: w },
    I,
    C,
    g,
    { listState: a, topItemsIndexes: T, ...b },
    { scrollToIndex: h },
    d,
    { topItemCount: R },
    { groupCounts: B },
    O
  ]) => (F(b.rangeChanged, O.scrollSeekRangeChanged), F(
    x(
      O.windowViewportRect,
      E((L) => L.visibleHeight)
    ),
    I.viewportHeight
  ), {
    data: t,
    defaultItemHeight: e,
    firstItemIndex: n,
    fixedItemHeight: o,
    gap: r,
    groupCounts: B,
    initialItemFinalLocationReached: p,
    initialTopMostItemIndex: m,
    scrolledToInitialItem: w,
    sizeRanges: l,
    topItemCount: R,
    topItemsIndexes: T,
    // input
    totalCount: f,
    ...g,
    groupIndices: s,
    itemSize: i,
    listState: a,
    scrollToIndex: h,
    // output
    statefulTotalCount: u,
    trackItemSizes: S,
    // exported from stateFlagsSystem
    ...b,
    // the bag of IO from featureGroup1System
    ...O,
    ...I,
    sizes: c,
    ...C
  }),
  X(
    Et,
    ue,
    at,
    Uo,
    _o,
    Gt,
    ce,
    Yo,
    jo,
    Gn,
    Zo
  )
);
function Xo(t, e) {
  const n = {}, o = {};
  let r = 0;
  const s = t.length;
  for (; r < s; )
    o[t[r]] = 1, r += 1;
  for (const i in e)
    Object.hasOwn(o, i) || (n[i] = e[i]);
  return n;
}
const pe = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
function qe(t, e, n) {
  const o = Object.keys(e.required || {}), r = Object.keys(e.optional || {}), s = Object.keys(e.methods || {}), i = Object.keys(e.events || {}), l = H.createContext({});
  function c(g, a) {
    g.propsReady && W(g.propsReady, !1);
    for (const T of o) {
      const b = g[e.required[T]];
      W(b, a[T]);
    }
    for (const T of r)
      if (T in a) {
        const b = g[e.optional[T]];
        W(b, a[T]);
      }
    g.propsReady && W(g.propsReady, !0);
  }
  function u(g) {
    return s.reduce((a, T) => (a[T] = (b) => {
      const h = g[e.methods[T]];
      W(h, b);
    }, a), {});
  }
  function f(g) {
    return i.reduce((a, T) => (a[T] = mo(g[e.events[T]]), a), {});
  }
  const S = H.forwardRef((g, a) => {
    const { children: T, ...b } = g, [h] = H.useState(() => ye(ho(t), (B) => {
      c(B, b);
    })), [d] = H.useState(cn(f, h));
    pe(() => {
      for (const B of i)
        B in b && K(d[B], b[B]);
      return () => {
        Object.values(d).map(We);
      };
    }, [b, d, h]), pe(() => {
      c(h, b);
    }), H.useImperativeHandle(a, ln(u(h)));
    const R = n;
    return /* @__PURE__ */ z(l.Provider, { value: h, children: n ? /* @__PURE__ */ z(R, { ...Xo([...o, ...r, ...i], b), children: T }) : T });
  }), p = (g) => H.useCallback(kn(W, H.useContext(l)[g]), [g]), m = (g) => {
    const T = H.useContext(l)[g], b = H.useCallback(
      (h) => K(T, h),
      [T]
    );
    return H.useSyncExternalStore(
      b,
      () => lt(T),
      () => lt(T)
    );
  }, w = (g) => {
    const T = H.useContext(l)[g], [b, h] = H.useState(cn(lt, T));
    return pe(
      () => K(T, (d) => {
        d !== b && h(ln(d));
      }),
      [T, b]
    ), b;
  }, I = H.version.startsWith("18") ? m : w;
  return {
    Component: S,
    useEmitter: (g, a) => {
      const b = H.useContext(l)[g];
      pe(() => K(b, a), [a, b]);
    },
    useEmitterValue: I,
    usePublisher: p
  };
}
const Re = H.createContext(void 0), Yn = H.createContext(void 0), Zn = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
function Be(t) {
  return "self" in t;
}
function Jo(t) {
  return "body" in t;
}
function Xn(t, e, n, o = Yt, r, s) {
  const i = H.useRef(null), l = H.useRef(null), c = H.useRef(null), u = H.useCallback(
    (p) => {
      let m, w, I;
      const C = p.target;
      if (Jo(C) || Be(C)) {
        const a = Be(C) ? C : C.defaultView;
        I = s ? a.scrollX : a.scrollY, m = s ? a.document.documentElement.scrollWidth : a.document.documentElement.scrollHeight, w = s ? a.innerWidth : a.innerHeight;
      } else
        I = s ? C.scrollLeft : C.scrollTop, m = s ? C.scrollWidth : C.scrollHeight, w = s ? C.offsetWidth : C.offsetHeight;
      const g = () => {
        t({
          scrollHeight: m,
          scrollTop: Math.max(I, 0),
          viewportHeight: w
        });
      };
      p.suppressFlushSync ? g() : lo.flushSync(g), l.current !== null && (I === l.current || I <= 0 || I === m - w) && (l.current = null, e(!0), c.current && (clearTimeout(c.current), c.current = null));
    },
    [t, e]
  );
  H.useEffect(() => {
    const p = r || i.current;
    return o(r || i.current), u({ suppressFlushSync: !0, target: p }), p.addEventListener("scroll", u, { passive: !0 }), () => {
      o(null), p.removeEventListener("scroll", u);
    };
  }, [i, u, n, o, r]);
  function f(p) {
    const m = i.current;
    if (!m || (s ? "offsetWidth" in m && m.offsetWidth === 0 : "offsetHeight" in m && m.offsetHeight === 0))
      return;
    const w = p.behavior === "smooth";
    let I, C, g;
    Be(m) ? (C = Math.max(
      wt(m.document.documentElement, s ? "width" : "height"),
      s ? m.document.documentElement.scrollWidth : m.document.documentElement.scrollHeight
    ), I = s ? m.innerWidth : m.innerHeight, g = s ? window.scrollX : window.scrollY) : (C = m[s ? "scrollWidth" : "scrollHeight"], I = wt(m, s ? "width" : "height"), g = m[s ? "scrollLeft" : "scrollTop"]);
    const a = C - I;
    if (p.top = Math.ceil(Math.max(Math.min(a, p.top), 0)), Dn(I, C) || p.top === g) {
      t({ scrollHeight: C, scrollTop: g, viewportHeight: I }), w && e(!0);
      return;
    }
    w ? (l.current = p.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {
      c.current = null, l.current = null, e(!0);
    }, 1e3)) : l.current = null, s && (p = { behavior: p.behavior, left: p.top }), m.scrollTo(p);
  }
  function S(p) {
    s && (p = { behavior: p.behavior, left: p.top }), i.current.scrollBy(p);
  }
  return { scrollByCallback: S, scrollerRef: i, scrollToCallback: f };
}
const Oe = "-webkit-sticky", xn = "sticky", Jn = jn(() => {
  if (typeof document > "u")
    return xn;
  const t = document.createElement("div");
  return t.style.position = Oe, t.style.position === Oe ? Oe : xn;
});
function Ye(t) {
  return t;
}
const Qo = /* @__PURE__ */ U(() => {
  const t = y((c) => `Item ${c}`), e = y(null), n = y((c) => `Group ${c}`), o = y({}), r = y(Ye), s = y("div"), i = y(Yt), l = (c, u = null) => ct(
    x(
      o,
      E((f) => f[c]),
      Y()
    ),
    u
  );
  return {
    components: o,
    computeItemKey: r,
    context: e,
    EmptyPlaceholder: l("EmptyPlaceholder"),
    FooterComponent: l("Footer"),
    GroupComponent: l("Group", "div"),
    groupContent: n,
    HeaderComponent: l("Header"),
    HeaderFooterTag: s,
    ItemComponent: l("Item", "div"),
    itemContent: t,
    ListComponent: l("List", "div"),
    ScrollerComponent: l("Scroller", "div"),
    scrollerRef: i,
    ScrollSeekPlaceholder: l("ScrollSeekPlaceholder"),
    TopItemListComponent: l("TopItemList")
  };
}), tr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(qn, Qo)
), er = ({ height: t }) => /* @__PURE__ */ z("div", { style: { height: t } }), nr = { overflowAnchor: "none", position: Jn(), zIndex: 1 }, Qn = { overflowAnchor: "none" }, or = { ...Qn, display: "inline-block", height: "100%" }, Tn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
  const n = M("listState"), o = gt("sizeRanges"), r = M("useWindowScroll"), s = M("customScrollParent"), i = gt("windowScrollContainerState"), l = gt("scrollContainerState"), c = s || r ? i : l, u = M("itemContent"), f = M("context"), S = M("groupContent"), p = M("trackItemSizes"), m = M("itemSize"), w = M("log"), I = gt("gap"), C = M("horizontalDirection"), { callbackRef: g } = On(
    o,
    m,
    p,
    e ? Yt : c,
    w,
    I,
    s,
    C,
    M("skipAnimationFrameInResizeObserver")
  ), [a, T] = H.useState(0);
  Je("deviation", (k) => {
    a !== k && T(k);
  });
  const b = M("EmptyPlaceholder"), h = M("ScrollSeekPlaceholder") || er, d = M("ListComponent"), R = M("ItemComponent"), B = M("GroupComponent"), O = M("computeItemKey"), L = M("isSeeking"), V = M("groupIndices").length > 0, D = M("alignToBottom"), J = M("initialItemFinalLocationReached"), nt = e ? {} : {
    boxSizing: "border-box",
    ...C ? {
      display: "inline-block",
      height: "100%",
      marginLeft: a !== 0 ? a : D ? "auto" : 0,
      paddingLeft: n.offsetTop,
      paddingRight: n.offsetBottom,
      whiteSpace: "nowrap"
    } : {
      marginTop: a !== 0 ? a : D ? "auto" : 0,
      paddingBottom: n.offsetBottom,
      paddingTop: n.offsetTop
    },
    ...J ? {} : { visibility: "hidden" }
  };
  return !e && n.totalCount === 0 && b ? /* @__PURE__ */ z(b, { ...Z(b, f) }) : /* @__PURE__ */ z(
    d,
    {
      ...Z(d, f),
      "data-testid": e ? "virtuoso-top-item-list" : "virtuoso-item-list",
      ref: g,
      style: nt,
      children: (e ? n.topItems : n.items).map((k) => {
        const q = k.originalIndex, st = O(q + n.firstItemIndex, k.data, f);
        return L ? /* @__PURE__ */ $t(
          h,
          {
            ...Z(h, f),
            height: k.size,
            index: k.index,
            key: st,
            type: k.type || "item",
            ...k.type === "group" ? {} : { groupIndex: k.groupIndex }
          }
        ) : k.type === "group" ? /* @__PURE__ */ $t(
          B,
          {
            ...Z(B, f),
            "data-index": q,
            "data-item-index": k.index,
            "data-known-size": k.size,
            key: st,
            style: nr
          },
          S(k.index, f)
        ) : /* @__PURE__ */ $t(
          R,
          {
            ...Z(R, f),
            ...to(R, k.data),
            "data-index": q,
            "data-item-group-index": k.groupIndex,
            "data-item-index": k.index,
            "data-known-size": k.size,
            key: st,
            style: C ? or : Qn
          },
          V ? u(k.index, k.groupIndex, k.data, f) : u(k.index, k.data, f)
        );
      })
    }
  );
}), rr = {
  height: "100%",
  outline: "none",
  overflowY: "auto",
  position: "relative",
  WebkitOverflowScrolling: "touch"
}, sr = {
  outline: "none",
  overflowX: "auto",
  position: "relative"
}, Zt = (t) => ({
  height: "100%",
  position: "absolute",
  top: 0,
  width: "100%",
  ...t ? { display: "flex", flexDirection: "column" } : {}
}), ir = {
  position: Jn(),
  top: 0,
  width: "100%",
  zIndex: 1
};
function Z(t, e) {
  if (typeof t != "string")
    return { context: e };
}
function to(t, e) {
  return { item: typeof t == "string" ? void 0 : e };
}
const lr = /* @__PURE__ */ H.memo(function() {
  const e = M("HeaderComponent"), n = gt("headerHeight"), o = M("HeaderFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    M("skipAnimationFrameInResizeObserver")
  ), s = M("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
}), cr = /* @__PURE__ */ H.memo(function() {
  const e = M("FooterComponent"), n = gt("footerHeight"), o = M("HeaderFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    M("skipAnimationFrameInResizeObserver")
  ), s = M("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
});
function Ze({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
  return H.memo(function({ children: s, style: i, ...l }) {
    const c = n("scrollContainerState"), u = e("ScrollerComponent"), f = n("smoothScrollTargetReached"), S = e("scrollerRef"), p = e("context"), m = e("horizontalDirection") || !1, { scrollByCallback: w, scrollerRef: I, scrollToCallback: C } = Xn(
      c,
      f,
      u,
      S,
      void 0,
      m
    );
    return t("scrollTo", C), t("scrollBy", w), /* @__PURE__ */ z(
      u,
      {
        "data-testid": "virtuoso-scroller",
        "data-virtuoso-scroller": !0,
        ref: I,
        style: { ...m ? sr : rr, ...i },
        tabIndex: 0,
        ...l,
        ...Z(u, p),
        children: s
      }
    );
  });
}
function Xe({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
  return H.memo(function({ children: s, style: i, ...l }) {
    const c = n("windowScrollContainerState"), u = e("ScrollerComponent"), f = n("smoothScrollTargetReached"), S = e("totalListHeight"), p = e("deviation"), m = e("customScrollParent"), w = e("context"), I = H.useRef(null), C = e("scrollerRef"), { scrollByCallback: g, scrollerRef: a, scrollToCallback: T } = Xn(
      c,
      f,
      u,
      C,
      m
    );
    return Zn(() => {
      var b;
      return a.current = m || ((b = I.current) == null ? void 0 : b.ownerDocument.defaultView), () => {
        a.current = null;
      };
    }, [a, m]), t("windowScrollTo", T), t("scrollBy", g), /* @__PURE__ */ z(
      u,
      {
        ref: I,
        "data-virtuoso-scroller": !0,
        style: { position: "relative", ...i, ...S !== 0 ? { height: S + p } : {} },
        ...l,
        ...Z(u, w),
        children: s
      }
    );
  });
}
const ur = ({ children: t }) => {
  const e = H.useContext(Re), n = gt("viewportHeight"), o = gt("fixedItemHeight"), r = M("alignToBottom"), s = M("horizontalDirection"), i = H.useMemo(
    () => ne(n, (c) => wt(c, s ? "width" : "height")),
    [n, s]
  ), l = Ht(i, !0, M("skipAnimationFrameInResizeObserver"));
  return H.useEffect(() => {
    e && (n(e.viewportHeight), o(e.itemHeight));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: l, style: Zt(r), children: t });
}, ar = ({ children: t }) => {
  const e = H.useContext(Re), n = gt("windowViewportRect"), o = gt("fixedItemHeight"), r = M("customScrollParent"), s = Ge(
    n,
    r,
    M("skipAnimationFrameInResizeObserver")
  ), i = M("alignToBottom");
  return H.useEffect(() => {
    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(i), children: t });
}, dr = ({ children: t }) => {
  const e = M("TopItemListComponent") || "div", n = M("headerHeight"), o = { ...ir, marginTop: `${n}px` }, r = M("context");
  return /* @__PURE__ */ z(e, { style: o, ...Z(e, r), children: t });
}, fr = /* @__PURE__ */ H.memo(function(e) {
  const n = M("useWindowScroll"), o = M("topItemsIndexes").length > 0, r = M("customScrollParent"), s = M("context"), i = r || n ? pr : mr, l = r || n ? ar : ur;
  return /* @__PURE__ */ Kt(i, { ...e, ...Z(i, s), children: [
    o && /* @__PURE__ */ z(dr, { children: /* @__PURE__ */ z(Tn, { showTopList: !0 }) }),
    /* @__PURE__ */ Kt(l, { children: [
      /* @__PURE__ */ z(lr, {}),
      /* @__PURE__ */ z(Tn, {}),
      /* @__PURE__ */ z(cr, {})
    ] })
  ] });
}), {
  Component: eo,
  useEmitter: Je,
  useEmitterValue: M,
  usePublisher: gt
} = /* @__PURE__ */ qe(
  tr,
  {
    events: {
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      endReached: "endReached",
      groupIndices: "groupIndices",
      isScrolling: "isScrolling",
      itemsRendered: "itemsRendered",
      rangeChanged: "rangeChanged",
      startReached: "startReached",
      totalListHeightChanged: "totalListHeightChanged"
    },
    methods: {
      autoscrollToBottom: "autoscrollToBottom",
      getState: "getState",
      scrollBy: "scrollBy",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollToIndex: "scrollToIndex"
    },
    optional: {
      alignToBottom: "alignToBottom",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      components: "components",
      computeItemKey: "computeItemKey",
      context: "context",
      customScrollParent: "customScrollParent",
      data: "data",
      defaultItemHeight: "defaultItemHeight",
      firstItemIndex: "firstItemIndex",
      fixedItemHeight: "fixedItemHeight",
      followOutput: "followOutput",
      groupContent: "groupContent",
      groupCounts: "groupCounts",
      headerFooterTag: "HeaderFooterTag",
      horizontalDirection: "horizontalDirection",
      increaseViewportBy: "increaseViewportBy",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      itemContent: "itemContent",
      itemSize: "itemSize",
      logLevel: "logLevel",
      overscan: "overscan",
      restoreStateFrom: "restoreStateFrom",
      scrollerRef: "scrollerRef",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver",
      topItemCount: "topItemCount",
      totalCount: "totalCount",
      useWindowScroll: "useWindowScroll"
    },
    required: {}
  },
  fr
), mr = /* @__PURE__ */ Ze({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), pr = /* @__PURE__ */ Xe({ useEmitter: Je, useEmitterValue: M, usePublisher: gt }), Kr = eo, jr = eo, hr = /* @__PURE__ */ U(() => {
  const t = y((c) => /* @__PURE__ */ Kt("td", { children: [
    "Item $",
    c
  ] })), e = y(null), n = y(null), o = y(null), r = y({}), s = y(Ye), i = y(Yt), l = (c, u = null) => ct(
    x(
      r,
      E((f) => f[c]),
      Y()
    ),
    u
  );
  return {
    components: r,
    computeItemKey: s,
    context: e,
    EmptyPlaceholder: l("EmptyPlaceholder"),
    FillerRow: l("FillerRow"),
    fixedFooterContent: o,
    fixedHeaderContent: n,
    itemContent: t,
    ScrollerComponent: l("Scroller", "div"),
    scrollerRef: i,
    ScrollSeekPlaceholder: l("ScrollSeekPlaceholder"),
    TableBodyComponent: l("TableBody", "tbody"),
    TableComponent: l("Table", "table"),
    TableFooterComponent: l("TableFoot", "tfoot"),
    TableHeadComponent: l("TableHead", "thead"),
    TableRowComponent: l("TableRow", "tr")
  };
}), gr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(qn, hr)
), Ir = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { height: t } }) }), Sr = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { border: 0, height: t, padding: 0 } }) }), xr = { overflowAnchor: "none" }, Cn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
  const n = _("listState"), o = _("computeItemKey"), r = _("firstItemIndex"), s = _("isSeeking"), i = _("ScrollSeekPlaceholder") || Ir, l = _("context"), c = _("TableRowComponent"), u = _("fixedHeaderHeight"), f = _("itemContent"), S = (e ? n.topItems : []).reduce((m, w, I) => (I === 0 ? m.push(w.size) : m.push(m[I - 1] + w.size), m), []), p = (e ? n.topItems : n.items).map((m) => {
    const w = m.originalIndex, I = o(w + r, m.data, l), C = e ? w === 0 ? 0 : S[w - 1] : 0;
    return s ? /* @__PURE__ */ $t(
      i,
      {
        ...Z(i, l),
        height: m.size,
        index: m.index,
        key: I,
        type: m.type || "item"
      }
    ) : /* @__PURE__ */ $t(
      c,
      {
        ...Z(c, l),
        ...to(c, m.data),
        "data-index": w,
        "data-item-index": m.index,
        "data-known-size": m.size,
        key: I,
        style: e ? { overflowAnchor: "none", position: "sticky", top: u + C, zIndex: 2 } : xr
      },
      f(m.index, m.data, l)
    );
  });
  return /* @__PURE__ */ z(io, { children: p });
}), Tr = /* @__PURE__ */ H.memo(function() {
  const e = _("listState"), n = _("topItemsIndexes").length > 0, o = Tt("sizeRanges"), r = _("useWindowScroll"), s = _("customScrollParent"), i = Tt("windowScrollContainerState"), l = Tt("scrollContainerState"), c = s || r ? i : l, u = _("trackItemSizes"), f = _("itemSize"), S = _("log"), { callbackRef: p, ref: m } = On(
    o,
    f,
    u,
    c,
    S,
    void 0,
    s,
    !1,
    _("skipAnimationFrameInResizeObserver")
  ), [w, I] = H.useState(0);
  Qe("deviation", (V) => {
    w !== V && (m.current.style.marginTop = `${V}px`, I(V));
  });
  const C = _("EmptyPlaceholder"), g = _("FillerRow") || Sr, a = _("TableBodyComponent"), T = _("paddingTopAddition"), b = _("statefulTotalCount"), h = _("context");
  if (b === 0 && C)
    return /* @__PURE__ */ z(C, { ...Z(C, h) });
  const d = (n ? e.topItems : []).reduce((V, D) => V + D.size, 0), R = e.offsetTop + T + w - d, B = e.offsetBottom, O = R > 0 ? /* @__PURE__ */ z(g, { context: h, height: R }, "padding-top") : null, L = B > 0 ? /* @__PURE__ */ z(g, { context: h, height: B }, "padding-bottom") : null;
  return /* @__PURE__ */ Kt(a, { "data-testid": "virtuoso-item-list", ref: p, ...Z(a, h), children: [
    O,
    n && /* @__PURE__ */ z(Cn, { showTopList: !0 }),
    /* @__PURE__ */ z(Cn, {}),
    L
  ] });
}), Cr = ({ children: t }) => {
  const e = H.useContext(Re), n = Tt("viewportHeight"), o = Tt("fixedItemHeight"), r = Ht(
    H.useMemo(() => ne(n, (s) => wt(s, "height")), [n]),
    !0,
    _("skipAnimationFrameInResizeObserver")
  );
  return H.useEffect(() => {
    e && (n(e.viewportHeight), o(e.itemHeight));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: r, style: Zt(!1), children: t });
}, wr = ({ children: t }) => {
  const e = H.useContext(Re), n = Tt("windowViewportRect"), o = Tt("fixedItemHeight"), r = _("customScrollParent"), s = Ge(
    n,
    r,
    _("skipAnimationFrameInResizeObserver")
  );
  return H.useEffect(() => {
    e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(!1), children: t });
}, yr = /* @__PURE__ */ H.memo(function(e) {
  const n = _("useWindowScroll"), o = _("customScrollParent"), r = Tt("fixedHeaderHeight"), s = Tt("fixedFooterHeight"), i = _("fixedHeaderContent"), l = _("fixedFooterContent"), c = _("context"), u = Ht(
    H.useMemo(() => ne(r, (a) => wt(a, "height")), [r]),
    !0,
    _("skipAnimationFrameInResizeObserver")
  ), f = Ht(
    H.useMemo(() => ne(s, (a) => wt(a, "height")), [s]),
    !0,
    _("skipAnimationFrameInResizeObserver")
  ), S = o || n ? Rr : br, p = o || n ? wr : Cr, m = _("TableComponent"), w = _("TableHeadComponent"), I = _("TableFooterComponent"), C = i ? /* @__PURE__ */ z(
    w,
    {
      ref: u,
      style: { position: "sticky", top: 0, zIndex: 2 },
      ...Z(w, c),
      children: i()
    },
    "TableHead"
  ) : null, g = l ? /* @__PURE__ */ z(
    I,
    {
      ref: f,
      style: { bottom: 0, position: "sticky", zIndex: 1 },
      ...Z(I, c),
      children: l()
    },
    "TableFoot"
  ) : null;
  return /* @__PURE__ */ z(S, { ...e, ...Z(S, c), children: /* @__PURE__ */ z(p, { children: /* @__PURE__ */ Kt(m, { style: { borderSpacing: 0, overflowAnchor: "none" }, ...Z(m, c), children: [
    C,
    /* @__PURE__ */ z(Tr, {}, "TableBody"),
    g
  ] }) }) });
}), {
  Component: vr,
  useEmitter: Qe,
  useEmitterValue: _,
  usePublisher: Tt
} = /* @__PURE__ */ qe(
  gr,
  {
    events: {
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      endReached: "endReached",
      groupIndices: "groupIndices",
      isScrolling: "isScrolling",
      itemsRendered: "itemsRendered",
      rangeChanged: "rangeChanged",
      startReached: "startReached",
      totalListHeightChanged: "totalListHeightChanged"
    },
    methods: {
      getState: "getState",
      scrollBy: "scrollBy",
      scrollIntoView: "scrollIntoView",
      scrollTo: "scrollTo",
      scrollToIndex: "scrollToIndex"
    },
    optional: {
      alignToBottom: "alignToBottom",
      atBottomThreshold: "atBottomThreshold",
      atTopThreshold: "atTopThreshold",
      components: "components",
      computeItemKey: "computeItemKey",
      context: "context",
      customScrollParent: "customScrollParent",
      data: "data",
      defaultItemHeight: "defaultItemHeight",
      firstItemIndex: "firstItemIndex",
      fixedFooterContent: "fixedFooterContent",
      fixedHeaderContent: "fixedHeaderContent",
      fixedItemHeight: "fixedItemHeight",
      followOutput: "followOutput",
      groupCounts: "groupCounts",
      increaseViewportBy: "increaseViewportBy",
      initialItemCount: "initialItemCount",
      initialScrollTop: "initialScrollTop",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      itemContent: "itemContent",
      itemSize: "itemSize",
      logLevel: "logLevel",
      overscan: "overscan",
      restoreStateFrom: "restoreStateFrom",
      scrollerRef: "scrollerRef",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      topItemCount: "topItemCount",
      totalCount: "totalCount",
      useWindowScroll: "useWindowScroll"
    },
    required: {}
  },
  yr
), br = /* @__PURE__ */ Ze({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt }), Rr = /* @__PURE__ */ Xe({ useEmitter: Qe, useEmitterValue: _, usePublisher: Tt }), qr = vr, wn = {
  bottom: 0,
  itemHeight: 0,
  items: [],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, Hr = {
  bottom: 0,
  itemHeight: 0,
  items: [{ index: 0 }],
  itemWidth: 0,
  offsetBottom: 0,
  offsetTop: 0,
  top: 0
}, { ceil: yn, floor: Ce, max: ee, min: Fe, round: vn } = Math;
function bn(t, e, n) {
  return Array.from({ length: e - t + 1 }).map((o, r) => ({ data: n === null ? null : n[r + t], index: r + t }));
}
function Er(t) {
  return {
    ...Hr,
    items: t
  };
}
function he(t, e) {
  return t && t.width === e.width && t.height === e.height;
}
function kr(t, e) {
  return t && t.column === e.column && t.row === e.row;
}
const Br = /* @__PURE__ */ U(
  ([
    { increaseViewportBy: t, listBoundary: e, overscan: n, visibleRange: o },
    { footerHeight: r, headerHeight: s, scrollBy: i, scrollContainerState: l, scrollTo: c, scrollTop: u, smoothScrollTargetReached: f, viewportHeight: S },
    p,
    m,
    { didMount: w, propsReady: I },
    { customScrollParent: C, useWindowScroll: g, windowScrollContainerState: a, windowScrollTo: T, windowViewportRect: b },
    h
  ]) => {
    const d = y(0), R = y(0), B = y(wn), O = y({ height: 0, width: 0 }), L = y({ height: 0, width: 0 }), V = $(), D = $(), J = y(0), nt = y(null), k = y({ column: 0, row: 0 }), q = $(), st = $(), dt = y(!1), St = y(0), ft = y(!0), ut = y(!1), At = y(!1);
    K(
      x(
        w,
        G(St),
        P(([v, N]) => !!N)
      ),
      () => {
        W(ft, !1);
      }
    ), K(
      x(
        rt(w, ft, L, O, St, ut),
        P(([v, N, Q, it, , tt]) => v && !N && Q.height !== 0 && it.height !== 0 && !tt)
      ),
      ([, , , , v]) => {
        W(ut, !0), $e(1, () => {
          W(V, v);
        }), Rt(x(u), () => {
          W(e, [0, 0]), W(ft, !0);
        });
      }
    ), F(
      x(
        st,
        P((v) => v != null && v.scrollTop > 0),
        vt(0)
      ),
      R
    ), K(
      x(
        w,
        G(st),
        P(([, v]) => v != null)
      ),
      ([, v]) => {
        v && (W(O, v.viewport), W(L, v.item), W(k, v.gap), v.scrollTop > 0 && (W(dt, !0), Rt(x(u, jt(1)), (N) => {
          W(dt, !1);
        }), W(c, { top: v.scrollTop })));
      }
    ), F(
      x(
        O,
        E(({ height: v }) => v)
      ),
      S
    ), F(
      x(
        rt(
          A(O, he),
          A(L, he),
          A(k, (v, N) => v && v.column === N.column && v.row === N.row),
          A(u)
        ),
        E(([v, N, Q, it]) => ({
          gap: Q,
          item: N,
          scrollTop: it,
          viewport: v
        }))
      ),
      q
    ), F(
      x(
        rt(
          A(d),
          o,
          A(k, kr),
          A(L, he),
          A(O, he),
          A(nt),
          A(R),
          A(dt),
          A(ft),
          A(St)
        ),
        P(([, , , , , , , v]) => !v),
        E(
          ([
            v,
            [N, Q],
            it,
            tt,
            Bt,
            Jt,
            Nt,
            ,
            de,
            Ot
          ]) => {
            const { column: Ft, row: Qt } = it, { height: fe, width: He } = tt, { width: tn } = Bt;
            if (Nt === 0 && (v === 0 || tn === 0))
              return wn;
            if (He === 0) {
              const sn = Ue(Ot, v), so = sn + Math.max(Nt - 1, 0);
              return Er(bn(sn, so, Jt));
            }
            const me = no(tn, He, Ft);
            let Dt, Wt;
            de ? N === 0 && Q === 0 && Nt > 0 ? (Dt = 0, Wt = Nt - 1) : (Dt = me * Ce((N + Qt) / (fe + Qt)), Wt = me * yn((Q + Qt) / (fe + Qt)) - 1, Wt = Fe(v - 1, ee(Wt, me - 1)), Dt = Fe(Wt, ee(0, Dt))) : (Dt = 0, Wt = -1);
            const en = bn(Dt, Wt, Jt), { bottom: nn, top: on } = Rn(Bt, it, tt, en), rn = yn(v / me), ro = rn * fe + (rn - 1) * Qt - nn;
            return { bottom: nn, itemHeight: fe, items: en, itemWidth: He, offsetBottom: ro, offsetTop: on, top: on };
          }
        )
      ),
      B
    ), F(
      x(
        nt,
        P((v) => v !== null),
        E((v) => v.length)
      ),
      d
    ), F(
      x(
        rt(O, L, B, k),
        P(([v, N, { items: Q }]) => Q.length > 0 && N.height !== 0 && v.height !== 0),
        E(([v, N, { items: Q }, it]) => {
          const { bottom: tt, top: Bt } = Rn(v, it, N, Q);
          return [Bt, tt];
        }),
        Y(se)
      ),
      e
    );
    const xt = y(!1);
    F(
      x(
        u,
        G(xt),
        E(([v, N]) => N || v !== 0)
      ),
      xt
    );
    const Xt = pt(
      x(
        rt(B, d),
        P(([{ items: v }]) => v.length > 0),
        G(xt),
        P(([[v, N], Q]) => {
          const tt = v.items[v.items.length - 1].index === N - 1;
          return (Q || v.bottom > 0 && v.itemHeight > 0 && v.offsetBottom === 0 && v.items.length === N) && tt;
        }),
        E(([[, v]]) => v - 1),
        Y()
      )
    ), Mt = pt(
      x(
        A(B),
        P(({ items: v }) => v.length > 0 && v[0].index === 0),
        vt(0),
        Y()
      )
    ), yt = pt(
      x(
        A(B),
        G(dt),
        P(([{ items: v }, N]) => v.length > 0 && !N),
        E(([{ items: v }]) => ({
          endIndex: v[v.length - 1].index,
          startIndex: v[0].index
        })),
        Y(An),
        Lt(0)
      )
    );
    F(yt, m.scrollSeekRangeChanged), F(
      x(
        V,
        G(O, L, d, k),
        E(([v, N, Q, it, tt]) => {
          const Bt = Nn(v), { align: Jt, behavior: Nt, offset: de } = Bt;
          let Ot = Bt.index;
          Ot === "LAST" && (Ot = it - 1), Ot = ee(0, Ot, Fe(it - 1, Ot));
          let Ft = Ae(N, tt, Q, Ot);
          return Jt === "end" ? Ft = vn(Ft - N.height + Q.height) : Jt === "center" && (Ft = vn(Ft - N.height / 2 + Q.height / 2)), de && (Ft += de), { behavior: Nt, top: Ft };
        })
      ),
      c
    );
    const kt = ct(
      x(
        B,
        E((v) => v.offsetBottom + v.bottom)
      ),
      0
    );
    return F(
      x(
        b,
        E((v) => ({ height: v.visibleHeight, width: v.visibleWidth }))
      ),
      O
    ), {
      customScrollParent: C,
      // input
      data: nt,
      deviation: J,
      footerHeight: r,
      gap: k,
      headerHeight: s,
      increaseViewportBy: t,
      initialItemCount: R,
      itemDimensions: L,
      overscan: n,
      restoreStateFrom: st,
      scrollBy: i,
      scrollContainerState: l,
      scrollHeight: D,
      scrollTo: c,
      scrollToIndex: V,
      scrollTop: u,
      smoothScrollTargetReached: f,
      totalCount: d,
      useWindowScroll: g,
      viewportDimensions: O,
      windowScrollContainerState: a,
      windowScrollTo: T,
      windowViewportRect: b,
      ...m,
      // output
      gridState: B,
      horizontalDirection: At,
      initialTopMostItemIndex: St,
      totalListHeight: kt,
      ...p,
      endReached: Xt,
      propsReady: I,
      rangeChanged: yt,
      startReached: Mt,
      stateChanged: q,
      stateRestoreInProgress: dt,
      ...h
    };
  },
  X(Ke, at, ae, Kn, Pt, je, Vt)
);
function no(t, e, n) {
  return ee(1, Ce((t + n) / (Ce(e) + n)));
}
function Rn(t, e, n, o) {
  const { height: r } = n;
  if (r === void 0 || o.length === 0)
    return { bottom: 0, top: 0 };
  const s = Ae(t, e, n, o[0].index);
  return { bottom: Ae(t, e, n, o[o.length - 1].index) + r, top: s };
}
function Ae(t, e, n, o) {
  const r = no(t.width, n.width, e.column), s = Ce(o / r), i = s * n.height + ee(0, s - 1) * e.row;
  return i > 0 ? i + e.row : i;
}
const Or = /* @__PURE__ */ U(() => {
  const t = y((S) => `Item ${S}`), e = y({}), n = y(null), o = y("virtuoso-grid-item"), r = y("virtuoso-grid-list"), s = y(Ye), i = y("div"), l = y(Yt), c = (S, p = null) => ct(
    x(
      e,
      E((m) => m[S]),
      Y()
    ),
    p
  ), u = y(!1), f = y(!1);
  return F(A(f), u), {
    components: e,
    computeItemKey: s,
    context: n,
    FooterComponent: c("Footer"),
    HeaderComponent: c("Header"),
    headerFooterTag: i,
    itemClassName: o,
    ItemComponent: c("Item", "div"),
    itemContent: t,
    listClassName: r,
    ListComponent: c("List", "div"),
    readyStateChanged: u,
    reportReadyState: f,
    ScrollerComponent: c("Scroller", "div"),
    scrollerRef: l,
    ScrollSeekPlaceholder: c("ScrollSeekPlaceholder", "div")
  };
}), Fr = /* @__PURE__ */ U(
  ([t, e]) => ({ ...t, ...e }),
  X(Br, Or)
), Lr = /* @__PURE__ */ H.memo(function() {
  const e = et("gridState"), n = et("listClassName"), o = et("itemClassName"), r = et("itemContent"), s = et("computeItemKey"), i = et("isSeeking"), l = It("scrollHeight"), c = et("ItemComponent"), u = et("ListComponent"), f = et("ScrollSeekPlaceholder"), S = et("context"), p = It("itemDimensions"), m = It("gap"), w = et("log"), I = et("stateRestoreInProgress"), C = It("reportReadyState"), g = Ht(
    H.useMemo(
      () => (a) => {
        const T = a.parentElement.parentElement.scrollHeight;
        l(T);
        const b = a.firstChild;
        if (b) {
          const { height: h, width: d } = b.getBoundingClientRect();
          p({ height: h, width: d });
        }
        m({
          column: Hn("column-gap", getComputedStyle(a).columnGap, w),
          row: Hn("row-gap", getComputedStyle(a).rowGap, w)
        });
      },
      [l, p, m, w]
    ),
    !0,
    !1
  );
  return Zn(() => {
    e.itemHeight > 0 && e.itemWidth > 0 && C(!0);
  }, [e]), I ? null : /* @__PURE__ */ z(
    u,
    {
      className: n,
      ref: g,
      ...Z(u, S),
      "data-testid": "virtuoso-item-list",
      style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop },
      children: e.items.map((a) => {
        const T = s(a.index, a.data, S);
        return i ? /* @__PURE__ */ z(
          f,
          {
            ...Z(f, S),
            height: e.itemHeight,
            index: a.index,
            width: e.itemWidth
          },
          T
        ) : /* @__PURE__ */ $t(
          c,
          {
            ...Z(c, S),
            className: o,
            "data-index": a.index,
            key: T
          },
          r(a.index, a.data, S)
        );
      })
    }
  );
}), zr = H.memo(function() {
  const e = et("HeaderComponent"), n = It("headerHeight"), o = et("headerFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    !1
  ), s = et("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
}), Vr = H.memo(function() {
  const e = et("FooterComponent"), n = It("footerHeight"), o = et("headerFooterTag"), r = Ht(
    H.useMemo(
      () => (i) => {
        n(wt(i, "height"));
      },
      [n]
    ),
    !0,
    !1
  ), s = et("context");
  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...Z(e, s) }) }) : null;
}), Pr = ({ children: t }) => {
  const e = H.useContext(Yn), n = It("itemDimensions"), o = It("viewportDimensions"), r = Ht(
    H.useMemo(
      () => (s) => {
        o(s.getBoundingClientRect());
      },
      [o]
    ),
    !0,
    !1
  );
  return H.useEffect(() => {
    e && (o({ height: e.viewportHeight, width: e.viewportWidth }), n({ height: e.itemHeight, width: e.itemWidth }));
  }, [e, o, n]), /* @__PURE__ */ z("div", { ref: r, style: Zt(!1), children: t });
}, Ar = ({ children: t }) => {
  const e = H.useContext(Yn), n = It("windowViewportRect"), o = It("itemDimensions"), r = et("customScrollParent"), s = Ge(n, r, !1);
  return H.useEffect(() => {
    e && (o({ height: e.itemHeight, width: e.itemWidth }), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: e.viewportWidth }));
  }, [e, n, o]), /* @__PURE__ */ z("div", { ref: s, style: Zt(!1), children: t });
}, Mr = /* @__PURE__ */ H.memo(function({ ...e }) {
  const n = et("useWindowScroll"), o = et("customScrollParent"), r = o || n ? Gr : _r, s = o || n ? Ar : Pr, i = et("context");
  return /* @__PURE__ */ z(r, { ...e, ...Z(r, i), children: /* @__PURE__ */ Kt(s, { children: [
    /* @__PURE__ */ z(zr, {}),
    /* @__PURE__ */ z(Lr, {}),
    /* @__PURE__ */ z(Vr, {})
  ] }) });
}), {
  Component: Wr,
  useEmitter: oo,
  useEmitterValue: et,
  usePublisher: It
} = /* @__PURE__ */ qe(
  Fr,
  {
    events: {
      atBottomStateChange: "atBottomStateChange",
      atTopStateChange: "atTopStateChange",
      endReached: "endReached",
      isScrolling: "isScrolling",
      rangeChanged: "rangeChanged",
      readyStateChanged: "readyStateChanged",
      startReached: "startReached",
      stateChanged: "stateChanged"
    },
    methods: {
      scrollBy: "scrollBy",
      scrollTo: "scrollTo",
      scrollToIndex: "scrollToIndex"
    },
    optional: {
      components: "components",
      computeItemKey: "computeItemKey",
      context: "context",
      customScrollParent: "customScrollParent",
      data: "data",
      headerFooterTag: "headerFooterTag",
      increaseViewportBy: "increaseViewportBy",
      initialItemCount: "initialItemCount",
      initialTopMostItemIndex: "initialTopMostItemIndex",
      itemClassName: "itemClassName",
      itemContent: "itemContent",
      listClassName: "listClassName",
      logLevel: "logLevel",
      overscan: "overscan",
      restoreStateFrom: "restoreStateFrom",
      scrollerRef: "scrollerRef",
      scrollSeekConfiguration: "scrollSeekConfiguration",
      totalCount: "totalCount",
      useWindowScroll: "useWindowScroll"
    }
  },
  Mr
), _r = /* @__PURE__ */ Ze({ useEmitter: oo, useEmitterValue: et, usePublisher: It }), Gr = /* @__PURE__ */ Xe({ useEmitter: oo, useEmitterValue: et, usePublisher: It });
function Hn(t, e, n) {
  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, ht.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
}
const Yr = Wr;
export {
  jr as GroupedVirtuoso,
  ht as LogLevel,
  qr as TableVirtuoso,
  Kr as Virtuoso,
  Yr as VirtuosoGrid,
  Yn as VirtuosoGridMockContext,
  Re as VirtuosoMockContext
};
